/*! jQuery v2.1.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.1",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+-new Date,v=a.document,w=0,x=0,y=gb(),z=gb(),A=gb(),B=function(a,b){return a===b&&(l=!0),0},C="undefined",D=1<<31,E={}.hasOwnProperty,F=[],G=F.pop,H=F.push,I=F.push,J=F.slice,K=F.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1},L="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",N="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",O=N.replace("w","w#"),P="\\["+M+"*("+N+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+O+"))|)"+M+"*\\]",Q=":("+N+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+P+")*)|.*)\\)|)",R=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),S=new RegExp("^"+M+"*,"+M+"*"),T=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp("="+M+"*([^\\]'\"]*?)"+M+"*\\]","g"),V=new RegExp(Q),W=new RegExp("^"+O+"$"),X={ID:new RegExp("^#("+N+")"),CLASS:new RegExp("^\\.("+N+")"),TAG:new RegExp("^("+N.replace("w","w*")+")"),ATTR:new RegExp("^"+P),PSEUDO:new RegExp("^"+Q),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+L+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ab=/[+~]/,bb=/'|\\/g,cb=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),db=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)};try{I.apply(F=J.call(v.childNodes),v.childNodes),F[v.childNodes.length].nodeType}catch(eb){I={apply:F.length?function(a,b){H.apply(a,J.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function fb(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],!a||"string"!=typeof a)return d;if(1!==(k=b.nodeType)&&9!==k)return[];if(p&&!e){if(f=_.exec(a))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return I.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName&&b.getElementsByClassName)return I.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=9===k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(bb,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+qb(o[l]);w=ab.test(a)&&ob(b.parentNode)||b,x=o.join(",")}if(x)try{return I.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function gb(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function hb(a){return a[u]=!0,a}function ib(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function jb(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function kb(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||D)-(~a.sourceIndex||D);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function lb(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function mb(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function nb(a){return hb(function(b){return b=+b,hb(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function ob(a){return a&&typeof a.getElementsByTagName!==C&&a}c=fb.support={},f=fb.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=fb.setDocument=function(a){var b,e=a?a.ownerDocument||a:v,g=e.defaultView;return e!==n&&9===e.nodeType&&e.documentElement?(n=e,o=e.documentElement,p=!f(e),g&&g!==g.top&&(g.addEventListener?g.addEventListener("unload",function(){m()},!1):g.attachEvent&&g.attachEvent("onunload",function(){m()})),c.attributes=ib(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ib(function(a){return a.appendChild(e.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(e.getElementsByClassName)&&ib(function(a){return a.innerHTML="<div class='a'></div><div class='a i'></div>",a.firstChild.className="i",2===a.getElementsByClassName("i").length}),c.getById=ib(function(a){return o.appendChild(a).id=u,!e.getElementsByName||!e.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if(typeof b.getElementById!==C&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){var c=typeof a.getAttributeNode!==C&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return typeof b.getElementsByTagName!==C?b.getElementsByTagName(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return typeof b.getElementsByClassName!==C&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(e.querySelectorAll))&&(ib(function(a){a.innerHTML="<select msallowclip=''><option selected=''></option></select>",a.querySelectorAll("[msallowclip^='']").length&&q.push("[*^$]="+M+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+M+"*(?:value|"+L+")"),a.querySelectorAll(":checked").length||q.push(":checked")}),ib(function(a){var b=e.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+M+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ib(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",Q)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===e||a.ownerDocument===v&&t(v,a)?-1:b===e||b.ownerDocument===v&&t(v,b)?1:k?K.call(k,a)-K.call(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,f=a.parentNode,g=b.parentNode,h=[a],i=[b];if(!f||!g)return a===e?-1:b===e?1:f?-1:g?1:k?K.call(k,a)-K.call(k,b):0;if(f===g)return kb(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?kb(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},e):n},fb.matches=function(a,b){return fb(a,null,null,b)},fb.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return fb(b,n,null,[a]).length>0},fb.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},fb.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&E.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},fb.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},fb.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=fb.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=fb.selectors={cacheLength:50,createPseudo:hb,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(cb,db),a[3]=(a[3]||a[4]||a[5]||"").replace(cb,db),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||fb.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&fb.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(cb,db).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+M+")"+a+"("+M+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||typeof a.getAttribute!==C&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=fb.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||fb.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?hb(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=K.call(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:hb(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?hb(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),!c.pop()}}),has:hb(function(a){return function(b){return fb(a,b).length>0}}),contains:hb(function(a){return function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:hb(function(a){return W.test(a||"")||fb.error("unsupported lang: "+a),a=a.replace(cb,db).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:nb(function(){return[0]}),last:nb(function(a,b){return[b-1]}),eq:nb(function(a,b,c){return[0>c?c+b:c]}),even:nb(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:nb(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:nb(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:nb(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=lb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=mb(b);function pb(){}pb.prototype=d.filters=d.pseudos,d.setFilters=new pb,g=fb.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?fb.error(a):z(a,i).slice(0)};function qb(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function rb(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function sb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function tb(a,b,c){for(var d=0,e=b.length;e>d;d++)fb(a,b[d],c);return c}function ub(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function vb(a,b,c,d,e,f){return d&&!d[u]&&(d=vb(d)),e&&!e[u]&&(e=vb(e,f)),hb(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||tb(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:ub(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=ub(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?K.call(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=ub(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):I.apply(g,r)})}function wb(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=rb(function(a){return a===b},h,!0),l=rb(function(a){return K.call(b,a)>-1},h,!0),m=[function(a,c,d){return!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d))}];f>i;i++)if(c=d.relative[a[i].type])m=[rb(sb(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return vb(i>1&&sb(m),i>1&&qb(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&wb(a.slice(i,e)),f>e&&wb(a=a.slice(e)),f>e&&qb(a))}m.push(c)}return sb(m)}function xb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=G.call(i));s=ub(s)}I.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&fb.uniqueSort(i)}return k&&(w=v,j=t),r};return c?hb(f):f}return h=fb.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=wb(b[c]),f[u]?d.push(f):e.push(f);f=A(a,xb(e,d)),f.selector=a}return f},i=fb.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(cb,db),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(cb,db),ab.test(j[0].type)&&ob(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&qb(j),!a)return I.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,ab.test(a)&&ob(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ib(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ib(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||jb("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ib(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||jb("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ib(function(a){return null==a.getAttribute("disabled")})||jb(L,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),fb}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+Math.random()}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)
},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var ab=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bb=/<([\w:]+)/,cb=/<|&#?\w+;/,db=/<(?:script|style|link)/i,eb=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/^$|\/(?:java|ecma)script/i,gb=/^true\/(.*)/,hb=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ib={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ib.optgroup=ib.option,ib.tbody=ib.tfoot=ib.colgroup=ib.caption=ib.thead,ib.th=ib.td;function jb(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function kb(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function lb(a){var b=gb.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function mb(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function nb(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function ob(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pb(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=ob(h),f=ob(a),d=0,e=f.length;e>d;d++)pb(f[d],g[d]);if(b)if(c)for(f=f||ob(a),g=g||ob(h),d=0,e=f.length;e>d;d++)nb(f[d],g[d]);else nb(a,h);return g=ob(h,"script"),g.length>0&&mb(g,!i&&ob(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(cb.test(e)){f=f||k.appendChild(b.createElement("div")),g=(bb.exec(e)||["",""])[1].toLowerCase(),h=ib[g]||ib._default,f.innerHTML=h[1]+e.replace(ab,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=ob(k.appendChild(e),"script"),i&&mb(f),c)){j=0;while(e=f[j++])fb.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(ob(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&mb(ob(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(ob(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!db.test(a)&&!ib[(bb.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(ab,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(ob(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(ob(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&eb.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(ob(c,"script"),kb),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,ob(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,lb),j=0;g>j;j++)h=f[j],fb.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(hb,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qb,rb={};function sb(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function tb(a){var b=l,c=rb[a];return c||(c=sb(a,b),"none"!==c&&c||(qb=(qb||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qb[0].contentDocument,b.write(),b.close(),c=sb(a,b),qb.detach()),rb[a]=c),c}var ub=/^margin/,vb=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wb=function(a){return a.ownerDocument.defaultView.getComputedStyle(a,null)};function xb(a,b,c){var d,e,f,g,h=a.style;return c=c||wb(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),vb.test(g)&&ub.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function yb(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var zb=/^(none|table(?!-c[ea]).+)/,Ab=new RegExp("^("+Q+")(.*)$","i"),Bb=new RegExp("^([+-])=("+Q+")","i"),Cb={position:"absolute",visibility:"hidden",display:"block"},Db={letterSpacing:"0",fontWeight:"400"},Eb=["Webkit","O","Moz","ms"];function Fb(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Eb.length;while(e--)if(b=Eb[e]+c,b in a)return b;return d}function Gb(a,b,c){var d=Ab.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Hb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ib(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wb(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xb(a,b,f),(0>e||null==e)&&(e=a.style[b]),vb.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Hb(a,b,c||(g?"border":"content"),d,f)+"px"}function Jb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",tb(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xb(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fb(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Bb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fb(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xb(a,b,d)),"normal"===e&&b in Db&&(e=Db[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?zb.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Cb,function(){return Ib(a,b,d)}):Ib(a,b,d):void 0},set:function(a,c,d){var e=d&&wb(a);return Gb(a,c,d?Hb(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=yb(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xb,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ub.test(a)||(n.cssHooks[a+b].set=Gb)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wb(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Jb(this,!0)},hide:function(){return Jb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Kb(a,b,c,d,e){return new Kb.prototype.init(a,b,c,d,e)}n.Tween=Kb,Kb.prototype={constructor:Kb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Kb.propHooks[this.prop];return a&&a.get?a.get(this):Kb.propHooks._default.get(this)},run:function(a){var b,c=Kb.propHooks[this.prop];return this.pos=b=this.options.duration?n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Kb.propHooks._default.set(this),this}},Kb.prototype.init.prototype=Kb.prototype,Kb.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Kb.propHooks.scrollTop=Kb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Kb.prototype.init,n.fx.step={};var Lb,Mb,Nb=/^(?:toggle|show|hide)$/,Ob=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pb=/queueHooks$/,Qb=[Vb],Rb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Ob.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Ob.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sb(){return setTimeout(function(){Lb=void 0}),Lb=n.now()}function Tb(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ub(a,b,c){for(var d,e=(Rb[b]||[]).concat(Rb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Vb(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||tb(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Nb.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?tb(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ub(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wb(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xb(a,b,c){var d,e,f=0,g=Qb.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Lb||Sb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:Lb||Sb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wb(k,j.opts.specialEasing);g>f;f++)if(d=Qb[f].call(j,a,k,j.opts))return d;return n.map(k,Ub,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xb,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Rb[c]=Rb[c]||[],Rb[c].unshift(b)},prefilter:function(a,b){b?Qb.unshift(a):Qb.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xb(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Tb(b,!0),a,d,e)}}),n.each({slideDown:Tb("show"),slideUp:Tb("hide"),slideToggle:Tb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(Lb=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),Lb=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Mb||(Mb=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Mb),Mb=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Yb,Zb,$b=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Zb:Yb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))
},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Zb={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$b[b]||n.find.attr;$b[b]=function(a,b,d){var e,f;return d||(f=$b[b],$b[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$b[b]=f),e}});var _b=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_b.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ac=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ac," ").indexOf(b)>=0)return!0;return!1}});var bc=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bc,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cc=n.now(),dc=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var ec,fc,gc=/#.*$/,hc=/([?&])_=[^&]*/,ic=/^(.*?):[ \t]*([^\r\n]*)$/gm,jc=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,kc=/^(?:GET|HEAD)$/,lc=/^\/\//,mc=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,nc={},oc={},pc="*/".concat("*");try{fc=location.href}catch(qc){fc=l.createElement("a"),fc.href="",fc=fc.href}ec=mc.exec(fc.toLowerCase())||[];function rc(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function sc(a,b,c,d){var e={},f=a===oc;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function tc(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function uc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function vc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:fc,type:"GET",isLocal:jc.test(ec[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":pc,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?tc(tc(a,n.ajaxSettings),b):tc(n.ajaxSettings,a)},ajaxPrefilter:rc(nc),ajaxTransport:rc(oc),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=ic.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||fc)+"").replace(gc,"").replace(lc,ec[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=mc.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===ec[1]&&h[2]===ec[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(ec[3]||("http:"===ec[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),sc(nc,k,b,v),2===t)return v;i=k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!kc.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(dc.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=hc.test(d)?d.replace(hc,"$1_="+cc++):d+(dc.test(d)?"&":"?")+"_="+cc++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+pc+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=sc(oc,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=uc(k,v,f)),u=vc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var wc=/%20/g,xc=/\[\]$/,yc=/\r?\n/g,zc=/^(?:submit|button|image|reset|file)$/i,Ac=/^(?:input|select|textarea|keygen)/i;function Bc(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||xc.test(a)?d(a,e):Bc(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Bc(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Bc(c,a[c],b,e);return d.join("&").replace(wc,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&Ac.test(this.nodeName)&&!zc.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(yc,"\r\n")}}):{name:b.name,value:c.replace(yc,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Cc=0,Dc={},Ec={0:200,1223:204},Fc=n.ajaxSettings.xhr();a.ActiveXObject&&n(a).on("unload",function(){for(var a in Dc)Dc[a]()}),k.cors=!!Fc&&"withCredentials"in Fc,k.ajax=Fc=!!Fc,n.ajaxTransport(function(a){var b;return k.cors||Fc&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Cc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Dc[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Ec[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Dc[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Gc=[],Hc=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Gc.pop()||n.expando+"_"+cc++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Hc.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Hc.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Hc,"$1"+e):b.jsonp!==!1&&(b.url+=(dc.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Gc.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Ic=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Ic)return Ic.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Jc=a.document.documentElement;function Kc(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Kc(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Jc;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Jc})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Kc(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=yb(k.pixelPosition,function(a,c){return c?(c=xb(a,b),vb.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Lc=a.jQuery,Mc=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Mc),b&&a.jQuery===n&&(a.jQuery=Lc),n},typeof b===U&&(a.jQuery=a.$=n),n});
//# sourceMappingURL=jquery.min.map

/*! VelocityJS.org (1.1.0). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */
/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */
!function(e){function t(e){var t=e.length,r=$.type(e);return"function"===r||$.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===r||0===t||"number"==typeof t&&t>0&&t-1 in e}if(!e.jQuery){var $=function(e,t){return new $.fn.init(e,t)};$.isWindow=function(e){return null!=e&&e==e.window},$.type=function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?a[o.call(e)]||"object":typeof e},$.isArray=Array.isArray||function(e){return"array"===$.type(e)},$.isPlainObject=function(e){var t;if(!e||"object"!==$.type(e)||e.nodeType||$.isWindow(e))return!1;try{if(e.constructor&&!n.call(e,"constructor")&&!n.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}for(t in e);return void 0===t||n.call(e,t)},$.each=function(e,r,a){var n,o=0,i=e.length,s=t(e);if(a){if(s)for(;i>o&&(n=r.apply(e[o],a),n!==!1);o++);else for(o in e)if(n=r.apply(e[o],a),n===!1)break}else if(s)for(;i>o&&(n=r.call(e[o],o,e[o]),n!==!1);o++);else for(o in e)if(n=r.call(e[o],o,e[o]),n===!1)break;return e},$.data=function(e,t,a){if(void 0===a){var n=e[$.expando],o=n&&r[n];if(void 0===t)return o;if(o&&t in o)return o[t]}else if(void 0!==t){var n=e[$.expando]||(e[$.expando]=++$.uuid);return r[n]=r[n]||{},r[n][t]=a,a}},$.removeData=function(e,t){var a=e[$.expando],n=a&&r[a];n&&$.each(t,function(e,t){delete n[t]})},$.extend=function(){var e,t,r,a,n,o,i=arguments[0]||{},s=1,l=arguments.length,u=!1;for("boolean"==typeof i&&(u=i,i=arguments[s]||{},s++),"object"!=typeof i&&"function"!==$.type(i)&&(i={}),s===l&&(i=this,s--);l>s;s++)if(null!=(n=arguments[s]))for(a in n)e=i[a],r=n[a],i!==r&&(u&&r&&($.isPlainObject(r)||(t=$.isArray(r)))?(t?(t=!1,o=e&&$.isArray(e)?e:[]):o=e&&$.isPlainObject(e)?e:{},i[a]=$.extend(u,o,r)):void 0!==r&&(i[a]=r));return i},$.queue=function(e,r,a){function n(e,r){var a=r||[];return null!=e&&(t(Object(e))?!function(e,t){for(var r=+t.length,a=0,n=e.length;r>a;)e[n++]=t[a++];if(r!==r)for(;void 0!==t[a];)e[n++]=t[a++];return e.length=n,e}(a,"string"==typeof e?[e]:e):[].push.call(a,e)),a}if(e){r=(r||"fx")+"queue";var o=$.data(e,r);return a?(!o||$.isArray(a)?o=$.data(e,r,n(a)):o.push(a),o):o||[]}},$.dequeue=function(e,t){$.each(e.nodeType?[e]:e,function(e,r){t=t||"fx";var a=$.queue(r,t),n=a.shift();"inprogress"===n&&(n=a.shift()),n&&("fx"===t&&a.unshift("inprogress"),n.call(r,function(){$.dequeue(r,t)}))})},$.fn=$.prototype={init:function(e){if(e.nodeType)return this[0]=e,this;throw new Error("Not a DOM node.")},offset:function(){var t=this[0].getBoundingClientRect?this[0].getBoundingClientRect():{top:0,left:0};return{top:t.top+(e.pageYOffset||document.scrollTop||0)-(document.clientTop||0),left:t.left+(e.pageXOffset||document.scrollLeft||0)-(document.clientLeft||0)}},position:function(){function e(){for(var e=this.offsetParent||document;e&&"html"===!e.nodeType.toLowerCase&&"static"===e.style.position;)e=e.offsetParent;return e||document}var t=this[0],e=e.apply(t),r=this.offset(),a=/^(?:body|html)$/i.test(e.nodeName)?{top:0,left:0}:$(e).offset();return r.top-=parseFloat(t.style.marginTop)||0,r.left-=parseFloat(t.style.marginLeft)||0,e.style&&(a.top+=parseFloat(e.style.borderTopWidth)||0,a.left+=parseFloat(e.style.borderLeftWidth)||0),{top:r.top-a.top,left:r.left-a.left}}};var r={};$.expando="velocity"+(new Date).getTime(),$.uuid=0;for(var a={},n=a.hasOwnProperty,o=a.toString,i="Boolean Number String Function Array Date RegExp Object Error".split(" "),s=0;s<i.length;s++)a["[object "+i[s]+"]"]=i[s].toLowerCase();$.fn.init.prototype=$.fn,e.Velocity={Utilities:$}}}(window),function(e){"object"==typeof module&&"object"==typeof module.exports?module.exports=e():"function"==typeof define&&define.amd?define(e):e()}(function(){return function(e,t,r,a){function n(e){for(var t=-1,r=e?e.length:0,a=[];++t<r;){var n=e[t];n&&a.push(n)}return a}function o(e){return g.isWrapped(e)?e=[].slice.call(e):g.isNode(e)&&(e=[e]),e}function i(e){var t=$.data(e,"velocity");return null===t?a:t}function s(e){return function(t){return Math.round(t*e)*(1/e)}}function l(e,r,a,n){function o(e,t){return 1-3*t+3*e}function i(e,t){return 3*t-6*e}function s(e){return 3*e}function l(e,t,r){return((o(t,r)*e+i(t,r))*e+s(t))*e}function u(e,t,r){return 3*o(t,r)*e*e+2*i(t,r)*e+s(t)}function c(t,r){for(var n=0;m>n;++n){var o=u(r,e,a);if(0===o)return r;var i=l(r,e,a)-t;r-=i/o}return r}function p(){for(var t=0;b>t;++t)w[t]=l(t*x,e,a)}function f(t,r,n){var o,i,s=0;do i=r+(n-r)/2,o=l(i,e,a)-t,o>0?n=i:r=i;while(Math.abs(o)>h&&++s<v);return i}function d(t){for(var r=0,n=1,o=b-1;n!=o&&w[n]<=t;++n)r+=x;--n;var i=(t-w[n])/(w[n+1]-w[n]),s=r+i*x,l=u(s,e,a);return l>=y?c(t,s):0==l?s:f(t,r,r+x)}function g(){V=!0,(e!=r||a!=n)&&p()}var m=4,y=.001,h=1e-7,v=10,b=11,x=1/(b-1),S="Float32Array"in t;if(4!==arguments.length)return!1;for(var P=0;4>P;++P)if("number"!=typeof arguments[P]||isNaN(arguments[P])||!isFinite(arguments[P]))return!1;e=Math.min(e,1),a=Math.min(a,1),e=Math.max(e,0),a=Math.max(a,0);var w=S?new Float32Array(b):new Array(b),V=!1,C=function(t){return V||g(),e===r&&a===n?t:0===t?0:1===t?1:l(d(t),r,n)};C.getControlPoints=function(){return[{x:e,y:r},{x:a,y:n}]};var T="generateBezier("+[e,r,a,n]+")";return C.toString=function(){return T},C}function u(e,t){var r=e;return g.isString(e)?v.Easings[e]||(r=!1):r=g.isArray(e)&&1===e.length?s.apply(null,e):g.isArray(e)&&2===e.length?b.apply(null,e.concat([t])):g.isArray(e)&&4===e.length?l.apply(null,e):!1,r===!1&&(r=v.Easings[v.defaults.easing]?v.defaults.easing:h),r}function c(e){if(e)for(var t=(new Date).getTime(),r=0,n=v.State.calls.length;n>r;r++)if(v.State.calls[r]){var o=v.State.calls[r],s=o[0],l=o[2],u=o[3],f=!!u;u||(u=v.State.calls[r][3]=t-16);for(var d=Math.min((t-u)/l.duration,1),m=0,y=s.length;y>m;m++){var h=s[m],b=h.element;if(i(b)){var S=!1;if(l.display!==a&&null!==l.display&&"none"!==l.display){if("flex"===l.display){var w=["-webkit-box","-moz-box","-ms-flexbox","-webkit-flex"];$.each(w,function(e,t){x.setPropertyValue(b,"display",t)})}x.setPropertyValue(b,"display",l.display)}l.visibility!==a&&"hidden"!==l.visibility&&x.setPropertyValue(b,"visibility",l.visibility);for(var V in h)if("element"!==V){var C=h[V],T,k=g.isString(C.easing)?v.Easings[C.easing]:C.easing;if(1===d)T=C.endValue;else if(T=C.startValue+(C.endValue-C.startValue)*k(d),!f&&T===C.currentValue)continue;if(C.currentValue=T,x.Hooks.registered[V]){var A=x.Hooks.getRoot(V),F=i(b).rootPropertyValueCache[A];F&&(C.rootPropertyValue=F)}var E=x.setPropertyValue(b,V,C.currentValue+(0===parseFloat(T)?"":C.unitType),C.rootPropertyValue,C.scrollData);x.Hooks.registered[V]&&(i(b).rootPropertyValueCache[A]=x.Normalizations.registered[A]?x.Normalizations.registered[A]("extract",null,E[1]):E[1]),"transform"===E[0]&&(S=!0)}l.mobileHA&&i(b).transformCache.translate3d===a&&(i(b).transformCache.translate3d="(0px, 0px, 0px)",S=!0),S&&x.flushTransformCache(b)}}l.display!==a&&"none"!==l.display&&(v.State.calls[r][2].display=!1),l.visibility!==a&&"hidden"!==l.visibility&&(v.State.calls[r][2].visibility=!1),l.progress&&l.progress.call(o[1],o[1],d,Math.max(0,u+l.duration-t),u),1===d&&p(r)}v.State.isTicking&&P(c)}function p(e,t){if(!v.State.calls[e])return!1;for(var r=v.State.calls[e][0],n=v.State.calls[e][1],o=v.State.calls[e][2],s=v.State.calls[e][4],l=!1,u=0,c=r.length;c>u;u++){var p=r[u].element;if(t||o.loop||("none"===o.display&&x.setPropertyValue(p,"display",o.display),"hidden"===o.visibility&&x.setPropertyValue(p,"visibility",o.visibility)),o.loop!==!0&&($.queue(p)[1]===a||!/\.velocityQueueEntryFlag/i.test($.queue(p)[1]))&&i(p)){i(p).isAnimating=!1,i(p).rootPropertyValueCache={};var f=!1;$.each(x.Lists.transforms3D,function(e,t){var r=/^scale/.test(t)?1:0,n=i(p).transformCache[t];i(p).transformCache[t]!==a&&new RegExp("^\\("+r+"[^.]").test(n)&&(f=!0,delete i(p).transformCache[t])}),o.mobileHA&&(f=!0,delete i(p).transformCache.translate3d),f&&x.flushTransformCache(p),x.Values.removeClass(p,"velocity-animating")}if(!t&&o.complete&&!o.loop&&u===c-1)try{o.complete.call(n,n)}catch(d){setTimeout(function(){throw d},1)}s&&o.loop!==!0&&s(n),o.loop!==!0||t||($.each(i(p).tweensContainer,function(e,t){/^rotate/.test(e)&&360===parseFloat(t.endValue)&&(t.endValue=0,t.startValue=360)}),v(p,"reverse",{loop:!0,delay:o.delay})),o.queue!==!1&&$.dequeue(p,o.queue)}v.State.calls[e]=!1;for(var g=0,m=v.State.calls.length;m>g;g++)if(v.State.calls[g]!==!1){l=!0;break}l===!1&&(v.State.isTicking=!1,delete v.State.calls,v.State.calls=[])}var f=function(){if(r.documentMode)return r.documentMode;for(var e=7;e>4;e--){var t=r.createElement("div");if(t.innerHTML="<!--[if IE "+e+"]><span></span><![endif]-->",t.getElementsByTagName("span").length)return t=null,e}return a}(),d=function(){var e=0;return t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||function(t){var r=(new Date).getTime(),a;return a=Math.max(0,16-(r-e)),e=r+a,setTimeout(function(){t(r+a)},a)}}(),g={isString:function(e){return"string"==typeof e},isArray:Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},isFunction:function(e){return"[object Function]"===Object.prototype.toString.call(e)},isNode:function(e){return e&&e.nodeType},isNodeList:function(e){return"object"==typeof e&&/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(e))&&e.length!==a&&(0===e.length||"object"==typeof e[0]&&e[0].nodeType>0)},isWrapped:function(e){return e&&(e.jquery||t.Zepto&&t.Zepto.zepto.isZ(e))},isSVG:function(e){return t.SVGElement&&e instanceof t.SVGElement},isEmptyObject:function(e){for(var t in e)return!1;return!0}},$,m=!1;if(e.fn&&e.fn.jquery?($=e,m=!0):$=t.Velocity.Utilities,8>=f&&!m)throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");if(7>=f)return void(jQuery.fn.velocity=jQuery.fn.animate);var y=400,h="swing",v={State:{isMobile:/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),isAndroid:/Android/i.test(navigator.userAgent),isGingerbread:/Android 2\.3\.[3-7]/i.test(navigator.userAgent),isChrome:t.chrome,isFirefox:/Firefox/i.test(navigator.userAgent),prefixElement:r.createElement("div"),prefixMatches:{},scrollAnchor:null,scrollPropertyLeft:null,scrollPropertyTop:null,isTicking:!1,calls:[]},CSS:{},Utilities:$,Redirects:{},Easings:{},Promise:t.Promise,defaults:{queue:"",duration:y,easing:h,begin:a,complete:a,progress:a,display:a,visibility:a,loop:!1,delay:!1,mobileHA:!0,_cacheValues:!0},init:function(e){$.data(e,"velocity",{isSVG:g.isSVG(e),isAnimating:!1,computedStyle:null,tweensContainer:null,rootPropertyValueCache:{},transformCache:{}})},hook:null,mock:!1,version:{major:1,minor:1,patch:0},debug:!1};t.pageYOffset!==a?(v.State.scrollAnchor=t,v.State.scrollPropertyLeft="pageXOffset",v.State.scrollPropertyTop="pageYOffset"):(v.State.scrollAnchor=r.documentElement||r.body.parentNode||r.body,v.State.scrollPropertyLeft="scrollLeft",v.State.scrollPropertyTop="scrollTop");var b=function(){function e(e){return-e.tension*e.x-e.friction*e.v}function t(t,r,a){var n={x:t.x+a.dx*r,v:t.v+a.dv*r,tension:t.tension,friction:t.friction};return{dx:n.v,dv:e(n)}}function r(r,a){var n={dx:r.v,dv:e(r)},o=t(r,.5*a,n),i=t(r,.5*a,o),s=t(r,a,i),l=1/6*(n.dx+2*(o.dx+i.dx)+s.dx),u=1/6*(n.dv+2*(o.dv+i.dv)+s.dv);return r.x=r.x+l*a,r.v=r.v+u*a,r}return function a(e,t,n){var o={x:-1,v:0,tension:null,friction:null},i=[0],s=0,l=1e-4,u=.016,c,p,f;for(e=parseFloat(e)||500,t=parseFloat(t)||20,n=n||null,o.tension=e,o.friction=t,c=null!==n,c?(s=a(e,t),p=s/n*u):p=u;;)if(f=r(f||o,p),i.push(1+f.x),s+=16,!(Math.abs(f.x)>l&&Math.abs(f.v)>l))break;return c?function(e){return i[e*(i.length-1)|0]}:s}}();v.Easings={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},spring:function(e){return 1-Math.cos(4.5*e*Math.PI)*Math.exp(6*-e)}},$.each([["ease",[.25,.1,.25,1]],["ease-in",[.42,0,1,1]],["ease-out",[0,0,.58,1]],["ease-in-out",[.42,0,.58,1]],["easeInSine",[.47,0,.745,.715]],["easeOutSine",[.39,.575,.565,1]],["easeInOutSine",[.445,.05,.55,.95]],["easeInQuad",[.55,.085,.68,.53]],["easeOutQuad",[.25,.46,.45,.94]],["easeInOutQuad",[.455,.03,.515,.955]],["easeInCubic",[.55,.055,.675,.19]],["easeOutCubic",[.215,.61,.355,1]],["easeInOutCubic",[.645,.045,.355,1]],["easeInQuart",[.895,.03,.685,.22]],["easeOutQuart",[.165,.84,.44,1]],["easeInOutQuart",[.77,0,.175,1]],["easeInQuint",[.755,.05,.855,.06]],["easeOutQuint",[.23,1,.32,1]],["easeInOutQuint",[.86,0,.07,1]],["easeInExpo",[.95,.05,.795,.035]],["easeOutExpo",[.19,1,.22,1]],["easeInOutExpo",[1,0,0,1]],["easeInCirc",[.6,.04,.98,.335]],["easeOutCirc",[.075,.82,.165,1]],["easeInOutCirc",[.785,.135,.15,.86]]],function(e,t){v.Easings[t[0]]=l.apply(null,t[1])});var x=v.CSS={RegEx:{isHex:/^#([A-f\d]{3}){1,2}$/i,valueUnwrap:/^[A-z]+\((.*)\)$/i,wrappedValueAlreadyExtracted:/[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,valueSplit:/([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi},Lists:{colors:["fill","stroke","stopColor","color","backgroundColor","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","outlineColor"],transformsBase:["translateX","translateY","scale","scaleX","scaleY","skewX","skewY","rotateZ"],transforms3D:["transformPerspective","translateZ","scaleZ","rotateX","rotateY"]},Hooks:{templates:{textShadow:["Color X Y Blur","black 0px 0px 0px"],boxShadow:["Color X Y Blur Spread","black 0px 0px 0px 0px"],clip:["Top Right Bottom Left","0px 0px 0px 0px"],backgroundPosition:["X Y","0% 0%"],transformOrigin:["X Y Z","50% 50% 0px"],perspectiveOrigin:["X Y","50% 50%"]},registered:{},register:function(){for(var e=0;e<x.Lists.colors.length;e++){var t="color"===x.Lists.colors[e]?"0 0 0 1":"255 255 255 1";x.Hooks.templates[x.Lists.colors[e]]=["Red Green Blue Alpha",t]}var r,a,n;if(f)for(r in x.Hooks.templates){a=x.Hooks.templates[r],n=a[0].split(" ");var o=a[1].match(x.RegEx.valueSplit);"Color"===n[0]&&(n.push(n.shift()),o.push(o.shift()),x.Hooks.templates[r]=[n.join(" "),o.join(" ")])}for(r in x.Hooks.templates){a=x.Hooks.templates[r],n=a[0].split(" ");for(var e in n){var i=r+n[e],s=e;x.Hooks.registered[i]=[r,s]}}},getRoot:function(e){var t=x.Hooks.registered[e];return t?t[0]:e},cleanRootPropertyValue:function(e,t){return x.RegEx.valueUnwrap.test(t)&&(t=t.match(x.RegEx.valueUnwrap)[1]),x.Values.isCSSNullValue(t)&&(t=x.Hooks.templates[e][1]),t},extractValue:function(e,t){var r=x.Hooks.registered[e];if(r){var a=r[0],n=r[1];return t=x.Hooks.cleanRootPropertyValue(a,t),t.toString().match(x.RegEx.valueSplit)[n]}return t},injectValue:function(e,t,r){var a=x.Hooks.registered[e];if(a){var n=a[0],o=a[1],i,s;return r=x.Hooks.cleanRootPropertyValue(n,r),i=r.toString().match(x.RegEx.valueSplit),i[o]=t,s=i.join(" ")}return r}},Normalizations:{registered:{clip:function(e,t,r){switch(e){case"name":return"clip";case"extract":var a;return x.RegEx.wrappedValueAlreadyExtracted.test(r)?a=r:(a=r.toString().match(x.RegEx.valueUnwrap),a=a?a[1].replace(/,(\s+)?/g," "):r),a;case"inject":return"rect("+r+")"}},blur:function(e,t,r){switch(e){case"name":return"-webkit-filter";case"extract":var a=parseFloat(r);if(!a&&0!==a){var n=r.toString().match(/blur\(([0-9]+[A-z]+)\)/i);a=n?n[1]:0}return a;case"inject":return parseFloat(r)?"blur("+r+")":"none"}},opacity:function(e,t,r){if(8>=f)switch(e){case"name":return"filter";case"extract":var a=r.toString().match(/alpha\(opacity=(.*)\)/i);return r=a?a[1]/100:1;case"inject":return t.style.zoom=1,parseFloat(r)>=1?"":"alpha(opacity="+parseInt(100*parseFloat(r),10)+")"}else switch(e){case"name":return"opacity";case"extract":return r;case"inject":return r}}},register:function(){9>=f||v.State.isGingerbread||(x.Lists.transformsBase=x.Lists.transformsBase.concat(x.Lists.transforms3D));for(var e=0;e<x.Lists.transformsBase.length;e++)!function(){var t=x.Lists.transformsBase[e];x.Normalizations.registered[t]=function(e,r,n){switch(e){case"name":return"transform";case"extract":return i(r)===a||i(r).transformCache[t]===a?/^scale/i.test(t)?1:0:i(r).transformCache[t].replace(/[()]/g,"");case"inject":var o=!1;switch(t.substr(0,t.length-1)){case"translate":o=!/(%|px|em|rem|vw|vh|\d)$/i.test(n);break;case"scal":case"scale":v.State.isAndroid&&i(r).transformCache[t]===a&&1>n&&(n=1),o=!/(\d)$/i.test(n);break;case"skew":o=!/(deg|\d)$/i.test(n);break;case"rotate":o=!/(deg|\d)$/i.test(n)}return o||(i(r).transformCache[t]="("+n+")"),i(r).transformCache[t]}}}();for(var e=0;e<x.Lists.colors.length;e++)!function(){var t=x.Lists.colors[e];x.Normalizations.registered[t]=function(e,r,n){switch(e){case"name":return t;case"extract":var o;if(x.RegEx.wrappedValueAlreadyExtracted.test(n))o=n;else{var i,s={black:"rgb(0, 0, 0)",blue:"rgb(0, 0, 255)",gray:"rgb(128, 128, 128)",green:"rgb(0, 128, 0)",red:"rgb(255, 0, 0)",white:"rgb(255, 255, 255)"};/^[A-z]+$/i.test(n)?i=s[n]!==a?s[n]:s.black:x.RegEx.isHex.test(n)?i="rgb("+x.Values.hexToRgb(n).join(" ")+")":/^rgba?\(/i.test(n)||(i=s.black),o=(i||n).toString().match(x.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g," ")}return 8>=f||3!==o.split(" ").length||(o+=" 1"),o;case"inject":return 8>=f?4===n.split(" ").length&&(n=n.split(/\s+/).slice(0,3).join(" ")):3===n.split(" ").length&&(n+=" 1"),(8>=f?"rgb":"rgba")+"("+n.replace(/\s+/g,",").replace(/\.(\d)+(?=,)/g,"")+")"}}}()}},Names:{camelCase:function(e){return e.replace(/-(\w)/g,function(e,t){return t.toUpperCase()})},SVGAttribute:function(e){var t="width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";return(f||v.State.isAndroid&&!v.State.isChrome)&&(t+="|transform"),new RegExp("^("+t+")$","i").test(e)},prefixCheck:function(e){if(v.State.prefixMatches[e])return[v.State.prefixMatches[e],!0];for(var t=["","Webkit","Moz","ms","O"],r=0,a=t.length;a>r;r++){var n;if(n=0===r?e:t[r]+e.replace(/^\w/,function(e){return e.toUpperCase()}),g.isString(v.State.prefixElement.style[n]))return v.State.prefixMatches[e]=n,[n,!0]}return[e,!1]}},Values:{hexToRgb:function(e){var t=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,a;return e=e.replace(t,function(e,t,r,a){return t+t+r+r+a+a}),a=r.exec(e),a?[parseInt(a[1],16),parseInt(a[2],16),parseInt(a[3],16)]:[0,0,0]},isCSSNullValue:function(e){return 0==e||/^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(e)},getUnitType:function(e){return/^(rotate|skew)/i.test(e)?"deg":/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e)?"":"px"},getDisplayType:function(e){var t=e&&e.tagName.toString().toLowerCase();return/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t)?"inline":/^(li)$/i.test(t)?"list-item":/^(tr)$/i.test(t)?"table-row":"block"},addClass:function(e,t){e.classList?e.classList.add(t):e.className+=(e.className.length?" ":"")+t},removeClass:function(e,t){e.classList?e.classList.remove(t):e.className=e.className.toString().replace(new RegExp("(^|\\s)"+t.split(" ").join("|")+"(\\s|$)","gi")," ")}},getPropertyValue:function(e,r,n,o){function s(e,r){function n(){u&&x.setPropertyValue(e,"display","none")}var l=0;if(8>=f)l=$.css(e,r);else{var u=!1;if(/^(width|height)$/.test(r)&&0===x.getPropertyValue(e,"display")&&(u=!0,x.setPropertyValue(e,"display",x.Values.getDisplayType(e))),!o){if("height"===r&&"border-box"!==x.getPropertyValue(e,"boxSizing").toString().toLowerCase()){var c=e.offsetHeight-(parseFloat(x.getPropertyValue(e,"borderTopWidth"))||0)-(parseFloat(x.getPropertyValue(e,"borderBottomWidth"))||0)-(parseFloat(x.getPropertyValue(e,"paddingTop"))||0)-(parseFloat(x.getPropertyValue(e,"paddingBottom"))||0);return n(),c}if("width"===r&&"border-box"!==x.getPropertyValue(e,"boxSizing").toString().toLowerCase()){var p=e.offsetWidth-(parseFloat(x.getPropertyValue(e,"borderLeftWidth"))||0)-(parseFloat(x.getPropertyValue(e,"borderRightWidth"))||0)-(parseFloat(x.getPropertyValue(e,"paddingLeft"))||0)-(parseFloat(x.getPropertyValue(e,"paddingRight"))||0);return n(),p}}var d;d=i(e)===a?t.getComputedStyle(e,null):i(e).computedStyle?i(e).computedStyle:i(e).computedStyle=t.getComputedStyle(e,null),(f||v.State.isFirefox)&&"borderColor"===r&&(r="borderTopColor"),l=9===f&&"filter"===r?d.getPropertyValue(r):d[r],(""===l||null===l)&&(l=e.style[r]),n()}if("auto"===l&&/^(top|right|bottom|left)$/i.test(r)){var g=s(e,"position");("fixed"===g||"absolute"===g&&/top|left/i.test(r))&&(l=$(e).position()[r]+"px")}return l}var l;if(x.Hooks.registered[r]){var u=r,c=x.Hooks.getRoot(u);n===a&&(n=x.getPropertyValue(e,x.Names.prefixCheck(c)[0])),x.Normalizations.registered[c]&&(n=x.Normalizations.registered[c]("extract",e,n)),l=x.Hooks.extractValue(u,n)}else if(x.Normalizations.registered[r]){var p,d;p=x.Normalizations.registered[r]("name",e),"transform"!==p&&(d=s(e,x.Names.prefixCheck(p)[0]),x.Values.isCSSNullValue(d)&&x.Hooks.templates[r]&&(d=x.Hooks.templates[r][1])),l=x.Normalizations.registered[r]("extract",e,d)}return/^[\d-]/.test(l)||(l=i(e)&&i(e).isSVG&&x.Names.SVGAttribute(r)?/^(height|width)$/i.test(r)?e.getBBox()[r]:e.getAttribute(r):s(e,x.Names.prefixCheck(r)[0])),x.Values.isCSSNullValue(l)&&(l=0),v.debug>=2&&console.log("Get "+r+": "+l),l},setPropertyValue:function(e,r,a,n,o){var s=r;if("scroll"===r)o.container?o.container["scroll"+o.direction]=a:"Left"===o.direction?t.scrollTo(a,o.alternateValue):t.scrollTo(o.alternateValue,a);else if(x.Normalizations.registered[r]&&"transform"===x.Normalizations.registered[r]("name",e))x.Normalizations.registered[r]("inject",e,a),s="transform",a=i(e).transformCache[r];else{if(x.Hooks.registered[r]){var l=r,u=x.Hooks.getRoot(r);n=n||x.getPropertyValue(e,u),a=x.Hooks.injectValue(l,a,n),r=u}if(x.Normalizations.registered[r]&&(a=x.Normalizations.registered[r]("inject",e,a),r=x.Normalizations.registered[r]("name",e)),s=x.Names.prefixCheck(r)[0],8>=f)try{e.style[s]=a}catch(c){v.debug&&console.log("Browser does not support ["+a+"] for ["+s+"]")}else i(e)&&i(e).isSVG&&x.Names.SVGAttribute(r)?e.setAttribute(r,a):e.style[s]=a;v.debug>=2&&console.log("Set "+r+" ("+s+"): "+a)}return[s,a]},flushTransformCache:function(e){function t(t){return parseFloat(x.getPropertyValue(e,t))}var r="";if((f||v.State.isAndroid&&!v.State.isChrome)&&i(e).isSVG){var a={translate:[t("translateX"),t("translateY")],skewX:[t("skewX")],skewY:[t("skewY")],scale:1!==t("scale")?[t("scale"),t("scale")]:[t("scaleX"),t("scaleY")],rotate:[t("rotateZ"),0,0]};$.each(i(e).transformCache,function(e){/^translate/i.test(e)?e="translate":/^scale/i.test(e)?e="scale":/^rotate/i.test(e)&&(e="rotate"),a[e]&&(r+=e+"("+a[e].join(" ")+") ",delete a[e])})}else{var n,o;$.each(i(e).transformCache,function(t){return n=i(e).transformCache[t],"transformPerspective"===t?(o=n,!0):(9===f&&"rotateZ"===t&&(t="rotate"),void(r+=t+n+" "))}),o&&(r="perspective"+o+" "+r)}x.setPropertyValue(e,"transform",r)}};x.Hooks.register(),x.Normalizations.register(),v.hook=function(e,t,r){var n=a;return e=o(e),$.each(e,function(e,o){if(i(o)===a&&v.init(o),r===a)n===a&&(n=v.CSS.getPropertyValue(o,t));else{var s=v.CSS.setPropertyValue(o,t,r);"transform"===s[0]&&v.CSS.flushTransformCache(o),n=s}}),n};var S=function(){function e(){return f?k.promise||null:d}function s(){function e(e){function f(e,t){var r=a,n=a,i=a;return g.isArray(e)?(r=e[0],!g.isArray(e[1])&&/^[\d-]/.test(e[1])||g.isFunction(e[1])||x.RegEx.isHex.test(e[1])?i=e[1]:(g.isString(e[1])&&!x.RegEx.isHex.test(e[1])||g.isArray(e[1]))&&(n=t?e[1]:u(e[1],s.duration),e[2]!==a&&(i=e[2]))):r=e,t||(n=n||s.easing),g.isFunction(r)&&(r=r.call(o,V,w)),g.isFunction(i)&&(i=i.call(o,V,w)),[r||0,n,i]}function d(e,t){var r,a;return a=(t||"0").toString().toLowerCase().replace(/[%A-z]+$/,function(e){return r=e,""}),r||(r=x.Values.getUnitType(e)),[a,r]}function m(){var e={myParent:o.parentNode||r.body,position:x.getPropertyValue(o,"position"),fontSize:x.getPropertyValue(o,"fontSize")},a=e.position===L.lastPosition&&e.myParent===L.lastParent,n=e.fontSize===L.lastFontSize;L.lastParent=e.myParent,L.lastPosition=e.position,L.lastFontSize=e.fontSize;var s=100,l={};if(n&&a)l.emToPx=L.lastEmToPx,l.percentToPxWidth=L.lastPercentToPxWidth,l.percentToPxHeight=L.lastPercentToPxHeight;else{var u=i(o).isSVG?r.createElementNS("http://www.w3.org/2000/svg","rect"):r.createElement("div");v.init(u),e.myParent.appendChild(u),$.each(["overflow","overflowX","overflowY"],function(e,t){v.CSS.setPropertyValue(u,t,"hidden")}),v.CSS.setPropertyValue(u,"position",e.position),v.CSS.setPropertyValue(u,"fontSize",e.fontSize),v.CSS.setPropertyValue(u,"boxSizing","content-box"),$.each(["minWidth","maxWidth","width","minHeight","maxHeight","height"],function(e,t){v.CSS.setPropertyValue(u,t,s+"%")}),v.CSS.setPropertyValue(u,"paddingLeft",s+"em"),l.percentToPxWidth=L.lastPercentToPxWidth=(parseFloat(x.getPropertyValue(u,"width",null,!0))||1)/s,l.percentToPxHeight=L.lastPercentToPxHeight=(parseFloat(x.getPropertyValue(u,"height",null,!0))||1)/s,l.emToPx=L.lastEmToPx=(parseFloat(x.getPropertyValue(u,"paddingLeft"))||1)/s,e.myParent.removeChild(u)}return null===L.remToPx&&(L.remToPx=parseFloat(x.getPropertyValue(r.body,"fontSize"))||16),null===L.vwToPx&&(L.vwToPx=parseFloat(t.innerWidth)/100,L.vhToPx=parseFloat(t.innerHeight)/100),l.remToPx=L.remToPx,l.vwToPx=L.vwToPx,l.vhToPx=L.vhToPx,v.debug>=1&&console.log("Unit ratios: "+JSON.stringify(l),o),l}if(s.begin&&0===V)try{s.begin.call(h,h)}catch(y){setTimeout(function(){throw y},1)}if("scroll"===A){var S=/^x$/i.test(s.axis)?"Left":"Top",C=parseFloat(s.offset)||0,T,F,E;s.container?g.isWrapped(s.container)||g.isNode(s.container)?(s.container=s.container[0]||s.container,T=s.container["scroll"+S],E=T+$(o).position()[S.toLowerCase()]+C):s.container=null:(T=v.State.scrollAnchor[v.State["scrollProperty"+S]],F=v.State.scrollAnchor[v.State["scrollProperty"+("Left"===S?"Top":"Left")]],E=$(o).offset()[S.toLowerCase()]+C),l={scroll:{rootPropertyValue:!1,startValue:T,currentValue:T,endValue:E,unitType:"",easing:s.easing,scrollData:{container:s.container,direction:S,alternateValue:F}},element:o},v.debug&&console.log("tweensContainer (scroll): ",l.scroll,o)}else if("reverse"===A){if(!i(o).tweensContainer)return void $.dequeue(o,s.queue);"none"===i(o).opts.display&&(i(o).opts.display="auto"),"hidden"===i(o).opts.visibility&&(i(o).opts.visibility="visible"),i(o).opts.loop=!1,i(o).opts.begin=null,i(o).opts.complete=null,P.easing||delete s.easing,P.duration||delete s.duration,s=$.extend({},i(o).opts,s);var j=$.extend(!0,{},i(o).tweensContainer);for(var H in j)if("element"!==H){var N=j[H].startValue;j[H].startValue=j[H].currentValue=j[H].endValue,j[H].endValue=N,g.isEmptyObject(P)||(j[H].easing=s.easing),v.debug&&console.log("reverse tweensContainer ("+H+"): "+JSON.stringify(j[H]),o)}l=j}else if("start"===A){var j;i(o).tweensContainer&&i(o).isAnimating===!0&&(j=i(o).tweensContainer),$.each(b,function(e,t){if(RegExp("^"+x.Lists.colors.join("$|^")+"$").test(e)){var r=f(t,!0),n=r[0],o=r[1],i=r[2];if(x.RegEx.isHex.test(n)){for(var s=["Red","Green","Blue"],l=x.Values.hexToRgb(n),u=i?x.Values.hexToRgb(i):a,c=0;c<s.length;c++){var p=[l[c]];o&&p.push(o),u!==a&&p.push(u[c]),b[e+s[c]]=p}delete b[e]}}});for(var O in b){var z=f(b[O]),q=z[0],M=z[1],I=z[2];O=x.Names.camelCase(O);var B=x.Hooks.getRoot(O),W=!1;if(i(o).isSVG||x.Names.prefixCheck(B)[1]!==!1||x.Normalizations.registered[B]!==a){(s.display!==a&&null!==s.display&&"none"!==s.display||s.visibility!==a&&"hidden"!==s.visibility)&&/opacity|filter/.test(O)&&!I&&0!==q&&(I=0),s._cacheValues&&j&&j[O]?(I===a&&(I=j[O].endValue+j[O].unitType),W=i(o).rootPropertyValueCache[B]):x.Hooks.registered[O]?I===a?(W=x.getPropertyValue(o,B),I=x.getPropertyValue(o,O,W)):W=x.Hooks.templates[B][1]:I===a&&(I=x.getPropertyValue(o,O));var G,D,X,Y=!1;if(G=d(O,I),I=G[0],X=G[1],G=d(O,q),q=G[0].replace(/^([+-\/*])=/,function(e,t){return Y=t,""}),D=G[1],I=parseFloat(I)||0,q=parseFloat(q)||0,"%"===D&&(/^(fontSize|lineHeight)$/.test(O)?(q/=100,D="em"):/^scale/.test(O)?(q/=100,D=""):/(Red|Green|Blue)$/i.test(O)&&(q=q/100*255,D="")),/[\/*]/.test(Y))D=X;else if(X!==D&&0!==I)if(0===q)D=X;else{p=p||m();var Q=/margin|padding|left|right|width|text|word|letter/i.test(O)||/X$/.test(O)||"x"===O?"x":"y";switch(X){case"%":I*="x"===Q?p.percentToPxWidth:p.percentToPxHeight;break;case"px":break;default:I*=p[X+"ToPx"]}switch(D){case"%":I*=1/("x"===Q?p.percentToPxWidth:p.percentToPxHeight);break;case"px":break;default:I*=1/p[D+"ToPx"]}}switch(Y){case"+":q=I+q;break;case"-":q=I-q;break;case"*":q=I*q;break;case"/":q=I/q}l[O]={rootPropertyValue:W,startValue:I,currentValue:I,endValue:q,unitType:D,easing:M},v.debug&&console.log("tweensContainer ("+O+"): "+JSON.stringify(l[O]),o)}else v.debug&&console.log("Skipping ["+B+"] due to a lack of browser support.")}l.element=o}l.element&&(x.Values.addClass(o,"velocity-animating"),R.push(l),""===s.queue&&(i(o).tweensContainer=l,i(o).opts=s),i(o).isAnimating=!0,V===w-1?(v.State.calls.length>1e4&&(v.State.calls=n(v.State.calls)),v.State.calls.push([R,h,s,null,k.resolver]),v.State.isTicking===!1&&(v.State.isTicking=!0,c())):V++)}var o=this,s=$.extend({},v.defaults,P),l={},p;switch(i(o)===a&&v.init(o),parseFloat(s.delay)&&s.queue!==!1&&$.queue(o,s.queue,function(e){v.velocityQueueEntryFlag=!0,i(o).delayTimer={setTimeout:setTimeout(e,parseFloat(s.delay)),next:e}}),s.duration.toString().toLowerCase()){case"fast":s.duration=200;break;case"normal":s.duration=y;break;case"slow":s.duration=600;break;default:s.duration=parseFloat(s.duration)||1}v.mock!==!1&&(v.mock===!0?s.duration=s.delay=1:(s.duration*=parseFloat(v.mock)||1,s.delay*=parseFloat(v.mock)||1)),s.easing=u(s.easing,s.duration),s.begin&&!g.isFunction(s.begin)&&(s.begin=null),s.progress&&!g.isFunction(s.progress)&&(s.progress=null),s.complete&&!g.isFunction(s.complete)&&(s.complete=null),s.display!==a&&null!==s.display&&(s.display=s.display.toString().toLowerCase(),"auto"===s.display&&(s.display=v.CSS.Values.getDisplayType(o))),s.visibility!==a&&null!==s.visibility&&(s.visibility=s.visibility.toString().toLowerCase()),s.mobileHA=s.mobileHA&&v.State.isMobile&&!v.State.isGingerbread,s.queue===!1?s.delay?setTimeout(e,s.delay):e():$.queue(o,s.queue,function(t,r){return r===!0?(k.promise&&k.resolver(h),!0):(v.velocityQueueEntryFlag=!0,void e(t))}),""!==s.queue&&"fx"!==s.queue||"inprogress"===$.queue(o)[0]||$.dequeue(o)}var l=arguments[0]&&($.isPlainObject(arguments[0].properties)&&!arguments[0].properties.names||g.isString(arguments[0].properties)),f,d,m,h,b,P;if(g.isWrapped(this)?(f=!1,m=0,h=this,d=this):(f=!0,m=1,h=l?arguments[0].elements:arguments[0]),h=o(h)){l?(b=arguments[0].properties,P=arguments[0].options):(b=arguments[m],P=arguments[m+1]);var w=h.length,V=0;if("stop"!==b&&!$.isPlainObject(P)){var C=m+1;P={};for(var T=C;T<arguments.length;T++)g.isArray(arguments[T])||!/^(fast|normal|slow)$/i.test(arguments[T])&&!/^\d/.test(arguments[T])?g.isString(arguments[T])||g.isArray(arguments[T])?P.easing=arguments[T]:g.isFunction(arguments[T])&&(P.complete=arguments[T]):P.duration=arguments[T]}var k={promise:null,resolver:null,rejecter:null};f&&v.Promise&&(k.promise=new v.Promise(function(e,t){k.resolver=e,k.rejecter=t}));var A;switch(b){case"scroll":A="scroll";break;case"reverse":A="reverse";break;case"stop":$.each(h,function(e,t){i(t)&&i(t).delayTimer&&(clearTimeout(i(t).delayTimer.setTimeout),i(t).delayTimer.next&&i(t).delayTimer.next(),delete i(t).delayTimer)});var F=[];return $.each(v.State.calls,function(e,t){t&&$.each(t[1],function(r,n){var o=g.isString(P)?P:"";return P!==a&&t[2].queue!==o?!0:void $.each(h,function(t,r){r===n&&(P!==a&&($.each($.queue(r,o),function(e,t){g.isFunction(t)&&t(null,!0)}),$.queue(r,o,[])),i(r)&&""===o&&$.each(i(r).tweensContainer,function(e,t){t.endValue=t.currentValue}),F.push(e))})})}),$.each(F,function(e,t){p(t,!0)}),k.promise&&k.resolver(h),e();default:if(!$.isPlainObject(b)||g.isEmptyObject(b)){if(g.isString(b)&&v.Redirects[b]){var E=$.extend({},P),j=E.duration,H=E.delay||0;return E.backwards===!0&&(h=$.extend(!0,[],h).reverse()),$.each(h,function(e,t){parseFloat(E.stagger)?E.delay=H+parseFloat(E.stagger)*e:g.isFunction(E.stagger)&&(E.delay=H+E.stagger.call(t,e,w)),E.drag&&(E.duration=parseFloat(j)||(/^(callout|transition)/.test(b)?1e3:y),E.duration=Math.max(E.duration*(E.backwards?1-e/w:(e+1)/w),.75*E.duration,200)),v.Redirects[b].call(t,t,E||{},e,w,h,k.promise?k:a)
}),e()}var N="Velocity: First argument ("+b+") was not a property map, a known action, or a registered redirect. Aborting.";return k.promise?k.rejecter(new Error(N)):console.log(N),e()}A="start"}var L={lastParent:null,lastPosition:null,lastFontSize:null,lastPercentToPxWidth:null,lastPercentToPxHeight:null,lastEmToPx:null,remToPx:null,vwToPx:null,vhToPx:null},R=[];$.each(h,function(e,t){g.isNode(t)&&s.call(t)});var E=$.extend({},v.defaults,P),O;if(E.loop=parseInt(E.loop),O=2*E.loop-1,E.loop)for(var z=0;O>z;z++){var q={delay:E.delay,progress:E.progress};z===O-1&&(q.display=E.display,q.visibility=E.visibility,q.complete=E.complete),S(h,"reverse",q)}return e()}};v=$.extend(S,v),v.animate=S;var P=t.requestAnimationFrame||d;return v.State.isMobile||r.hidden===a||r.addEventListener("visibilitychange",function(){r.hidden?(P=function(e){return setTimeout(function(){e(!0)},16)},c()):P=t.requestAnimationFrame||d}),e.Velocity=v,e!==t&&(e.fn.velocity=S,e.fn.velocity.defaults=v.defaults),$.each(["Down","Up"],function(e,t){v.Redirects["slide"+t]=function(e,r,n,o,i,s){var l=$.extend({},r),u=l.begin,c=l.complete,p={height:"",marginTop:"",marginBottom:"",paddingTop:"",paddingBottom:""},f={};l.display===a&&(l.display="Down"===t?"inline"===v.CSS.Values.getDisplayType(e)?"inline-block":"block":"none"),l.begin=function(){u&&u.call(i,i);for(var r in p){f[r]=e.style[r];var a=v.CSS.getPropertyValue(e,r);p[r]="Down"===t?[a,0]:[0,a]}f.overflow=e.style.overflow,e.style.overflow="hidden"},l.complete=function(){for(var t in f)e.style[t]=f[t];c&&c.call(i,i),s&&s.resolver(i)},v(e,p,l)}}),$.each(["In","Out"],function(e,t){v.Redirects["fade"+t]=function(e,r,n,o,i,s){var l=$.extend({},r),u={opacity:"In"===t?1:0},c=l.complete;l.complete=n!==o-1?l.begin=null:function(){c&&c.call(i,i),s&&s.resolver(i)},l.display===a&&(l.display="In"===t?"auto":"none"),v(this,u,l)}}),v}(window.jQuery||window.Zepto||window,window,document)});

/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.11
 *
 * Requires: jQuery 1.2.2+
 */
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):"object"==typeof exports?module.exports=a:a(jQuery)}(function(a){function b(b){var g=b||window.event,h=i.call(arguments,1),j=0,l=0,m=0,n=0,o=0,p=0;if(b=a.event.fix(g),b.type="mousewheel","detail"in g&&(m=-1*g.detail),"wheelDelta"in g&&(m=g.wheelDelta),"wheelDeltaY"in g&&(m=g.wheelDeltaY),"wheelDeltaX"in g&&(l=-1*g.wheelDeltaX),"axis"in g&&g.axis===g.HORIZONTAL_AXIS&&(l=-1*m,m=0),j=0===m?l:m,"deltaY"in g&&(m=-1*g.deltaY,j=m),"deltaX"in g&&(l=g.deltaX,0===m&&(j=-1*l)),0!==m||0!==l){if(1===g.deltaMode){var q=a.data(this,"mousewheel-line-height");j*=q,m*=q,l*=q}else if(2===g.deltaMode){var r=a.data(this,"mousewheel-page-height");j*=r,m*=r,l*=r}if(n=Math.max(Math.abs(m),Math.abs(l)),(!f||f>n)&&(f=n,d(g,n)&&(f/=40)),d(g,n)&&(j/=40,l/=40,m/=40),j=Math[j>=1?"floor":"ceil"](j/f),l=Math[l>=1?"floor":"ceil"](l/f),m=Math[m>=1?"floor":"ceil"](m/f),k.settings.normalizeOffset&&this.getBoundingClientRect){var s=this.getBoundingClientRect();o=b.clientX-s.left,p=b.clientY-s.top}return b.deltaX=l,b.deltaY=m,b.deltaFactor=f,b.offsetX=o,b.offsetY=p,b.deltaMode=0,h.unshift(b,j,l,m),e&&clearTimeout(e),e=setTimeout(c,200),(a.event.dispatch||a.event.handle).apply(this,h)}}function c(){f=null}function d(a,b){return k.settings.adjustOldDeltas&&"mousewheel"===a.type&&b%120===0}var e,f,g=["wheel","mousewheel","DOMMouseScroll","MozMousePixelScroll"],h="onwheel"in document||document.documentMode>=9?["wheel"]:["mousewheel","DomMouseScroll","MozMousePixelScroll"],i=Array.prototype.slice;if(a.event.fixHooks)for(var j=g.length;j;)a.event.fixHooks[g[--j]]=a.event.mouseHooks;var k=a.event.special.mousewheel={version:"3.1.11",setup:function(){if(this.addEventListener)for(var c=h.length;c;)this.addEventListener(h[--c],b,!1);else this.onmousewheel=b;a.data(this,"mousewheel-line-height",k.getLineHeight(this)),a.data(this,"mousewheel-page-height",k.getPageHeight(this))},teardown:function(){if(this.removeEventListener)for(var c=h.length;c;)this.removeEventListener(h[--c],b,!1);else this.onmousewheel=null;a.removeData(this,"mousewheel-line-height"),a.removeData(this,"mousewheel-page-height")},getLineHeight:function(b){var c=a(b)["offsetParent"in a.fn?"offsetParent":"parent"]();return c.length||(c=a("body")),parseInt(c.css("fontSize"),10)},getPageHeight:function(b){return a(b).height()},settings:{adjustOldDeltas:!0,normalizeOffset:!0}};a.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})});

/**
 * Event dispatcher that facilitates binding, unbinding and triggering of events.
 * @version: 0.0.2
 */
(function(Vent){
	if(typeof module !== 'undefined' && module.exports){ //CommonJS
		module.exports = Vent;
	}
	else if(typeof define === 'function'){ //AMD
		define(function(){
			return Vent;
		});
	}
	else{
		window.Vent = Vent;
	}
	
}(function(){
	var Vent = function(){
		this.events = {};
	};
	
	Vent.prototype = {
	
		spliter: /\s+/,
		
		/**
		* Alias for "bind" method.
		* @method on
		*/
		on: function(){
			return this.bind.apply(this, arguments);
		},
		
		/**
		* Alias for "unbind" method.
		* @method off
		*/
		off: function(){
			return this.unbind.apply(this, arguments);
		},
		
		/**
		* Binds event listener(s).
		* @method bind
		* @param events {string} space-separated list of event names.
		* @param callback {function} function to be invoked when event is triggered.
		* @param [context] {object} context to be passed to callback.
		* @return {object} this.
		*/
		bind: function(events, callback, context){
			var split = events.split(this.spliter);
			
			for(var i=0, splitLen=split.length; i<splitLen; i++){
				var event = split[i];
				
				if(!this.events[event]){
					this.events[event] = [];
				}
				this.events[event].push({
					context: context,
					callback: callback
				});
			}
			return this;
		},
		
		/**
		* Unbinds event listener(s).
		* @method unbind
		* @param [events] {string} space-separated list of event names.
		* @param [callback] {function} function to compare with callback.
		* @param [context] {object} object to compare with context.
		* @return {object} this.
		*/
		unbind: function(events, callback, context){
			var checkCallback = typeof callback === 'function',
				checkContext = typeof context === 'object' && context !== null;
			
			//no arguments - remove all events.
			if(arguments.length === 0){
				this.events = [];
			}
			else{
				var split = events.split(this.spliter);
				
				for(var i=0, splitLen=split.length; i<splitLen; i++){
					var event = split[i],
						listeners = this.events[event];
					
					if(listeners){
						//don't need to bother with looping if we don't care about callback or context.
						if(!checkCallback){
							delete this.events[event];
						}
						else{
							for(var j=listeners.length-1; j >=0; j--){
								var listener = listeners[j];
								
								if(listener.callback === callback){
									if(checkContext){
										if(listener.context === context){
											listeners.splice(j, 1);
										}
									}
									else{
										listeners.splice(j, 1);
									}
								}
							}
							
							//cleanup events object if all listeners have been removed.
							if(listeners.length === 0){
								delete this.events[event];
							}
						}
					}
				}
			}
			
			return this;
		},
		
		/**
		* Triggers event listener(s).
		* @method trigger
		* @param events {string} space-separated list of event names.
		* @return {object} this.
		*/
		trigger: function(events){
			var split = events.split(this.spliter),
				//convert arguments to an array.
				args = Array.prototype.slice.call(arguments);
			
			for(var i=0, splitLen=split.length; i<splitLen; i++){
				var event = split[i],
					listeners = this.events[event];
				
				if(listeners){
					for(var j=0, ListenersLen=listeners.length; j<ListenersLen; j++){
						var listener = listeners[j],
							context = listener.context || this;
							
						listener.callback.apply(context, args.slice(1));
					}
					
					//trigger every 'all' event.
					var allListeners = this.events['all'];
					if(allListeners){
						for(var j=0, ListenersLen=listeners.length; j<ListenersLen; j++){
							var listener = listeners[j],
								context = listener.context || this;
								
							listener.callback.apply(context, args);
						}
					}
				}
			}
			return this;
		}
	};
	
	return Vent;
}()));

/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var dat=dat||{};dat.gui=dat.gui||{};dat.utils=dat.utils||{};dat.controllers=dat.controllers||{};dat.dom=dat.dom||{};dat.color=dat.color||{};dat.utils.css=function(){return{load:function(e,a){var a=a||document,c=a.createElement("link");c.type="text/css";c.rel="stylesheet";c.href=e;a.getElementsByTagName("head")[0].appendChild(c)},inject:function(e,a){var a=a||document,c=document.createElement("style");c.type="text/css";c.innerHTML=e;a.getElementsByTagName("head")[0].appendChild(c)}}}();
dat.utils.common=function(){var e=Array.prototype.forEach,a=Array.prototype.slice;return{BREAK:{},extend:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(a[f])||(c[f]=a[f])},this);return c},defaults:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(c[f])&&(c[f]=a[f])},this);return c},compose:function(){var c=a.call(arguments);return function(){for(var d=a.call(arguments),f=c.length-1;f>=0;f--)d=[c[f].apply(this,d)];return d[0]}},
each:function(a,d,f){if(e&&a.forEach===e)a.forEach(d,f);else if(a.length===a.length+0)for(var b=0,n=a.length;b<n;b++){if(b in a&&d.call(f,a[b],b)===this.BREAK)break}else for(b in a)if(d.call(f,a[b],b)===this.BREAK)break},defer:function(a){setTimeout(a,0)},toArray:function(c){return c.toArray?c.toArray():a.call(c)},isUndefined:function(a){return a===void 0},isNull:function(a){return a===null},isNaN:function(a){return a!==a},isArray:Array.isArray||function(a){return a.constructor===Array},isObject:function(a){return a===
Object(a)},isNumber:function(a){return a===a+0},isString:function(a){return a===a+""},isBoolean:function(a){return a===false||a===true},isFunction:function(a){return Object.prototype.toString.call(a)==="[object Function]"}}}();
dat.controllers.Controller=function(e){var a=function(a,d){this.initialValue=a[d];this.domElement=document.createElement("div");this.object=a;this.property=d;this.__onFinishChange=this.__onChange=void 0};e.extend(a.prototype,{onChange:function(a){this.__onChange=a;return this},onFinishChange:function(a){this.__onFinishChange=a;return this},setValue:function(a){this.object[this.property]=a;this.__onChange&&this.__onChange.call(this,a);this.updateDisplay();return this},getValue:function(){return this.object[this.property]},
updateDisplay:function(){return this},isModified:function(){return this.initialValue!==this.getValue()}});return a}(dat.utils.common);
dat.dom.dom=function(e){function a(b){if(b==="0"||e.isUndefined(b))return 0;b=b.match(d);return!e.isNull(b)?parseFloat(b[1]):0}var c={};e.each({HTMLEvents:["change"],MouseEvents:["click","mousemove","mousedown","mouseup","mouseover"],KeyboardEvents:["keydown"]},function(b,a){e.each(b,function(b){c[b]=a})});var d=/(\d+(\.\d+)?)px/,f={makeSelectable:function(b,a){if(!(b===void 0||b.style===void 0))b.onselectstart=a?function(){return false}:function(){},b.style.MozUserSelect=a?"auto":"none",b.style.KhtmlUserSelect=
a?"auto":"none",b.unselectable=a?"on":"off"},makeFullscreen:function(b,a,d){e.isUndefined(a)&&(a=true);e.isUndefined(d)&&(d=true);b.style.position="absolute";if(a)b.style.left=0,b.style.right=0;if(d)b.style.top=0,b.style.bottom=0},fakeEvent:function(b,a,d,f){var d=d||{},m=c[a];if(!m)throw Error("Event type "+a+" not supported.");var l=document.createEvent(m);switch(m){case "MouseEvents":l.initMouseEvent(a,d.bubbles||false,d.cancelable||true,window,d.clickCount||1,0,0,d.x||d.clientX||0,d.y||d.clientY||
0,false,false,false,false,0,null);break;case "KeyboardEvents":m=l.initKeyboardEvent||l.initKeyEvent;e.defaults(d,{cancelable:true,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false,keyCode:void 0,charCode:void 0});m(a,d.bubbles||false,d.cancelable,window,d.ctrlKey,d.altKey,d.shiftKey,d.metaKey,d.keyCode,d.charCode);break;default:l.initEvent(a,d.bubbles||false,d.cancelable||true)}e.defaults(l,f);b.dispatchEvent(l)},bind:function(b,a,d,c){b.addEventListener?b.addEventListener(a,d,c||false):b.attachEvent&&
b.attachEvent("on"+a,d);return f},unbind:function(b,a,d,c){b.removeEventListener?b.removeEventListener(a,d,c||false):b.detachEvent&&b.detachEvent("on"+a,d);return f},addClass:function(b,a){if(b.className===void 0)b.className=a;else if(b.className!==a){var d=b.className.split(/ +/);if(d.indexOf(a)==-1)d.push(a),b.className=d.join(" ").replace(/^\s+/,"").replace(/\s+$/,"")}return f},removeClass:function(b,a){if(a){if(b.className!==void 0)if(b.className===a)b.removeAttribute("class");else{var d=b.className.split(/ +/),
c=d.indexOf(a);if(c!=-1)d.splice(c,1),b.className=d.join(" ")}}else b.className=void 0;return f},hasClass:function(a,d){return RegExp("(?:^|\\s+)"+d+"(?:\\s+|$)").test(a.className)||false},getWidth:function(b){b=getComputedStyle(b);return a(b["border-left-width"])+a(b["border-right-width"])+a(b["padding-left"])+a(b["padding-right"])+a(b.width)},getHeight:function(b){b=getComputedStyle(b);return a(b["border-top-width"])+a(b["border-bottom-width"])+a(b["padding-top"])+a(b["padding-bottom"])+a(b.height)},
getOffset:function(a){var d={left:0,top:0};if(a.offsetParent){do d.left+=a.offsetLeft,d.top+=a.offsetTop;while(a=a.offsetParent)}return d},isActive:function(a){return a===document.activeElement&&(a.type||a.href)}};return f}(dat.utils.common);
dat.controllers.OptionController=function(e,a,c){var d=function(f,b,e){d.superclass.call(this,f,b);var h=this;this.__select=document.createElement("select");if(c.isArray(e)){var j={};c.each(e,function(a){j[a]=a});e=j}c.each(e,function(a,b){var d=document.createElement("option");d.innerHTML=b;d.setAttribute("value",a);h.__select.appendChild(d)});this.updateDisplay();a.bind(this.__select,"change",function(){h.setValue(this.options[this.selectedIndex].value)});this.domElement.appendChild(this.__select)};
d.superclass=e;c.extend(d.prototype,e.prototype,{setValue:function(a){a=d.superclass.prototype.setValue.call(this,a);this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue());return a},updateDisplay:function(){this.__select.value=this.getValue();return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);
dat.controllers.NumberController=function(e,a){var c=function(d,f,b){c.superclass.call(this,d,f);b=b||{};this.__min=b.min;this.__max=b.max;this.__step=b.step;d=this.__impliedStep=a.isUndefined(this.__step)?this.initialValue==0?1:Math.pow(10,Math.floor(Math.log(this.initialValue)/Math.LN10))/10:this.__step;d=d.toString();this.__precision=d.indexOf(".")>-1?d.length-d.indexOf(".")-1:0};c.superclass=e;a.extend(c.prototype,e.prototype,{setValue:function(a){if(this.__min!==void 0&&a<this.__min)a=this.__min;
else if(this.__max!==void 0&&a>this.__max)a=this.__max;this.__step!==void 0&&a%this.__step!=0&&(a=Math.round(a/this.__step)*this.__step);return c.superclass.prototype.setValue.call(this,a)},min:function(a){this.__min=a;return this},max:function(a){this.__max=a;return this},step:function(a){this.__step=a;return this}});return c}(dat.controllers.Controller,dat.utils.common);
dat.controllers.NumberControllerBox=function(e,a,c){var d=function(f,b,e){function h(){var a=parseFloat(l.__input.value);c.isNaN(a)||l.setValue(a)}function j(a){var b=o-a.clientY;l.setValue(l.getValue()+b*l.__impliedStep);o=a.clientY}function m(){a.unbind(window,"mousemove",j);a.unbind(window,"mouseup",m)}this.__truncationSuspended=false;d.superclass.call(this,f,b,e);var l=this,o;this.__input=document.createElement("input");this.__input.setAttribute("type","text");a.bind(this.__input,"change",h);
a.bind(this.__input,"blur",function(){h();l.__onFinishChange&&l.__onFinishChange.call(l,l.getValue())});a.bind(this.__input,"mousedown",function(b){a.bind(window,"mousemove",j);a.bind(window,"mouseup",m);o=b.clientY});a.bind(this.__input,"keydown",function(a){if(a.keyCode===13)l.__truncationSuspended=true,this.blur(),l.__truncationSuspended=false});this.updateDisplay();this.domElement.appendChild(this.__input)};d.superclass=e;c.extend(d.prototype,e.prototype,{updateDisplay:function(){var a=this.__input,
b;if(this.__truncationSuspended)b=this.getValue();else{b=this.getValue();var c=Math.pow(10,this.__precision);b=Math.round(b*c)/c}a.value=b;return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.NumberController,dat.dom.dom,dat.utils.common);
dat.controllers.NumberControllerSlider=function(e,a,c,d,f){var b=function(d,c,f,e,l){function o(b){b.preventDefault();var d=a.getOffset(g.__background),c=a.getWidth(g.__background);g.setValue(g.__min+(g.__max-g.__min)*((b.clientX-d.left)/(d.left+c-d.left)));return false}function y(){a.unbind(window,"mousemove",o);a.unbind(window,"mouseup",y);g.__onFinishChange&&g.__onFinishChange.call(g,g.getValue())}b.superclass.call(this,d,c,{min:f,max:e,step:l});var g=this;this.__background=document.createElement("div");
this.__foreground=document.createElement("div");a.bind(this.__background,"mousedown",function(b){a.bind(window,"mousemove",o);a.bind(window,"mouseup",y);o(b)});a.addClass(this.__background,"slider");a.addClass(this.__foreground,"slider-fg");this.updateDisplay();this.__background.appendChild(this.__foreground);this.domElement.appendChild(this.__background)};b.superclass=e;b.useDefaultStyles=function(){c.inject(f)};d.extend(b.prototype,e.prototype,{updateDisplay:function(){this.__foreground.style.width=
(this.getValue()-this.__min)/(this.__max-this.__min)*100+"%";return b.superclass.prototype.updateDisplay.call(this)}});return b}(dat.controllers.NumberController,dat.dom.dom,dat.utils.css,dat.utils.common,".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");
dat.controllers.FunctionController=function(e,a,c){var d=function(c,b,e){d.superclass.call(this,c,b);var h=this;this.__button=document.createElement("div");this.__button.innerHTML=e===void 0?"Fire":e;a.bind(this.__button,"click",function(a){a.preventDefault();h.fire();return false});a.addClass(this.__button,"button");this.domElement.appendChild(this.__button)};d.superclass=e;c.extend(d.prototype,e.prototype,{fire:function(){this.__onChange&&this.__onChange.call(this);this.__onFinishChange&&this.__onFinishChange.call(this,
this.getValue());this.getValue().call(this.object)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);
dat.controllers.BooleanController=function(e,a,c){var d=function(c,b){d.superclass.call(this,c,b);var e=this;this.__prev=this.getValue();this.__checkbox=document.createElement("input");this.__checkbox.setAttribute("type","checkbox");a.bind(this.__checkbox,"change",function(){e.setValue(!e.__prev)},false);this.domElement.appendChild(this.__checkbox);this.updateDisplay()};d.superclass=e;c.extend(d.prototype,e.prototype,{setValue:function(a){a=d.superclass.prototype.setValue.call(this,a);this.__onFinishChange&&
this.__onFinishChange.call(this,this.getValue());this.__prev=this.getValue();return a},updateDisplay:function(){this.getValue()===true?(this.__checkbox.setAttribute("checked","checked"),this.__checkbox.checked=true):this.__checkbox.checked=false;return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common);
dat.color.toString=function(e){return function(a){if(a.a==1||e.isUndefined(a.a)){for(a=a.hex.toString(16);a.length<6;)a="0"+a;return"#"+a}else return"rgba("+Math.round(a.r)+","+Math.round(a.g)+","+Math.round(a.b)+","+a.a+")"}}(dat.utils.common);
dat.color.interpret=function(e,a){var c,d,f=[{litmus:a.isString,conversions:{NWE_CHAR_HEX:{read:function(a){a=a.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return a===null?false:{space:"HEX",hex:parseInt("0x"+a[1].toString()+a[1].toString()+a[2].toString()+a[2].toString()+a[3].toString()+a[3].toString())}},write:e},SIX_CHAR_HEX:{read:function(a){a=a.match(/^#([A-F0-9]{6})$/i);return a===null?false:{space:"HEX",hex:parseInt("0x"+a[1].toString())}},write:e},CSS_RGB:{read:function(a){a=a.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
return a===null?false:{space:"RGB",r:parseFloat(a[1]),g:parseFloat(a[2]),b:parseFloat(a[3])}},write:e},CSS_RGBA:{read:function(a){a=a.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);return a===null?false:{space:"RGB",r:parseFloat(a[1]),g:parseFloat(a[2]),b:parseFloat(a[3]),a:parseFloat(a[4])}},write:e}}},{litmus:a.isNumber,conversions:{HEX:{read:function(a){return{space:"HEX",hex:a,conversionName:"HEX"}},write:function(a){return a.hex}}}},{litmus:a.isArray,conversions:{RGB_ARRAY:{read:function(a){return a.length!=
3?false:{space:"RGB",r:a[0],g:a[1],b:a[2]}},write:function(a){return[a.r,a.g,a.b]}},RGBA_ARRAY:{read:function(a){return a.length!=4?false:{space:"RGB",r:a[0],g:a[1],b:a[2],a:a[3]}},write:function(a){return[a.r,a.g,a.b,a.a]}}}},{litmus:a.isObject,conversions:{RGBA_OBJ:{read:function(b){return a.isNumber(b.r)&&a.isNumber(b.g)&&a.isNumber(b.b)&&a.isNumber(b.a)?{space:"RGB",r:b.r,g:b.g,b:b.b,a:b.a}:false},write:function(a){return{r:a.r,g:a.g,b:a.b,a:a.a}}},RGB_OBJ:{read:function(b){return a.isNumber(b.r)&&
a.isNumber(b.g)&&a.isNumber(b.b)?{space:"RGB",r:b.r,g:b.g,b:b.b}:false},write:function(a){return{r:a.r,g:a.g,b:a.b}}},HSVA_OBJ:{read:function(b){return a.isNumber(b.h)&&a.isNumber(b.s)&&a.isNumber(b.v)&&a.isNumber(b.a)?{space:"HSV",h:b.h,s:b.s,v:b.v,a:b.a}:false},write:function(a){return{h:a.h,s:a.s,v:a.v,a:a.a}}},HSV_OBJ:{read:function(b){return a.isNumber(b.h)&&a.isNumber(b.s)&&a.isNumber(b.v)?{space:"HSV",h:b.h,s:b.s,v:b.v}:false},write:function(a){return{h:a.h,s:a.s,v:a.v}}}}}];return function(){d=
false;var b=arguments.length>1?a.toArray(arguments):arguments[0];a.each(f,function(e){if(e.litmus(b))return a.each(e.conversions,function(e,f){c=e.read(b);if(d===false&&c!==false)return d=c,c.conversionName=f,c.conversion=e,a.BREAK}),a.BREAK});return d}}(dat.color.toString,dat.utils.common);
dat.GUI=dat.gui.GUI=function(e,a,c,d,f,b,n,h,j,m,l,o,y,g,i){function q(a,b,r,c){if(b[r]===void 0)throw Error("Object "+b+' has no property "'+r+'"');c.color?b=new l(b,r):(b=[b,r].concat(c.factoryArgs),b=d.apply(a,b));if(c.before instanceof f)c.before=c.before.__li;t(a,b);g.addClass(b.domElement,"c");r=document.createElement("span");g.addClass(r,"property-name");r.innerHTML=b.property;var e=document.createElement("div");e.appendChild(r);e.appendChild(b.domElement);c=s(a,e,c.before);g.addClass(c,k.CLASS_CONTROLLER_ROW);
g.addClass(c,typeof b.getValue());p(a,c,b);a.__controllers.push(b);return b}function s(a,b,d){var c=document.createElement("li");b&&c.appendChild(b);d?a.__ul.insertBefore(c,params.before):a.__ul.appendChild(c);a.onResize();return c}function p(a,d,c){c.__li=d;c.__gui=a;i.extend(c,{options:function(b){if(arguments.length>1)return c.remove(),q(a,c.object,c.property,{before:c.__li.nextElementSibling,factoryArgs:[i.toArray(arguments)]});if(i.isArray(b)||i.isObject(b))return c.remove(),q(a,c.object,c.property,
{before:c.__li.nextElementSibling,factoryArgs:[b]})},name:function(a){c.__li.firstElementChild.firstElementChild.innerHTML=a;return c},listen:function(){c.__gui.listen(c);return c},remove:function(){c.__gui.remove(c);return c}});if(c instanceof j){var e=new h(c.object,c.property,{min:c.__min,max:c.__max,step:c.__step});i.each(["updateDisplay","onChange","onFinishChange"],function(a){var b=c[a],H=e[a];c[a]=e[a]=function(){var a=Array.prototype.slice.call(arguments);b.apply(c,a);return H.apply(e,a)}});
g.addClass(d,"has-slider");c.domElement.insertBefore(e.domElement,c.domElement.firstElementChild)}else if(c instanceof h){var f=function(b){return i.isNumber(c.__min)&&i.isNumber(c.__max)?(c.remove(),q(a,c.object,c.property,{before:c.__li.nextElementSibling,factoryArgs:[c.__min,c.__max,c.__step]})):b};c.min=i.compose(f,c.min);c.max=i.compose(f,c.max)}else if(c instanceof b)g.bind(d,"click",function(){g.fakeEvent(c.__checkbox,"click")}),g.bind(c.__checkbox,"click",function(a){a.stopPropagation()});
else if(c instanceof n)g.bind(d,"click",function(){g.fakeEvent(c.__button,"click")}),g.bind(d,"mouseover",function(){g.addClass(c.__button,"hover")}),g.bind(d,"mouseout",function(){g.removeClass(c.__button,"hover")});else if(c instanceof l)g.addClass(d,"color"),c.updateDisplay=i.compose(function(a){d.style.borderLeftColor=c.__color.toString();return a},c.updateDisplay),c.updateDisplay();c.setValue=i.compose(function(b){a.getRoot().__preset_select&&c.isModified()&&B(a.getRoot(),true);return b},c.setValue)}
function t(a,b){var c=a.getRoot(),d=c.__rememberedObjects.indexOf(b.object);if(d!=-1){var e=c.__rememberedObjectIndecesToControllers[d];e===void 0&&(e={},c.__rememberedObjectIndecesToControllers[d]=e);e[b.property]=b;if(c.load&&c.load.remembered){c=c.load.remembered;if(c[a.preset])c=c[a.preset];else if(c[w])c=c[w];else return;if(c[d]&&c[d][b.property]!==void 0)d=c[d][b.property],b.initialValue=d,b.setValue(d)}}}function I(a){var b=a.__save_row=document.createElement("li");g.addClass(a.domElement,
"has-save");a.__ul.insertBefore(b,a.__ul.firstChild);g.addClass(b,"save-row");var c=document.createElement("span");c.innerHTML="&nbsp;";g.addClass(c,"button gears");var d=document.createElement("span");d.innerHTML="Save";g.addClass(d,"button");g.addClass(d,"save");var e=document.createElement("span");e.innerHTML="New";g.addClass(e,"button");g.addClass(e,"save-as");var f=document.createElement("span");f.innerHTML="Revert";g.addClass(f,"button");g.addClass(f,"revert");var m=a.__preset_select=document.createElement("select");
a.load&&a.load.remembered?i.each(a.load.remembered,function(b,c){C(a,c,c==a.preset)}):C(a,w,false);g.bind(m,"change",function(){for(var b=0;b<a.__preset_select.length;b++)a.__preset_select[b].innerHTML=a.__preset_select[b].value;a.preset=this.value});b.appendChild(m);b.appendChild(c);b.appendChild(d);b.appendChild(e);b.appendChild(f);if(u){var b=document.getElementById("dg-save-locally"),l=document.getElementById("dg-local-explain");b.style.display="block";b=document.getElementById("dg-local-storage");
localStorage.getItem(document.location.href+".isLocal")==="true"&&b.setAttribute("checked","checked");var o=function(){l.style.display=a.useLocalStorage?"block":"none"};o();g.bind(b,"change",function(){a.useLocalStorage=!a.useLocalStorage;o()})}var h=document.getElementById("dg-new-constructor");g.bind(h,"keydown",function(a){a.metaKey&&(a.which===67||a.keyCode==67)&&x.hide()});g.bind(c,"click",function(){h.innerHTML=JSON.stringify(a.getSaveObject(),void 0,2);x.show();h.focus();h.select()});g.bind(d,
"click",function(){a.save()});g.bind(e,"click",function(){var b=prompt("Enter a new preset name.");b&&a.saveAs(b)});g.bind(f,"click",function(){a.revert()})}function J(a){function b(f){f.preventDefault();e=f.clientX;g.addClass(a.__closeButton,k.CLASS_DRAG);g.bind(window,"mousemove",c);g.bind(window,"mouseup",d);return false}function c(b){b.preventDefault();a.width+=e-b.clientX;a.onResize();e=b.clientX;return false}function d(){g.removeClass(a.__closeButton,k.CLASS_DRAG);g.unbind(window,"mousemove",
c);g.unbind(window,"mouseup",d)}a.__resize_handle=document.createElement("div");i.extend(a.__resize_handle.style,{width:"6px",marginLeft:"-3px",height:"200px",cursor:"ew-resize",position:"absolute"});var e;g.bind(a.__resize_handle,"mousedown",b);g.bind(a.__closeButton,"mousedown",b);a.domElement.insertBefore(a.__resize_handle,a.domElement.firstElementChild)}function D(a,b){a.domElement.style.width=b+"px";if(a.__save_row&&a.autoPlace)a.__save_row.style.width=b+"px";if(a.__closeButton)a.__closeButton.style.width=
b+"px"}function z(a,b){var c={};i.each(a.__rememberedObjects,function(d,e){var f={};i.each(a.__rememberedObjectIndecesToControllers[e],function(a,c){f[c]=b?a.initialValue:a.getValue()});c[e]=f});return c}function C(a,b,c){var d=document.createElement("option");d.innerHTML=b;d.value=b;a.__preset_select.appendChild(d);if(c)a.__preset_select.selectedIndex=a.__preset_select.length-1}function B(a,b){var c=a.__preset_select[a.__preset_select.selectedIndex];c.innerHTML=b?c.value+"*":c.value}function E(a){a.length!=
0&&o(function(){E(a)});i.each(a,function(a){a.updateDisplay()})}e.inject(c);var w="Default",u;try{u="localStorage"in window&&window.localStorage!==null}catch(K){u=false}var x,F=true,v,A=false,G=[],k=function(a){function b(){localStorage.setItem(document.location.href+".gui",JSON.stringify(d.getSaveObject()))}function c(){var a=d.getRoot();a.width+=1;i.defer(function(){a.width-=1})}var d=this;this.domElement=document.createElement("div");this.__ul=document.createElement("ul");this.domElement.appendChild(this.__ul);
g.addClass(this.domElement,"dg");this.__folders={};this.__controllers=[];this.__rememberedObjects=[];this.__rememberedObjectIndecesToControllers=[];this.__listening=[];a=a||{};a=i.defaults(a,{autoPlace:true,width:k.DEFAULT_WIDTH});a=i.defaults(a,{resizable:a.autoPlace,hideable:a.autoPlace});if(i.isUndefined(a.load))a.load={preset:w};else if(a.preset)a.load.preset=a.preset;i.isUndefined(a.parent)&&a.hideable&&G.push(this);a.resizable=i.isUndefined(a.parent)&&a.resizable;if(a.autoPlace&&i.isUndefined(a.scrollable))a.scrollable=
true;var e=u&&localStorage.getItem(document.location.href+".isLocal")==="true";Object.defineProperties(this,{parent:{get:function(){return a.parent}},scrollable:{get:function(){return a.scrollable}},autoPlace:{get:function(){return a.autoPlace}},preset:{get:function(){return d.parent?d.getRoot().preset:a.load.preset},set:function(b){d.parent?d.getRoot().preset=b:a.load.preset=b;for(b=0;b<this.__preset_select.length;b++)if(this.__preset_select[b].value==this.preset)this.__preset_select.selectedIndex=
b;d.revert()}},width:{get:function(){return a.width},set:function(b){a.width=b;D(d,b)}},name:{get:function(){return a.name},set:function(b){a.name=b;if(m)m.innerHTML=a.name}},closed:{get:function(){return a.closed},set:function(b){a.closed=b;a.closed?g.addClass(d.__ul,k.CLASS_CLOSED):g.removeClass(d.__ul,k.CLASS_CLOSED);this.onResize();if(d.__closeButton)d.__closeButton.innerHTML=b?k.TEXT_OPEN:k.TEXT_CLOSED}},load:{get:function(){return a.load}},useLocalStorage:{get:function(){return e},set:function(a){u&&
((e=a)?g.bind(window,"unload",b):g.unbind(window,"unload",b),localStorage.setItem(document.location.href+".isLocal",a))}}});if(i.isUndefined(a.parent)){a.closed=false;g.addClass(this.domElement,k.CLASS_MAIN);g.makeSelectable(this.domElement,false);if(u&&e){d.useLocalStorage=true;var f=localStorage.getItem(document.location.href+".gui");if(f)a.load=JSON.parse(f)}this.__closeButton=document.createElement("div");this.__closeButton.innerHTML=k.TEXT_CLOSED;g.addClass(this.__closeButton,k.CLASS_CLOSE_BUTTON);
this.domElement.appendChild(this.__closeButton);g.bind(this.__closeButton,"click",function(){d.closed=!d.closed})}else{if(a.closed===void 0)a.closed=true;var m=document.createTextNode(a.name);g.addClass(m,"controller-name");f=s(d,m);g.addClass(this.__ul,k.CLASS_CLOSED);g.addClass(f,"title");g.bind(f,"click",function(a){a.preventDefault();d.closed=!d.closed;return false});if(!a.closed)this.closed=false}a.autoPlace&&(i.isUndefined(a.parent)&&(F&&(v=document.createElement("div"),g.addClass(v,"dg"),g.addClass(v,
k.CLASS_AUTO_PLACE_CONTAINER),document.body.appendChild(v),F=false),v.appendChild(this.domElement),g.addClass(this.domElement,k.CLASS_AUTO_PLACE)),this.parent||D(d,a.width));g.bind(window,"resize",function(){d.onResize()});g.bind(this.__ul,"webkitTransitionEnd",function(){d.onResize()});g.bind(this.__ul,"transitionend",function(){d.onResize()});g.bind(this.__ul,"oTransitionEnd",function(){d.onResize()});this.onResize();a.resizable&&J(this);d.getRoot();a.parent||c()};k.toggleHide=function(){A=!A;i.each(G,
function(a){a.domElement.style.zIndex=A?-999:999;a.domElement.style.opacity=A?0:1})};k.CLASS_AUTO_PLACE="a";k.CLASS_AUTO_PLACE_CONTAINER="ac";k.CLASS_MAIN="main";k.CLASS_CONTROLLER_ROW="cr";k.CLASS_TOO_TALL="taller-than-window";k.CLASS_CLOSED="closed";k.CLASS_CLOSE_BUTTON="close-button";k.CLASS_DRAG="drag";k.DEFAULT_WIDTH=245;k.TEXT_CLOSED="Close Controls";k.TEXT_OPEN="Open Controls";g.bind(window,"keydown",function(a){document.activeElement.type!=="text"&&(a.which===72||a.keyCode==72)&&k.toggleHide()},
false);i.extend(k.prototype,{add:function(a,b){return q(this,a,b,{factoryArgs:Array.prototype.slice.call(arguments,2)})},addColor:function(a,b){return q(this,a,b,{color:true})},remove:function(a){this.__ul.removeChild(a.__li);this.__controllers.slice(this.__controllers.indexOf(a),1);var b=this;i.defer(function(){b.onResize()})},destroy:function(){this.autoPlace&&v.removeChild(this.domElement)},addFolder:function(a){if(this.__folders[a]!==void 0)throw Error('You already have a folder in this GUI by the name "'+
a+'"');var b={name:a,parent:this};b.autoPlace=this.autoPlace;if(this.load&&this.load.folders&&this.load.folders[a])b.closed=this.load.folders[a].closed,b.load=this.load.folders[a];b=new k(b);this.__folders[a]=b;a=s(this,b.domElement);g.addClass(a,"folder");return b},open:function(){this.closed=false},close:function(){this.closed=true},onResize:function(){var a=this.getRoot();if(a.scrollable){var b=g.getOffset(a.__ul).top,c=0;i.each(a.__ul.childNodes,function(b){a.autoPlace&&b===a.__save_row||(c+=
g.getHeight(b))});window.innerHeight-b-20<c?(g.addClass(a.domElement,k.CLASS_TOO_TALL),a.__ul.style.height=window.innerHeight-b-20+"px"):(g.removeClass(a.domElement,k.CLASS_TOO_TALL),a.__ul.style.height="auto")}a.__resize_handle&&i.defer(function(){a.__resize_handle.style.height=a.__ul.offsetHeight+"px"});if(a.__closeButton)a.__closeButton.style.width=a.width+"px"},remember:function(){if(i.isUndefined(x))x=new y,x.domElement.innerHTML=a;if(this.parent)throw Error("You can only call remember on a top level GUI.");
var b=this;i.each(Array.prototype.slice.call(arguments),function(a){b.__rememberedObjects.length==0&&I(b);b.__rememberedObjects.indexOf(a)==-1&&b.__rememberedObjects.push(a)});this.autoPlace&&D(this,this.width)},getRoot:function(){for(var a=this;a.parent;)a=a.parent;return a},getSaveObject:function(){var a=this.load;a.closed=this.closed;if(this.__rememberedObjects.length>0){a.preset=this.preset;if(!a.remembered)a.remembered={};a.remembered[this.preset]=z(this)}a.folders={};i.each(this.__folders,function(b,
c){a.folders[c]=b.getSaveObject()});return a},save:function(){if(!this.load.remembered)this.load.remembered={};this.load.remembered[this.preset]=z(this);B(this,false)},saveAs:function(a){if(!this.load.remembered)this.load.remembered={},this.load.remembered[w]=z(this,true);this.load.remembered[a]=z(this);this.preset=a;C(this,a,true)},revert:function(a){i.each(this.__controllers,function(b){this.getRoot().load.remembered?t(a||this.getRoot(),b):b.setValue(b.initialValue)},this);i.each(this.__folders,
function(a){a.revert(a)});a||B(this.getRoot(),false)},listen:function(a){var b=this.__listening.length==0;this.__listening.push(a);b&&E(this.__listening)}});return k}(dat.utils.css,'<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>',
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory=function(e,a,c,d,f,b,n){return function(h,j,m,l){var o=h[j];if(n.isArray(m)||n.isObject(m))return new e(h,j,m);if(n.isNumber(o))return n.isNumber(m)&&n.isNumber(l)?new c(h,j,m,l):new a(h,j,{min:m,max:l});if(n.isString(o))return new d(h,j);if(n.isFunction(o))return new f(h,j,"");if(n.isBoolean(o))return new b(h,j)}}(dat.controllers.OptionController,dat.controllers.NumberControllerBox,dat.controllers.NumberControllerSlider,dat.controllers.StringController=function(e,a,c){var d=
function(c,b){function e(){h.setValue(h.__input.value)}d.superclass.call(this,c,b);var h=this;this.__input=document.createElement("input");this.__input.setAttribute("type","text");a.bind(this.__input,"keyup",e);a.bind(this.__input,"change",e);a.bind(this.__input,"blur",function(){h.__onFinishChange&&h.__onFinishChange.call(h,h.getValue())});a.bind(this.__input,"keydown",function(a){a.keyCode===13&&this.blur()});this.updateDisplay();this.domElement.appendChild(this.__input)};d.superclass=e;c.extend(d.prototype,
e.prototype,{updateDisplay:function(){if(!a.isActive(this.__input))this.__input.value=this.getValue();return d.superclass.prototype.updateDisplay.call(this)}});return d}(dat.controllers.Controller,dat.dom.dom,dat.utils.common),dat.controllers.FunctionController,dat.controllers.BooleanController,dat.utils.common),dat.controllers.Controller,dat.controllers.BooleanController,dat.controllers.FunctionController,dat.controllers.NumberControllerBox,dat.controllers.NumberControllerSlider,dat.controllers.OptionController,
dat.controllers.ColorController=function(e,a,c,d,f){function b(a,b,c,d){a.style.background="";f.each(j,function(e){a.style.cssText+="background: "+e+"linear-gradient("+b+", "+c+" 0%, "+d+" 100%); "})}function n(a){a.style.background="";a.style.cssText+="background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);";a.style.cssText+="background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";
a.style.cssText+="background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";a.style.cssText+="background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);";a.style.cssText+="background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"}var h=function(e,l){function o(b){q(b);a.bind(window,"mousemove",q);a.bind(window,
"mouseup",j)}function j(){a.unbind(window,"mousemove",q);a.unbind(window,"mouseup",j)}function g(){var a=d(this.value);a!==false?(p.__color.__state=a,p.setValue(p.__color.toOriginal())):this.value=p.__color.toString()}function i(){a.unbind(window,"mousemove",s);a.unbind(window,"mouseup",i)}function q(b){b.preventDefault();var c=a.getWidth(p.__saturation_field),d=a.getOffset(p.__saturation_field),e=(b.clientX-d.left+document.body.scrollLeft)/c,b=1-(b.clientY-d.top+document.body.scrollTop)/c;b>1?b=
1:b<0&&(b=0);e>1?e=1:e<0&&(e=0);p.__color.v=b;p.__color.s=e;p.setValue(p.__color.toOriginal());return false}function s(b){b.preventDefault();var c=a.getHeight(p.__hue_field),d=a.getOffset(p.__hue_field),b=1-(b.clientY-d.top+document.body.scrollTop)/c;b>1?b=1:b<0&&(b=0);p.__color.h=b*360;p.setValue(p.__color.toOriginal());return false}h.superclass.call(this,e,l);this.__color=new c(this.getValue());this.__temp=new c(0);var p=this;this.domElement=document.createElement("div");a.makeSelectable(this.domElement,
false);this.__selector=document.createElement("div");this.__selector.className="selector";this.__saturation_field=document.createElement("div");this.__saturation_field.className="saturation-field";this.__field_knob=document.createElement("div");this.__field_knob.className="field-knob";this.__field_knob_border="2px solid ";this.__hue_knob=document.createElement("div");this.__hue_knob.className="hue-knob";this.__hue_field=document.createElement("div");this.__hue_field.className="hue-field";this.__input=
document.createElement("input");this.__input.type="text";this.__input_textShadow="0 1px 1px ";a.bind(this.__input,"keydown",function(a){a.keyCode===13&&g.call(this)});a.bind(this.__input,"blur",g);a.bind(this.__selector,"mousedown",function(){a.addClass(this,"drag").bind(window,"mouseup",function(){a.removeClass(p.__selector,"drag")})});var t=document.createElement("div");f.extend(this.__selector.style,{width:"122px",height:"102px",padding:"3px",backgroundColor:"#222",boxShadow:"0px 1px 3px rgba(0,0,0,0.3)"});
f.extend(this.__field_knob.style,{position:"absolute",width:"12px",height:"12px",border:this.__field_knob_border+(this.__color.v<0.5?"#fff":"#000"),boxShadow:"0px 1px 3px rgba(0,0,0,0.5)",borderRadius:"12px",zIndex:1});f.extend(this.__hue_knob.style,{position:"absolute",width:"15px",height:"2px",borderRight:"4px solid #fff",zIndex:1});f.extend(this.__saturation_field.style,{width:"100px",height:"100px",border:"1px solid #555",marginRight:"3px",display:"inline-block",cursor:"pointer"});f.extend(t.style,
{width:"100%",height:"100%",background:"none"});b(t,"top","rgba(0,0,0,0)","#000");f.extend(this.__hue_field.style,{width:"15px",height:"100px",display:"inline-block",border:"1px solid #555",cursor:"ns-resize"});n(this.__hue_field);f.extend(this.__input.style,{outline:"none",textAlign:"center",color:"#fff",border:0,fontWeight:"bold",textShadow:this.__input_textShadow+"rgba(0,0,0,0.7)"});a.bind(this.__saturation_field,"mousedown",o);a.bind(this.__field_knob,"mousedown",o);a.bind(this.__hue_field,"mousedown",
function(b){s(b);a.bind(window,"mousemove",s);a.bind(window,"mouseup",i)});this.__saturation_field.appendChild(t);this.__selector.appendChild(this.__field_knob);this.__selector.appendChild(this.__saturation_field);this.__selector.appendChild(this.__hue_field);this.__hue_field.appendChild(this.__hue_knob);this.domElement.appendChild(this.__input);this.domElement.appendChild(this.__selector);this.updateDisplay()};h.superclass=e;f.extend(h.prototype,e.prototype,{updateDisplay:function(){var a=d(this.getValue());
if(a!==false){var e=false;f.each(c.COMPONENTS,function(b){if(!f.isUndefined(a[b])&&!f.isUndefined(this.__color.__state[b])&&a[b]!==this.__color.__state[b])return e=true,{}},this);e&&f.extend(this.__color.__state,a)}f.extend(this.__temp.__state,this.__color.__state);this.__temp.a=1;var h=this.__color.v<0.5||this.__color.s>0.5?255:0,j=255-h;f.extend(this.__field_knob.style,{marginLeft:100*this.__color.s-7+"px",marginTop:100*(1-this.__color.v)-7+"px",backgroundColor:this.__temp.toString(),border:this.__field_knob_border+
"rgb("+h+","+h+","+h+")"});this.__hue_knob.style.marginTop=(1-this.__color.h/360)*100+"px";this.__temp.s=1;this.__temp.v=1;b(this.__saturation_field,"left","#fff",this.__temp.toString());f.extend(this.__input.style,{backgroundColor:this.__input.value=this.__color.toString(),color:"rgb("+h+","+h+","+h+")",textShadow:this.__input_textShadow+"rgba("+j+","+j+","+j+",.7)"})}});var j=["-moz-","-o-","-webkit-","-ms-",""];return h}(dat.controllers.Controller,dat.dom.dom,dat.color.Color=function(e,a,c,d){function f(a,
b,c){Object.defineProperty(a,b,{get:function(){if(this.__state.space==="RGB")return this.__state[b];n(this,b,c);return this.__state[b]},set:function(a){if(this.__state.space!=="RGB")n(this,b,c),this.__state.space="RGB";this.__state[b]=a}})}function b(a,b){Object.defineProperty(a,b,{get:function(){if(this.__state.space==="HSV")return this.__state[b];h(this);return this.__state[b]},set:function(a){if(this.__state.space!=="HSV")h(this),this.__state.space="HSV";this.__state[b]=a}})}function n(b,c,e){if(b.__state.space===
"HEX")b.__state[c]=a.component_from_hex(b.__state.hex,e);else if(b.__state.space==="HSV")d.extend(b.__state,a.hsv_to_rgb(b.__state.h,b.__state.s,b.__state.v));else throw"Corrupted color state";}function h(b){var c=a.rgb_to_hsv(b.r,b.g,b.b);d.extend(b.__state,{s:c.s,v:c.v});if(d.isNaN(c.h)){if(d.isUndefined(b.__state.h))b.__state.h=0}else b.__state.h=c.h}var j=function(){this.__state=e.apply(this,arguments);if(this.__state===false)throw"Failed to interpret color arguments";this.__state.a=this.__state.a||
1};j.COMPONENTS="r,g,b,h,s,v,hex,a".split(",");d.extend(j.prototype,{toString:function(){return c(this)},toOriginal:function(){return this.__state.conversion.write(this)}});f(j.prototype,"r",2);f(j.prototype,"g",1);f(j.prototype,"b",0);b(j.prototype,"h");b(j.prototype,"s");b(j.prototype,"v");Object.defineProperty(j.prototype,"a",{get:function(){return this.__state.a},set:function(a){this.__state.a=a}});Object.defineProperty(j.prototype,"hex",{get:function(){if(!this.__state.space!=="HEX")this.__state.hex=
a.rgb_to_hex(this.r,this.g,this.b);return this.__state.hex},set:function(a){this.__state.space="HEX";this.__state.hex=a}});return j}(dat.color.interpret,dat.color.math=function(){var e;return{hsv_to_rgb:function(a,c,d){var e=a/60-Math.floor(a/60),b=d*(1-c),n=d*(1-e*c),c=d*(1-(1-e)*c),a=[[d,c,b],[n,d,b],[b,d,c],[b,n,d],[c,b,d],[d,b,n]][Math.floor(a/60)%6];return{r:a[0]*255,g:a[1]*255,b:a[2]*255}},rgb_to_hsv:function(a,c,d){var e=Math.min(a,c,d),b=Math.max(a,c,d),e=b-e;if(b==0)return{h:NaN,s:0,v:0};
a=a==b?(c-d)/e:c==b?2+(d-a)/e:4+(a-c)/e;a/=6;a<0&&(a+=1);return{h:a*360,s:e/b,v:b/255}},rgb_to_hex:function(a,c,d){a=this.hex_with_component(0,2,a);a=this.hex_with_component(a,1,c);return a=this.hex_with_component(a,0,d)},component_from_hex:function(a,c){return a>>c*8&255},hex_with_component:function(a,c,d){return d<<(e=c*8)|a&~(255<<e)}}}(),dat.color.toString,dat.utils.common),dat.color.interpret,dat.utils.common),dat.utils.requestAnimationFrame=function(){return window.webkitRequestAnimationFrame||
window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(e,1E3/60)}}(),dat.dom.CenteredDiv=function(e,a){var c=function(){this.backgroundElement=document.createElement("div");a.extend(this.backgroundElement.style,{backgroundColor:"rgba(0,0,0,0.8)",top:0,left:0,display:"none",zIndex:"1000",opacity:0,WebkitTransition:"opacity 0.2s linear"});e.makeFullscreen(this.backgroundElement);this.backgroundElement.style.position="fixed";this.domElement=
document.createElement("div");a.extend(this.domElement.style,{position:"fixed",display:"none",zIndex:"1001",opacity:0,WebkitTransition:"-webkit-transform 0.2s ease-out, opacity 0.2s linear"});document.body.appendChild(this.backgroundElement);document.body.appendChild(this.domElement);var c=this;e.bind(this.backgroundElement,"click",function(){c.hide()})};c.prototype.show=function(){var c=this;this.backgroundElement.style.display="block";this.domElement.style.display="block";this.domElement.style.opacity=
0;this.domElement.style.webkitTransform="scale(1.1)";this.layout();a.defer(function(){c.backgroundElement.style.opacity=1;c.domElement.style.opacity=1;c.domElement.style.webkitTransform="scale(1)"})};c.prototype.hide=function(){var a=this,c=function(){a.domElement.style.display="none";a.backgroundElement.style.display="none";e.unbind(a.domElement,"webkitTransitionEnd",c);e.unbind(a.domElement,"transitionend",c);e.unbind(a.domElement,"oTransitionEnd",c)};e.bind(this.domElement,"webkitTransitionEnd",
c);e.bind(this.domElement,"transitionend",c);e.bind(this.domElement,"oTransitionEnd",c);this.backgroundElement.style.opacity=0;this.domElement.style.opacity=0;this.domElement.style.webkitTransform="scale(1.1)"};c.prototype.layout=function(){this.domElement.style.left=window.innerWidth/2-e.getWidth(this.domElement)/2+"px";this.domElement.style.top=window.innerHeight/2-e.getHeight(this.domElement)/2+"px"};return c}(dat.dom.dom,dat.utils.common),dat.dom.dom,dat.utils.common);


// src/nwEngine.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var NWE = {

        REVISION: '5dev',
        BUILD: 2200,

        gfx: {},
        fw: {},
        audio: {}

    };

    // don't use self in global context

    var self = undefined;

    console.log( 'NWEngine. Rev ' + NWE.REVISION + '. Build ' + NWE.BUILD );

    // nothing here =P

    scope.NWE = NWE;
    if ( scope.__NWE ) {
        for ( var i = 0, il = scope.__NWE.length; i < il; i ++ ) scope.__NWE[ i ]( NWE );
        delete scope.__NWE;
    }

    scope.self = self;
    if ( scope.__self ) {
        for ( var i = 0, il = scope.__self.length; i < il; i ++ ) scope.__self[ i ]( self );
        delete scope.__self;
    }

}) ( window );


// src/helpers/Mobile.js

( function ( scope ) {

    /*
     * is hardware mobile device helper
     * @author ohmed
    */

    var MOBILE = !!(function(a){if(/(tizen|android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) return 1; else return 0; })(navigator.userAgent||navigator.vendor||window.opera);

    var isMobile = function () {

        return MOBILE;

    };

    if ( typeof isMobile === 'function' ) {
        var t = {}, p = {};
        for ( var i in isMobile ) t[i] = isMobile[i];
        for ( var i in isMobile.prototype ) try { p[i] = isMobile.prototype[i] } catch(e) {};
        scope.isMobile = isMobile.bind( scope );
    } else {
        scope.isMobile = isMobile;
    }
    scope.isMobile.prototype = isMobile.prototype;
    for ( var i in t ) scope.isMobile[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.isMobile.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__isMobile ) {
        for ( var i = 0, il = scope.__isMobile.length; i < il; i ++ ) scope.__isMobile[ i ]( isMobile );
        delete scope.__isMobile;
    }

}) ( NWE );


// src/helpers/Browser.js

( function ( scope ) {

    /*
     * detect browser helper
     * @author ohmed
    */

    var BROWSER;

    if ( !!window.chrome ) {

        BROWSER = 'CHROME';

    } else if ( typeof InstallTrigger !== 'undefined' ) {

        BROWSER = 'FIREFOX';

    } else if ( !!window.opera || navigator.userAgent.indexOf('Opera') >= 0 ) {

        BROWSER = 'OPERA';

    } else {

        BROWSER = 'IE';

    }

    var getBrowser = function () {

        return BROWSER;

    };

    if ( typeof getBrowser === 'function' ) {
        var t = {}, p = {};
        for ( var i in getBrowser ) t[i] = getBrowser[i];
        for ( var i in getBrowser.prototype ) try { p[i] = getBrowser.prototype[i] } catch(e) {};
        scope.getBrowser = getBrowser.bind( scope );
    } else {
        scope.getBrowser = getBrowser;
    }
    scope.getBrowser.prototype = getBrowser.prototype;
    for ( var i in t ) scope.getBrowser[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.getBrowser.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__getBrowser ) {
        for ( var i = 0, il = scope.__getBrowser.length; i < il; i ++ ) scope.__getBrowser[ i ]( getBrowser );
        delete scope.__getBrowser;
    }

}) ( NWE );


// src/helpers/Detector.js

( function ( scope ) {

    /*
     * detect capabilities
     * @author ohmed
    */



    var canvas = !! window.CanvasRenderingContext2D;

    var webgl = ( function () {

        try {

            var canvas = document.createElement( 'canvas' );
            return !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );

        } catch ( e ) {

            return false;

        }

    } )();

    var canvas = !! window.CanvasRenderingContext2D;

    var workers = !! window.Worker;

    var fileapi = window.File && window.FileReader && window.FileList && window.Blob;

    var Detector = function () {};

    Detector.prototype.isWebGLSupported = function () {

        return webgl;

    };

    Detector.prototype.getWebGLErrorMessage = function () {

        var element = document.createElement( 'div' );
        element.id = 'webgl-error-message';
        element.style.fontFamily = 'monospace';
        element.style.fontSize = '13px';
        element.style.fontWeight = 'normal';
        element.style.textAlign = 'center';
        element.style.background = '#fff';
        element.style.color = '#000';
        element.style.padding = '1.5em';
        element.style.width = '400px';
        element.style.margin = '5em auto 0';

        if ( ! webgl ) {

            element.innerHTML = window.WebGLRenderingContext ? [
                'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />',
                'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
            ].join( '\n' ) : [
                'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>',
                'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
            ].join( '\n' );

        }

        return element;

    };

    Detector.prototype.addGetWebGLMessage = function ( parameters ) {

        var parent, id, element;

        parameters = parameters || {};

        parent = parameters.parent !== undefined ? parameters.parent : document.body;
        id = parameters.id !== undefined ? parameters.id : 'oldie';

        element = Detector.getWebGLErrorMessage();
        element.id = id;

        parent.appendChild( element );

    };

    var Detector = new Detector();

    scope.Detector = Detector;
    if ( scope.__Detector ) {
        for ( var i = 0, il = scope.__Detector.length; i < il; i ++ ) scope.__Detector[ i ]( Detector );
        delete scope.__Detector;
    }

}) ( NWE );


// src/core/Clock.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var Clock = function ( autoStart ) {

        this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;

        this.running = false;

    };

    Clock.prototype = {

        constructor: Clock,

        start: function () {

            this.startTime = window.performance !== undefined && window.performance.now !== undefined
                                ? window.performance.now()
                                : Date.now();

            this.oldTime = this.startTime;
            this.running = true;

        },

        stop: function () {

            this.getElapsedTime();
            this.running = false;

        },

        getElapsedTime: function () {

            this.getDelta();
            return this.elapsedTime;

        },

        getDelta: function () {

            var diff = 0;

            if ( this.autoStart && ! this.running ) {

                this.start();

            }

            if ( this.running ) {

                var newTime = window.performance !== undefined && window.performance.now !== undefined
                                ? window.performance.now()
                                : Date.now();

                diff = 0.001 * ( newTime - this.oldTime );
                this.oldTime = newTime;

                this.elapsedTime += diff;

            }

            return diff;

        }

    };

    if ( typeof Clock === 'function' ) {
        var t = {}, p = {};
        for ( var i in Clock ) t[i] = Clock[i];
        for ( var i in Clock.prototype ) try { p[i] = Clock.prototype[i] } catch(e) {};
        scope.Clock = Clock.bind( scope );
    } else {
        scope.Clock = Clock;
    }
    scope.Clock.prototype = Clock.prototype;
    for ( var i in t ) scope.Clock[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Clock.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Clock ) {
        for ( var i = 0, il = scope.__Clock.length; i < il; i ++ ) scope.__Clock[ i ]( Clock );
        delete scope.__Clock;
    }

}) ( NWE );


// src/core/Pack.js

( function ( scope ) {

    /*
     * @author ohmed
    */

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var LayoutBufferGeometry = NWE.gfx.LayoutBufferGeometry;
    if ( !LayoutBufferGeometry ) { NWE.gfx.__LayoutBufferGeometry = (NWE.gfx.__LayoutBufferGeometry || []); NWE.gfx.__LayoutBufferGeometry.push( function ( obj ) { LayoutBufferGeometry = obj; } ); }

    var ShaderMaterial = NWE.gfx.ShaderMaterial;
    if ( !ShaderMaterial ) { NWE.gfx.__ShaderMaterial = (NWE.gfx.__ShaderMaterial || []); NWE.gfx.__ShaderMaterial.push( function ( obj ) { ShaderMaterial = obj; } ); }


    var Pack = function ( data ) {

        var geometries = data.geometries || {};
        var materials = data.materials || {};
        var shaders = data.shaders || {};
        var textures = data.textures || {};
        var configs = data.configs || {};

        //

        this.getRawGeometry = function ( name ) {

            if ( !geometries[ name ] ) {

                Logger.log( 'NWE.PackLoader.getRawGeometry(): No such geometry ' + name );
                return false;

            }

            return geometries[ name ];

        };

        this.getGeometry = function ( name ) {

            var rawGeometry = this.getRawGeometry( name );

            if ( rawGeometry ) {

                var attributes = rawGeometry.attributes;
                var attribute;
                var geometry = new LayoutBufferGeometry({ vertCount: rawGeometry.vertices, trisCount: rawGeometry.triangles });

                geometry.addAttribute( 'index', 3 * rawGeometry.triangles );

                for ( var attrName in attributes ) {

                    attribute = attributes[ attrName ];

                    if ( attrName !== 'index' ) {

                        geometry.addAttribute( attrName, attribute.itemSize );

                    }

                }

                geometry.bindArrays();

                for ( var attrName in attributes ) {

                    attribute = attributes[ attrName ];

                    geometry.fillAttribute( attrName, attribute );

                }

                geometry.computeChunkOffsets();

                return geometry;

            } else {

                return false;

            }

        };

        //

        this.getRawMaterial = function ( name ) {

            if ( !materials[ name ] ) {

                Logger.log( 'NWE.PackLoader.getRawMaterial(): No such material ' + name );
                return false;

            }

            return materials[ name ];

        };

        this.getMaterial = function ( name ) {

            var rawShader = this.getRawShader( name );

            if ( rawShader ) {

                var material = new ShaderMaterial({
                
                    attributes: rawShader.params.attributes,
                    uniforms: rawShader.params.uniforms,
                    defines: rawShader.params.defines,
                    varyings: rawShader.params.varyings,
                    vertexShader: rawShader.vertex,
                    fragmentShader: rawShader.fragment

                });

                return material;

            } else {

                return false;

            }

        };

        //

        this.getRawShader = function ( name ) {

            if ( !shaders[ name ] ) {

                Logger.log( 'NWE.PackLoader.getRawShader(): No such shader ' + name );
                return false;

            }

            return shaders[ name ];

        };

        //

        this.getRawTexture = function ( name ) {

            if ( !textures[ name ] ) {

                Logger.log( 'NWE.PackLoader.getRawTexture(): No such texture ' + name );
                return false;

            }

            return textures[ name ];

        };

        this.getTexture = function ( name ) {

            var rawTexture = this.getRawTexture( name );

            return ( rawTexture ) ? NWE.TextureLoader.load( rawTexture ) : false;

        };

        //

        this.getRawConfig = function ( name ) {

            if ( !configs[ name ] ) {

                Logger.log( 'NWE.PackLoader.getRawConfig(): No such config file ' + name );
                return false;

            }

            return configs[ name ];

        };

    };

    Pack.prototype = {

        constructor: Pack

    };

    if ( typeof Pack === 'function' ) {
        var t = {}, p = {};
        for ( var i in Pack ) t[i] = Pack[i];
        for ( var i in Pack.prototype ) try { p[i] = Pack.prototype[i] } catch(e) {};
        scope.Pack = Pack.bind( scope );
    } else {
        scope.Pack = Pack;
    }
    scope.Pack.prototype = Pack.prototype;
    for ( var i in t ) scope.Pack[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Pack.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Pack ) {
        for ( var i = 0, il = scope.__Pack.length; i < il; i ++ ) scope.__Pack[ i ]( Pack );
        delete scope.__Pack;
    }

}) ( NWE );


// src/core/Logger.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Logger = function () {

        var logger = {};

        logger.debugLevel = 2;

        logger.renderInfo = {

            memory: {

                programs: 0,
                geometries: 0,
                textures: 0

            },

            render: {

                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0

            }

        };

        logger.getTimeString = function() {

            var date = new Date();

            var minutes = ( date.getSeconds() < 10 ) ? '0' + date.getSeconds() : date.getSeconds();
            var seconds = ( date.getMinutes() < 10 ) ? '0' + date.getMinutes() : date.getMinutes();

            return '[' + date.getHours() + ':' + minutes + ':' + seconds + ']';

        };

        logger.getStack = function() {

            var stack = false,
                callerLineNumber = -1,
                callerFileURL = '',
                callerFileName = '';

            try {

                throw new Error();

            } catch(e) {

                stack = e.stack;

            }

            if ( stack.indexOf('@') !== -1 ) { // mozilla

                // TODO: handle mozilla stack parsing

            } else { // other

                var tmpData = stack.split(')')[2].split( window.location.host )[1].split(':');
                callerLineNumber = tmpData[ tmpData.length - 2 ];
                callerFileURL = tmpData[ tmpData.length - 3 ];
                callerFileURL = window.location.protocol + '//' + window.location.host + callerFileURL;
                callerFileName = callerFileURL.split('/').pop();

            }

            if ( callerLineNumber === -1 || !callerFileURL || !callerFileName ) {

                console.warn( 'Dont know why, but call stack is empty :(' );

            }

            return {

                callerFileName:     callerFileName,
                callerFileURL:      callerFileURL,
                callerLineNumber:   callerLineNumber,
                full:               stack

            };

        };

        logger.log = function( data ) {

            if ( logger.debugLevel > 1 ) {

                var stackInfo = logger.getStack();

                console.groupCollapsed( logger.getTimeString(), data );
                console.log( 'Trigger (' + stackInfo.callerFileURL + ':' + stackInfo.callerLineNumber + ')' );
                console.groupCollapsed( 'Full call stack' );
                console.log( stackInfo.full.replace( 'Error', 'Log' ) );
                console.groupEnd();
                console.groupEnd();

            }

        };

        logger.info = function( data ) {

            if ( logger.debugLevel > 2 ) {

                console.info( logger.getTimeString(), data );

            }

        };

        logger.warn = function( data ) {

            if ( logger.debugLevel > 1 ) {

                var stackInfo = logger.getStack();

                console.warn( logger.getTimeString(), data );
                // console.groupCollapsed();
                // console.error( 'Warn triggered (' + stackInfo.callerFileURL + ':' + stackInfo.callerLineNumber + ')' );
                // console.groupCollapsed( 'Full warn call stack' );
                // console.error( stackInfo.full );
                // console.groupEnd();

            }

        };

        logger.error = function( data ) {

            if ( logger.debugLevel > 1 ) {

                var stackInfo = logger.getStack();

                console.groupCollapsed( logger.getTimeString(), data );
                console.error( 'Error triggered (' + stackInfo.callerFileURL + ':' + stackInfo.callerLineNumber + ')' );
                console.groupCollapsed( 'Full error call stack' );
                console.error( stackInfo.full );
                console.groupEnd();
                console.groupEnd();

            }

        };

        return logger;

    }();

    scope.Logger = Logger;
    if ( scope.__Logger ) {
        for ( var i = 0, il = scope.__Logger.length; i < il; i ++ ) scope.__Logger[ i ]( Logger );
        delete scope.__Logger;
    }

}) ( NWE );


// src/events/EventDispatcher.js

( function ( scope ) {

    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */

    var EventDispatcher = function () {}

    EventDispatcher.prototype = {

        constructor: EventDispatcher,

        apply: function ( object ) {

            object.addEventListener = EventDispatcher.prototype.addEventListener;
            object.hasEventListener = EventDispatcher.prototype.hasEventListener;
            object.removeEventListener = EventDispatcher.prototype.removeEventListener;
            object.dispatchEvent = EventDispatcher.prototype.dispatchEvent;

        },

        addEventListener: function ( type, listener ) {

            if ( this.getInternal( 'listeners' ) === undefined ) {

                this.setInternal( 'listeners', {} );

            }

            var listeners = this.getInternal( 'listeners' );

            if ( listeners[ type ] === undefined ) {

                listeners[ type ] = [];

            }

            if ( listeners[ type ].indexOf( listener ) === - 1 ) {

                listeners[ type ].push( listener );

            }

        },

        hasEventListener: function ( type, listener ) {

            if ( this.getInternal( 'listeners' ) === undefined ) return false;

            var listeners = this.getInternal( 'listeners' );

            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

                return true;

            }

            return false;

        },

        removeEventListener: function ( type, listener ) {

            if ( this.getInternal( 'listeners' ) === undefined ) return false;

            var listeners = this.getInternal( 'listeners' );
            var index = listeners[ type ].indexOf( listener );

            if ( index !== - 1 ) {

                listeners[ type ].splice( index, 1 );

            }

        },

        dispatchEvent: function ( event ) {

            if ( this.getInternal( 'listeners' ) === undefined ) return false;

            var listeners = this.getInternal( 'listeners' );
            var listenerArray = listeners[ event.type ];

            if ( listenerArray !== undefined ) {

                event.target = this;

                for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {

                    listenerArray[ i ].call( this, event );

                }

            }

        }

    };

    if ( typeof EventDispatcher === 'function' ) {
        var t = {}, p = {};
        for ( var i in EventDispatcher ) t[i] = EventDispatcher[i];
        for ( var i in EventDispatcher.prototype ) try { p[i] = EventDispatcher.prototype[i] } catch(e) {};
        scope.EventDispatcher = EventDispatcher.bind( scope );
    } else {
        scope.EventDispatcher = EventDispatcher;
    }
    scope.EventDispatcher.prototype = EventDispatcher.prototype;
    for ( var i in t ) scope.EventDispatcher[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.EventDispatcher.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__EventDispatcher ) {
        for ( var i = 0, il = scope.__EventDispatcher.length; i < il; i ++ ) scope.__EventDispatcher[ i ]( EventDispatcher );
        delete scope.__EventDispatcher;
    }

}) ( NWE );


// src/pathfinder/PathFinder.js

( function ( scope ) {

    /* pathfinder */

    var PathFinder = function ( width, height ) {

        this.width = width || 0;
        this.height = height || 0;

        this.maxDepth = 5;

        //

        this.objects = [];

        this.navMash = [];
        this.blocks = {};

        //

        var limit = 4;
        var depth = 1;
        var block;
        var id = 0;

        for ( var i = 0, il = Math.pow( 4, this.maxDepth ); i < il; i ++ ) {

            if ( id >= limit ) {

                depth ++;
                id = 0;
                limit = Math.pow( 4, depth );

            }

            block = {

                id: id,
                depth: depth,
                neighbours: [],
                value: 0,
                used: 0

            };

            if ( depth === 1 ) {

                block.used = 1;

            }

            this.navMash.push( block );
            this.blocks[ depth + '.' + id ] = block;

            id ++;

        }

    };

    PathFinder.prototype.setSize = function ( width, height ) {

        this.width = width;
        this.height = height;

    };

    PathFinder.prototype.generateNavMash = function () {

        // todo

    };

    PathFinder.prototype.addObject = function ( id, x, y, width, height, rotation, value ) {

        this.objects.push({

            id: id,
            x: x,
            y: y,
            width: width,
            height: height,
            rotation: rotation,
            value: value

        });

        this.generateNavMash();

    };

    PathFinder.prototype.removeObject = function () {

        var tmp = [];

        for ( var i = 0, il = this.objects.length; i < il; i ++ ) {

            if ( this.objects[ i ].id !== id ) {

                tmp.push( this.objects[ i ] );

            }

        }

        this.objects = tmp;

        this.generateNavMash();

    };

    PathFinder.prototype.findPath = function () {

        // todo

    };

    //

    var NavMashBlock = function () {

        // todo

    };

    if ( typeof PathFinder === 'function' ) {
        var t = {}, p = {};
        for ( var i in PathFinder ) t[i] = PathFinder[i];
        for ( var i in PathFinder.prototype ) try { p[i] = PathFinder.prototype[i] } catch(e) {};
        scope.PathFinder = PathFinder.bind( scope );
    } else {
        scope.PathFinder = PathFinder;
    }
    scope.PathFinder.prototype = PathFinder.prototype;
    for ( var i in t ) scope.PathFinder[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.PathFinder.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__PathFinder ) {
        for ( var i = 0, il = scope.__PathFinder.length; i < il; i ++ ) scope.__PathFinder[ i ]( PathFinder );
        delete scope.__PathFinder;
    }

}) ( NWE );


// src/math/Math.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */



    var Math = {

        PI2: window.Math.PI * 2,

        generateUUID: function () {

            // http://www.broofa.com/Tools/Math.uuid.htm
            
            var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
            var uuid = new Array(36);
            var rnd = 0, r;

            return function () {

                for ( var i = 0; i < 36; i ++ ) {

                    if ( i == 8 || i == 13 || i == 18 || i == 23 ) {
                
                        uuid[ i ] = '-';
                
                    } else if ( i == 14 ) {
                
                        uuid[ i ] = '4';
                
                    } else {
                
                        if (rnd <= 0x02) rnd = 0x2000000 + (window.Math.random()*0x1000000)|0;
                        r = rnd & 0xf;
                        rnd = rnd >> 4;
                        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];

                    }
                }
                
                return uuid.join('');

            };

        }(),

        // Clamp value to range <a, b>

        clamp: function ( x, a, b ) {

            return ( x < a ) ? a : ( ( x > b ) ? b : x );

        },

        // Clamp value to range <a, inf)

        clampBottom: function ( x, a ) {

            return x < a ? a : x;

        },

        // Linear mapping from range <a1, a2> to range <b1, b2>

        mapLinear: function ( x, a1, a2, b1, b2 ) {

            return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

        },

        // http://en.wikipedia.org/wiki/Smoothstep

        smoothstep: function ( x, min, max ) {

            if ( x <= min ) return 0;
            if ( x >= max ) return 1;

            x = ( x - min )/( max - min );

            return x*x*(3 - 2*x);

        },

        smootherstep: function ( x, min, max ) {

            if ( x <= min ) return 0;
            if ( x >= max ) return 1;

            x = ( x - min )/( max - min );

            return x*x*x*(x*(x*6 - 15) + 10);

        },

        // Random float from <0, 1> with 16 bits of randomness
        // (standard Math.random() creates repetitive patterns when applied over larger space)

        random16: function () {

            return ( 65280 * window.Math.random() + 255 * window.Math.random() ) / 65535;

        },

        // Random integer from <low, high> interval

        randInt: function ( low, high ) {

            return low + window.Math.floor( window.Math.random() * ( high - low + 1 ) );

        },

        // Random float from <low, high> interval

        randFloat: function ( low, high ) {

            return low + window.Math.random() * ( high - low );

        },

        // Random float from <-range/2, range/2> interval

        randFloatSpread: function ( range ) {

            return range * ( 0.5 - window.Math.random() );

        },

        sign: function ( x ) {

            return ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );

        },

        degToRad: function() {

            var degreeToRadiansFactor = window.Math.PI / 180;

            return function ( degrees ) {

                return degrees * degreeToRadiansFactor;

            };

        }(),

        radToDeg: function() {

            var radianToDegreesFactor = 180 / window.Math.PI;

            return function ( radians ) {

                return radians * radianToDegreesFactor;

            };

        }(),

        isPowerOfTwo: function ( value ) {

            return ( value & ( value - 1 ) ) === 0 && value !== 0;

        }

    };

    scope.Math = Math;
    if ( scope.__Math ) {
        for ( var i = 0, il = scope.__Math.length; i < il; i ++ ) scope.__Math[ i ]( Math );
        delete scope.__Math;
    }

}) ( NWE );


// src/math/Color.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var Color = function ( value ) {

        if ( value !== undefined ) this.set( value );

        return this;

    };

    Color.prototype = {

        constructor: Color,

        r: 1, g: 1, b: 1,

        set: function ( value ) {

            if ( value instanceof Color ) {

                this.copy( value );

            } else if ( typeof value === 'number' ) {

                this.setHex( value );

            } else if ( typeof value === 'string' ) {

                this.setStyle( value );

            }

            return this;

        },

        setHex: function ( hex ) {

            hex = Math.floor( hex );

            this.r = ( hex >> 16 & 255 ) / 255;
            this.g = ( hex >> 8 & 255 ) / 255;
            this.b = ( hex & 255 ) / 255;

            return this;

        },

        setRGB: function ( r, g, b ) {

            this.r = r;
            this.g = g;
            this.b = b;

            return this;

        },

        setHSL: function ( h, s, l ) {

            // h,s,l ranges are in 0.0 - 1.0

            if ( s === 0 ) {

                this.r = this.g = this.b = l;

            } else {

                var hue2rgb = function ( p, q, t ) {

                    if ( t < 0 ) t += 1;
                    if ( t > 1 ) t -= 1;
                    if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
                    if ( t < 1 / 2 ) return q;
                    if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
                    return p;

                };

                var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
                var q = ( 2 * l ) - p;

                this.r = hue2rgb( q, p, h + 1 / 3 );
                this.g = hue2rgb( q, p, h );
                this.b = hue2rgb( q, p, h - 1 / 3 );

            }

            return this;

        },

        setStyle: function ( style ) {

            // rgb(255,0,0)

            if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

                var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

                this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

                return this;

            }

            // rgb(100%,0%,0%)

            if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

                var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

                this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

                return this;

            }

            // #ff0000

            if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

                var color = /^\#([0-9a-f]{6})$/i.exec( style );

                this.setHex( parseInt( color[ 1 ], 16 ) );

                return this;

            }

            // #f00

            if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

                var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

                this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

                return this;

            }

            // red

            if ( /^(\w+)$/i.test( style ) ) {

                this.setHex( ColorKeywords[ style ] );

                return this;

            }


        },

        copy: function ( color ) {

            this.r = color.r;
            this.g = color.g;
            this.b = color.b;

            return this;

        },

        copyGammaToLinear: function ( color ) {

            this.r = color.r * color.r;
            this.g = color.g * color.g;
            this.b = color.b * color.b;

            return this;

        },

        copyLinearToGamma: function ( color ) {

            this.r = Math.sqrt( color.r );
            this.g = Math.sqrt( color.g );
            this.b = Math.sqrt( color.b );

            return this;

        },

        convertGammaToLinear: function () {

            var r = this.r, g = this.g, b = this.b;

            this.r = r * r;
            this.g = g * g;
            this.b = b * b;

            return this;

        },

        convertLinearToGamma: function () {

            this.r = Math.sqrt( this.r );
            this.g = Math.sqrt( this.g );
            this.b = Math.sqrt( this.b );

            return this;

        },

        getHex: function () {

            return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

        },

        getHexString: function () {

            return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

        },

        getHSL: function () {

            var hsl = { h: 0, s: 0, l: 0 };

            return function () {

                // h,s,l ranges are in 0.0 - 1.0

                var r = this.r, g = this.g, b = this.b;

                var max = Math.max( r, g, b );
                var min = Math.min( r, g, b );

                var hue, saturation;
                var lightness = ( min + max ) / 2.0;

                if ( min === max ) {

                    hue = 0;
                    saturation = 0;

                } else {

                    var delta = max - min;

                    saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

                    switch ( max ) {

                        case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
                        case g: hue = ( b - r ) / delta + 2; break;
                        case b: hue = ( r - g ) / delta + 4; break;

                    }

                    hue /= 6;

                }

                hsl.h = hue;
                hsl.s = saturation;
                hsl.l = lightness;

                return hsl;

            };

        }(),

        getStyle: function () {

            return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

        },

        offsetHSL: function ( h, s, l ) {

            var hsl = this.getHSL();

            hsl.h += h; hsl.s += s; hsl.l += l;

            this.setHSL( hsl.h, hsl.s, hsl.l );

            return this;

        },

        add: function ( color ) {

            this.r += color.r;
            this.g += color.g;
            this.b += color.b;

            return this;

        },

        addColors: function ( color1, color2 ) {

            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;

            return this;

        },

        addScalar: function ( s ) {

            this.r += s;
            this.g += s;
            this.b += s;

            return this;

        },

        multiply: function ( color ) {

            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;

            return this;

        },

        multiplyScalar: function ( s ) {

            this.r *= s;
            this.g *= s;
            this.b *= s;

            return this;

        },

        lerp: function ( color, alpha ) {

            this.r += ( color.r - this.r ) * alpha;
            this.g += ( color.g - this.g ) * alpha;
            this.b += ( color.b - this.b ) * alpha;

            return this;

        },

        equals: function ( c ) {

            return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

        },

        fromArray: function ( array ) {

            this.r = array[ 0 ];
            this.g = array[ 1 ];
            this.b = array[ 2 ];

            return this;

        },

        toArray: function () {

            return [ this.r, this.g, this.b ];

        },

        clone: function () {

            return new Color().setRGB( this.r, this.g, this.b );

        }

    };


    if ( typeof Color === 'function' ) {
        var t = {}, p = {};
        for ( var i in Color ) t[i] = Color[i];
        for ( var i in Color.prototype ) try { p[i] = Color.prototype[i] } catch(e) {};
        scope.Color = Color.bind( scope );
    } else {
        scope.Color = Color;
    }
    scope.Color.prototype = Color.prototype;
    for ( var i in t ) scope.Color[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Color.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Color ) {
        for ( var i = 0, il = scope.__Color.length; i < il; i ++ ) scope.__Color[ i ]( Color );
        delete scope.__Color;
    }

}) ( NWE );


// src/math/ColorKeywords.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */



    var ColorKeywords = { "aliceblue": 0xF0F8FF, "antiquewhite": 0xFAEBD7, "aqua": 0x00FFFF, "aquamarine": 0x7FFFD4, "azure": 0xF0FFFF,
    "beige": 0xF5F5DC, "bisque": 0xFFE4C4, "black": 0x000000, "blanchedalmond": 0xFFEBCD, "blue": 0x0000FF, "blueviolet": 0x8A2BE2,
    "brown": 0xA52A2A, "burlywood": 0xDEB887, "cadetblue": 0x5F9EA0, "chartreuse": 0x7FFF00, "chocolate": 0xD2691E, "coral": 0xFF7F50,
    "cornflowerblue": 0x6495ED, "cornsilk": 0xFFF8DC, "crimson": 0xDC143C, "cyan": 0x00FFFF, "darkblue": 0x00008B, "darkcyan": 0x008B8B,
    "darkgoldenrod": 0xB8860B, "darkgray": 0xA9A9A9, "darkgreen": 0x006400, "darkgrey": 0xA9A9A9, "darkkhaki": 0xBDB76B, "darkmagenta": 0x8B008B,
    "darkolivegreen": 0x556B2F, "darkorange": 0xFF8C00, "darkorchid": 0x9932CC, "darkred": 0x8B0000, "darksalmon": 0xE9967A, "darkseagreen": 0x8FBC8F,
    "darkslateblue": 0x483D8B, "darkslategray": 0x2F4F4F, "darkslategrey": 0x2F4F4F, "darkturquoise": 0x00CED1, "darkviolet": 0x9400D3,
    "deeppink": 0xFF1493, "deepskyblue": 0x00BFFF, "dimgray": 0x696969, "dimgrey": 0x696969, "dodgerblue": 0x1E90FF, "firebrick": 0xB22222,
    "floralwhite": 0xFFFAF0, "forestgreen": 0x228B22, "fuchsia": 0xFF00FF, "gainsboro": 0xDCDCDC, "ghostwhite": 0xF8F8FF, "gold": 0xFFD700,
    "goldenrod": 0xDAA520, "gray": 0x808080, "green": 0x008000, "greenyellow": 0xADFF2F, "grey": 0x808080, "honeydew": 0xF0FFF0, "hotpink": 0xFF69B4,
    "indianred": 0xCD5C5C, "indigo": 0x4B0082, "ivory": 0xFFFFF0, "khaki": 0xF0E68C, "lavender": 0xE6E6FA, "lavenderblush": 0xFFF0F5, "lawngreen": 0x7CFC00,
    "lemonchiffon": 0xFFFACD, "lightblue": 0xADD8E6, "lightcoral": 0xF08080, "lightcyan": 0xE0FFFF, "lightgoldenrodyellow": 0xFAFAD2, "lightgray": 0xD3D3D3,
    "lightgreen": 0x90EE90, "lightgrey": 0xD3D3D3, "lightpink": 0xFFB6C1, "lightsalmon": 0xFFA07A, "lightseagreen": 0x20B2AA, "lightskyblue": 0x87CEFA,
    "lightslategray": 0x778899, "lightslategrey": 0x778899, "lightsteelblue": 0xB0C4DE, "lightyellow": 0xFFFFE0, "lime": 0x00FF00, "limegreen": 0x32CD32,
    "linen": 0xFAF0E6, "magenta": 0xFF00FF, "maroon": 0x800000, "mediumaquamarine": 0x66CDAA, "mediumblue": 0x0000CD, "mediumorchid": 0xBA55D3,
    "mediumpurple": 0x9370DB, "mediumseagreen": 0x3CB371, "mediumslateblue": 0x7B68EE, "mediumspringgreen": 0x00FA9A, "mediumturquoise": 0x48D1CC,
    "mediumvioletred": 0xC71585, "midnightblue": 0x191970, "mintcream": 0xF5FFFA, "mistyrose": 0xFFE4E1, "moccasin": 0xFFE4B5, "navajowhite": 0xFFDEAD,
    "navy": 0x000080, "oldlace": 0xFDF5E6, "olive": 0x808000, "olivedrab": 0x6B8E23, "orange": 0xFFA500, "orangered": 0xFF4500, "orchid": 0xDA70D6,
    "palegoldenrod": 0xEEE8AA, "palegreen": 0x98FB98, "paleturquoise": 0xAFEEEE, "palevioletred": 0xDB7093, "papayawhip": 0xFFEFD5, "peachpuff": 0xFFDAB9,
    "peru": 0xCD853F, "pink": 0xFFC0CB, "plum": 0xDDA0DD, "powderblue": 0xB0E0E6, "purple": 0x800080, "red": 0xFF0000, "rosybrown": 0xBC8F8F,
    "royalblue": 0x4169E1, "saddlebrown": 0x8B4513, "salmon": 0xFA8072, "sandybrown": 0xF4A460, "seagreen": 0x2E8B57, "seashell": 0xFFF5EE,
    "sienna": 0xA0522D, "silver": 0xC0C0C0, "skyblue": 0x87CEEB, "slateblue": 0x6A5ACD, "slategray": 0x708090, "slategrey": 0x708090, "snow": 0xFFFAFA,
    "springgreen": 0x00FF7F, "steelblue": 0x4682B4, "tan": 0xD2B48C, "teal": 0x008080, "thistle": 0xD8BFD8, "tomato": 0xFF6347, "turquoise": 0x40E0D0,
    "violet": 0xEE82EE, "wheat": 0xF5DEB3, "white": 0xFFFFFF, "whitesmoke": 0xF5F5F5, "yellow": 0xFFFF00, "yellowgreen": 0x9ACD32 };

    scope.ColorKeywords = ColorKeywords;
    if ( scope.__ColorKeywords ) {
        for ( var i = 0, il = scope.__ColorKeywords.length; i < il; i ++ ) scope.__ColorKeywords[ i ]( ColorKeywords );
        delete scope.__ColorKeywords;
    }

}) ( NWE );


// src/math/Quaternion.js

( function ( scope ) {

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://exocortex.com
     */

    var Euler = NWE.Euler;
    if ( !Euler ) { NWE.__Euler = (NWE.__Euler || []); NWE.__Euler.push( function ( obj ) { Euler = obj; } ); }


    var Quaternion = function ( x, y, z, w ) {

        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._w = ( w !== undefined ) ? w : 1;

    };

    Quaternion.prototype = {

        constructor: Quaternion,

        _x: 0,_y: 0, _z: 0, _w: 0,

        _euler: undefined,

        _updateEuler: function ( callback ) {

            if ( this._euler !== undefined ) {

                this._euler.setFromQuaternion( this, undefined, false );

            }

        },

        get x () {

            return this._x;

        },

        set x ( value ) {

            this._x = value;
            this._updateEuler();

        },

        get y () {

            return this._y;

        },

        set y ( value ) {

            this._y = value;
            this._updateEuler();

        },

        get z () {

            return this._z;

        },

        set z ( value ) {

            this._z = value;
            this._updateEuler();

        },

        get w () {

            return this._w;

        },

        set w ( value ) {

            this._w = value;
            this._updateEuler();

        },

        set: function ( x, y, z, w ) {

            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;

            this._updateEuler();

            return this;

        },

        copy: function ( quaternion ) {

            this._x = quaternion._x;
            this._y = quaternion._y;
            this._z = quaternion._z;
            this._w = quaternion._w;

            this._updateEuler();

            return this;

        },

        setFromEuler: function ( euler, update ) {

            if ( euler instanceof Euler === false ) {

                throw new Error( 'ERROR: Quaternion\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order. Please update your code.' );
            }

            // http://www.mathworks.com/matlabcentral/fileexchange/
            //  20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //  content/SpinCalc.m

            var c1 = Math.cos( euler._x / 2 );
            var c2 = Math.cos( euler._y / 2 );
            var c3 = Math.cos( euler._z / 2 );
            var s1 = Math.sin( euler._x / 2 );
            var s2 = Math.sin( euler._y / 2 );
            var s3 = Math.sin( euler._z / 2 );

            if ( euler.order === 'XYZ' ) {

                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;

            } else if ( euler.order === 'YXZ' ) {

                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;

            } else if ( euler.order === 'ZXY' ) {

                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;

            } else if ( euler.order === 'ZYX' ) {

                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;

            } else if ( euler.order === 'YZX' ) {

                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;

            } else if ( euler.order === 'XZY' ) {

                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;

            }

            if ( update !== false ) this._updateEuler();

            return this;

        },

        setFromAxisAngle: function ( axis, angle ) {

            // from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
            // axis have to be normalized

            var halfAngle = angle / 2, s = Math.sin( halfAngle );

            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = Math.cos( halfAngle );

            this._updateEuler();

            return this;

        },

        setFromRotationMatrix: function ( m ) {

            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

            var te = m.elements,

                m11 = te[0], m12 = te[4], m13 = te[8],
                m21 = te[1], m22 = te[5], m23 = te[9],
                m31 = te[2], m32 = te[6], m33 = te[10],

                trace = m11 + m22 + m33,
                s;

            if ( trace > 0 ) {

                s = 0.5 / Math.sqrt( trace + 1.0 );

                this._w = 0.25 / s;
                this._x = ( m32 - m23 ) * s;
                this._y = ( m13 - m31 ) * s;
                this._z = ( m21 - m12 ) * s;

            } else if ( m11 > m22 && m11 > m33 ) {

                s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

                this._w = (m32 - m23 ) / s;
                this._x = 0.25 * s;
                this._y = (m12 + m21 ) / s;
                this._z = (m13 + m31 ) / s;

            } else if ( m22 > m33 ) {

                s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

                this._w = (m13 - m31 ) / s;
                this._x = (m12 + m21 ) / s;
                this._y = 0.25 * s;
                this._z = (m23 + m32 ) / s;

            } else {

                s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

                this._w = ( m21 - m12 ) / s;
                this._x = ( m13 + m31 ) / s;
                this._y = ( m23 + m32 ) / s;
                this._z = 0.25 * s;

            }

            this._updateEuler();

            return this;

        },

        inverse: function () {

            this.conjugate().normalize();

            return this;

        },

        conjugate: function () {

            this._x *= -1;
            this._y *= -1;
            this._z *= -1;

            this._updateEuler();

            return this;

        },

        lengthSq: function () {

            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

        },

        length: function () {

            return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

        },

        normalize: function () {

            var l = this.length();

            if ( l === 0 ) {

                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;

            } else {

                l = 1 / l;

                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;

            }

            return this;

        },

        multiply: function ( q, p ) {

            return this.multiplyQuaternions( this, q );

        },


        multiplyQuaternions: function ( a, b ) {

            // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

            var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
            var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

            this._updateEuler();

            return this;

        },

        slerp: function ( qb, t ) {

            var x = this._x, y = this._y, z = this._z, w = this._w;

            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

            var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

            if ( cosHalfTheta < 0 ) {

                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;

                cosHalfTheta = -cosHalfTheta;

            } else {

                this.copy( qb );

            }

            if ( cosHalfTheta >= 1.0 ) {

                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;

                return this;

            }

            var halfTheta = Math.acos( cosHalfTheta );
            var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

            if ( Math.abs( sinHalfTheta ) < 0.001 ) {

                this._w = 0.5 * ( w + this._w );
                this._x = 0.5 * ( x + this._x );
                this._y = 0.5 * ( y + this._y );
                this._z = 0.5 * ( z + this._z );

                return this;

            }

            var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
            ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

            this._w = ( w * ratioA + this._w * ratioB );
            this._x = ( x * ratioA + this._x * ratioB );
            this._y = ( y * ratioA + this._y * ratioB );
            this._z = ( z * ratioA + this._z * ratioB );

            this._updateEuler();

            return this;

        },

        equals: function ( quaternion ) {

            return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

        },

        fromArray: function ( array ) {

            this._x = array[ 0 ];
            this._y = array[ 1 ];
            this._z = array[ 2 ];
            this._w = array[ 3 ];

            this._updateEuler();

            return this;

        },

        toArray: function () {

            return [ this._x, this._y, this._z, this._w ];

        },

        clone: function () {

            return new Quaternion( this._x, this._y, this._z, this._w );

        }

    };

    Quaternion.slerp = function ( qa, qb, qm, t ) {

        return qm.copy( qa ).slerp( qb, t );

    }

    if ( typeof Quaternion === 'function' ) {
        var t = {}, p = {};
        for ( var i in Quaternion ) t[i] = Quaternion[i];
        for ( var i in Quaternion.prototype ) try { p[i] = Quaternion.prototype[i] } catch(e) {};
        scope.Quaternion = Quaternion.bind( scope );
    } else {
        scope.Quaternion = Quaternion;
    }
    scope.Quaternion.prototype = Quaternion.prototype;
    for ( var i in t ) scope.Quaternion[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Quaternion.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Quaternion ) {
        for ( var i = 0, il = scope.__Quaternion.length; i < il; i ++ ) scope.__Quaternion[ i ]( Quaternion );
        delete scope.__Quaternion;
    }

}) ( NWE );


// src/math/Vec2.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author philogb / http://blog.thejit.org/
     * @author egraether / http://egraether.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author ohmed
     */

    var Vec2 = function ( x, y, onUpdate ) {

        if ( !! onUpdate ) {

            x = x || 0;
            y = y || 0;

            this.__defineGetter__('x', function () {
                return x;
            });

            this.__defineGetter__('y', function () {
                return y;
            });

            this.__defineSetter__('x', function ( value ) {
                this.onUpdate( x - value, 0 );
                x = value;
            });

            this.__defineSetter__('y', function ( value ) {
                this.onUpdate( 0, y - value );
                y = value;
            });

            this.onUpdate = ( typeof onUpdate === 'function' ) ? onUpdate : function () {};

        } else {

            if ( arguments.length === 2 ) {

                this.x = x || 0;
                this.y = y || 0;

            } else {

                this.x = this.y = x || 0;

            }

        }

    };

    Vec2.prototype = {

        constructor: Vec2,

        set: function ( x, y ) {

            if ( arguments.length === 2 ) {

                this.x = x;
                this.y = y;

            } else {

                this.x = this.y = x;

            }

            return this;

        },

        setX: function ( x ) {

            this.x = x;

            return this;

        },

        setY: function ( y ) {

            this.y = y;

            return this;

        },


        setComponent: function ( index, value ) {

            switch ( index ) {

                case 0: this.x = value; break;
                case 1: this.y = value; break;
                default: throw new Error( "index is out of range: " + index );

            }

        },

        getComponent: function ( index ) {

            switch ( index ) {

                case 0: return this.x;
                case 1: return this.y;
                default: throw new Error( "index is out of range: " + index );

            }

        },

        copy: function ( v ) {

            this.x = v.x;
            this.y = v.y;

            return this;

        },

        add: function ( v ) {

            this.x += v.x;
            this.y += v.y;

            return this;

        },

        addVectors: function ( a, b ) {

            this.x = a.x + b.x;
            this.y = a.y + b.y;

            return this;

        },

        addScalar: function ( s ) {

            this.x += s;
            this.y += s;

            return this;

        },

        sub: function ( v ) {

            this.x -= v.x;
            this.y -= v.y;

            return this;

        },

        subVectors: function ( a, b ) {

            this.x = a.x - b.x;
            this.y = a.y - b.y;

            return this;

        },

        multiplyScalar: function ( s ) {

            this.x *= s;
            this.y *= s;

            return this;

        },

        divideScalar: function ( scalar ) {

            if ( scalar !== 0 ) {

                var invScalar = 1 / scalar;

                this.x *= invScalar;
                this.y *= invScalar;

            } else {

                this.x = 0;
                this.y = 0;

            }

            return this;

        },

        min: function ( v ) {

            if ( this.x > v.x ) {

                this.x = v.x;

            }

            if ( this.y > v.y ) {

                this.y = v.y;

            }

            return this;

        },

        max: function ( v ) {

            if ( this.x < v.x ) {

                this.x = v.x;

            }

            if ( this.y < v.y ) {

                this.y = v.y;

            }

            return this;

        },

        clamp: function ( min, max ) {

            // This function assumes min < max, if this assumption isn't true it will not operate correctly

            if ( this.x < min.x ) {

                this.x = min.x;

            } else if ( this.x > max.x ) {

                this.x = max.x;

            }

            if ( this.y < min.y ) {

                this.y = min.y;

            } else if ( this.y > max.y ) {

                this.y = max.y;

            }

            return this;

        },

        negate: function() {

            return this.multiplyScalar( - 1 );

        },

        dot: function ( v ) {

            return this.x * v.x + this.y * v.y;

        },

        lengthSq: function () {

            return this.x * this.x + this.y * this.y;

        },

        length: function () {

            return Math.sqrt( this.x * this.x + this.y * this.y );

        },

        normalize: function () {

            return this.divideScalar( this.length() );

        },

        distanceTo: function ( v ) {

            return Math.sqrt( this.distanceToSquared( v ) );

        },

        distanceToSquared: function ( v ) {

            var dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;

        },

        setLength: function ( l ) {

            var oldLength = this.length();

            if ( oldLength !== 0 && l !== oldLength ) {

                this.multiplyScalar( l / oldLength );
            }

            return this;

        },

        lerp: function ( v, alpha ) {

            this.x += ( v.x - this.x ) * alpha;
            this.y += ( v.y - this.y ) * alpha;

            return this;

        },

        equals: function( v ) {

            return ( ( v.x === this.x ) && ( v.y === this.y ) );

        },

        fromArray: function ( array ) {

            this.x = array[ 0 ];
            this.y = array[ 1 ];

            return this;

        },

        toArray: function () {

            return [ this.x, this.y ];

        },

        clone: function () {

            return new Vec2( this.x, this.y );

        }

    };

    if ( typeof Vec2 === 'function' ) {
        var t = {}, p = {};
        for ( var i in Vec2 ) t[i] = Vec2[i];
        for ( var i in Vec2.prototype ) try { p[i] = Vec2.prototype[i] } catch(e) {};
        scope.Vec2 = Vec2.bind( scope );
    } else {
        scope.Vec2 = Vec2;
    }
    scope.Vec2.prototype = Vec2.prototype;
    for ( var i in t ) scope.Vec2[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Vec2.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Vec2 ) {
        for ( var i = 0, il = scope.__Vec2.length; i < il; i ++ ) scope.__Vec2[ i ]( Vec2 );
        delete scope.__Vec2;
    }

}) ( NWE );


// src/math/Vec3.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author *kile / http://kile.stravaganza.org/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author ohmed
     */

    var Quaternion = NWE.Quaternion;
    if ( !Quaternion ) { NWE.__Quaternion = (NWE.__Quaternion || []); NWE.__Quaternion.push( function ( obj ) { Quaternion = obj; } ); }

    var Euler = NWE.Euler;
    if ( !Euler ) { NWE.__Euler = (NWE.__Euler || []); NWE.__Euler.push( function ( obj ) { Euler = obj; } ); }


    var Vec3 = function ( x, y, z, onUpdate ) {

        if ( !! onUpdate ) {

            x = x || 0;
            y = y || 0;
            z = z || 0;

            this.__defineGetter__('x', function () {
                return x;
            });

            this.__defineGetter__('y', function () {
                return y;
            });

            this.__defineGetter__('z', function () {
                return z;
            });

            this.__defineSetter__('x', function ( value ) {
                var dx = value - x;
                x = value;
                this.onUpdate( dx, 0, 0 );
            });

            this.__defineSetter__('y', function ( value ) {
                var dy = value - y;
                y = value;
                this.onUpdate( 0, dy, 0 );
            });

            this.__defineSetter__('z', function ( value ) {
                var dz = value - z;
                z = value;
                this.onUpdate( 0, 0, dz );
            });

            this.onUpdate = ( typeof onUpdate === 'function' ) ? onUpdate : function () {};

        } else {

            if ( arguments.length === 3 ) {

                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;

            } else {

                this.x = this.y = this.z = x || 0;

            }

        }

    };

    Vec3.prototype = {

        constructor: Vec3,

        set: function ( x, y, z ) {

            if ( arguments.length === 3 ) {

                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;

            } else {

                this.x = this.y = this.z = x || 0;

            }

            return this;

        },

        setX: function ( x ) {

            this.x = x;

            return this;

        },

        setY: function ( y ) {

            this.y = y;

            return this;

        },

        setZ: function ( z ) {

            this.z = z;

            return this;

        },

        setComponent: function ( index, value ) {

            switch ( index ) {

                case 0: this.x = value; break;
                case 1: this.y = value; break;
                case 2: this.z = value; break;
                default: throw new Error( "index is out of range: " + index );

            }

        },

        getComponent: function ( index ) {

            switch ( index ) {

                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                default: throw new Error( "index is out of range: " + index );

            }

        },

        copy: function ( v ) {

            this.x = v.x;
            this.y = v.y;
            this.z = v.z;

            return this;

        },

        add: function ( v ) {

            this.x += v.x;
            this.y += v.y;
            this.z += v.z;

            return this;

        },

        addScalar: function ( s ) {

            this.x += s;
            this.y += s;
            this.z += s;

            return this;

        },

        addVectors: function ( a, b ) {

            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;

            return this;

        },

        sub: function ( v ) {

            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;

            return this;

        },

        subVectors: function ( a, b ) {

            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;

            return this;

        },

        multiply: function ( v ) {

            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;

            return this;

        },

        multiplyScalar: function ( scalar ) {

            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;

            return this;

        },

        multiplyVectors: function ( a, b ) {

            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;

            return this;

        },

        applyMatrix3: function ( m ) {

            var x = this.x;
            var y = this.y;
            var z = this.z;

            var e = m.elements;

            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;

            return this;

        },

        applyMatrix4: function ( m ) {

            // input: Matrix4 affine matrix

            var x = this.x, y = this.y, z = this.z;

            var e = m.elements;

            this.x = e[0] * x + e[4] * y + e[8]  * z + e[12];
            this.y = e[1] * x + e[5] * y + e[9]  * z + e[13];
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14];

            return this;

        },

        applyProjection: function ( m ) {

            // input: Matrix4 projection matrix

            var x = this.x, y = this.y, z = this.z;

            var e = m.elements;
            var d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide

            this.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;
            this.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;
            this.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;

            return this;

        },

        applyQuaternion: function ( q ) {

            var x = this.x;
            var y = this.y;
            var z = this.z;

            var qx = q.x;
            var qy = q.y;
            var qz = q.z;
            var qw = q.w;

            // calculate quat * vector

            var ix =  qw * x + qy * z - qz * y;
            var iy =  qw * y + qz * x - qx * z;
            var iz =  qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;

            // calculate result * inverse quat

            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

            return this;

        },

        transformDirection: function ( m ) {

            // input: Matrix4 affine matrix
            // vector interpreted as a direction

            var x = this.x, y = this.y, z = this.z;

            var e = m.elements;

            this.x = e[0] * x + e[4] * y + e[8]  * z;
            this.y = e[1] * x + e[5] * y + e[9]  * z;
            this.z = e[2] * x + e[6] * y + e[10] * z;

            this.normalize();

            return this;

        },

        divide: function ( v ) {

            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;

            return this;

        },

        divideScalar: function ( scalar ) {

            if ( scalar !== 0 ) {

                var invScalar = 1 / scalar;

                this.x *= invScalar;
                this.y *= invScalar;
                this.z *= invScalar;

            } else {

                this.x = 0;
                this.y = 0;
                this.z = 0;

            }

            return this;

        },

        min: function ( v ) {

            if ( this.x > v.x ) {

                this.x = v.x;

            }

            if ( this.y > v.y ) {

                this.y = v.y;

            }

            if ( this.z > v.z ) {

                this.z = v.z;

            }

            return this;

        },

        max: function ( v ) {

            if ( this.x < v.x ) {

                this.x = v.x;

            }

            if ( this.y < v.y ) {

                this.y = v.y;

            }

            if ( this.z < v.z ) {

                this.z = v.z;

            }

            return this;

        },

        clamp: function ( min, max ) {

            // This function assumes min < max, if this assumption isn't true it will not operate correctly

            if ( this.x < min.x ) {

                this.x = min.x;

            } else if ( this.x > max.x ) {

                this.x = max.x;

            }

            if ( this.y < min.y ) {

                this.y = min.y;

            } else if ( this.y > max.y ) {

                this.y = max.y;

            }

            if ( this.z < min.z ) {

                this.z = min.z;

            } else if ( this.z > max.z ) {

                this.z = max.z;

            }

            return this;

        },

        negate: function () {

            return this.multiplyScalar( - 1 );

        },

        dot: function ( v ) {

            return this.x * v.x + this.y * v.y + this.z * v.z;

        },

        lengthSq: function () {

            return this.x * this.x + this.y * this.y + this.z * this.z;

        },

        length: function () {

            return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

        },

        lengthManhattan: function () {

            return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

        },

        normalize: function () {

            return this.divideScalar( this.length() );

        },

        setLength: function ( l ) {

            var oldLength = this.length();

            if ( oldLength !== 0 && l !== oldLength  ) {

                this.multiplyScalar( l / oldLength );
            }

            return this;

        },

        lerp: function ( v, alpha ) {

            this.x += ( v.x - this.x ) * alpha;
            this.y += ( v.y - this.y ) * alpha;
            this.z += ( v.z - this.z ) * alpha;

            return this;

        },

        cross: function ( v ) {

            var x = this.x, y = this.y, z = this.z;

            this.x = y * v.z - z * v.y;
            this.y = z * v.x - x * v.z;
            this.z = x * v.y - y * v.x;

            return this;

        },

        crossVectors: function ( a, b ) {

            var ax = a.x, ay = a.y, az = a.z;
            var bx = b.x, by = b.y, bz = b.z;

            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;

            return this;

        },

        angleTo: function ( v ) {

            var theta = this.dot( v ) / ( this.length() * v.length() );

            // clamp, to handle numerical problems

            return Math.acos( NWE.Math.clamp( theta, -1, 1 ) );

        },

        distanceTo: function ( v ) {

            return Math.sqrt( this.distanceToSquared( v ) );

        },

        distanceToSquared: function ( v ) {

            var dx = this.x - v.x;
            var dy = this.y - v.y;
            var dz = this.z - v.z;

            return dx * dx + dy * dy + dz * dz;

        },

        getPositionFromMatrix: function ( m ) {

            this.x = m.elements[12];
            this.y = m.elements[13];
            this.z = m.elements[14];

            return this;

        },

        getScaleFromMatrix: function ( m ) {

            var sx = this.set( m.elements[0], m.elements[1], m.elements[2] ).length();
            var sy = this.set( m.elements[4], m.elements[5], m.elements[6] ).length();
            var sz = this.set( m.elements[8], m.elements[9], m.elements[10] ).length();

            this.x = sx;
            this.y = sy;
            this.z = sz;

            return this;
        },

        getColumnFromMatrix: function ( index, matrix ) {

            var offset = index * 4;

            var me = matrix.elements;

            this.x = me[ offset ];
            this.y = me[ offset + 1 ];
            this.z = me[ offset + 2 ];

            return this;

        },

        equals: function ( v ) {

            return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

        },

        fromArray: function ( array ) {

            this.x = array[ 0 ];
            this.y = array[ 1 ];
            this.z = array[ 2 ];

            return this;

        },

        toArray: function () {

            return [ this.x, this.y, this.z ];

        },

        clone: function () {

            return new Vec3( this.x, this.y, this.z );

        },

        applyAxisAngle: function () {

            var quaternion = new Quaternion();

            return function ( axis, angle ) {

                this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

                return this;

            };

        }(),

        projectOnVector: function () {

            var v1;

            return function ( vector ) {

                if ( v1 === undefined ) v1 = new Vec3();

                v1.copy( vector ).normalize();
                var d = this.dot( v1 );
                return this.copy( v1 ).multiplyScalar( d );

            };

        }(),

        projectOnPlane: function () {

            var v1;

            return function ( planeNormal ) {

                if ( v1 === undefined ) v1 = new Vec3();

                v1.copy( this ).projectOnVector( planeNormal );

                return this.sub( v1 );

            };

        }(),

        reflect: function () {

            var v1;

            return function ( normal ) {

                if ( v1 === undefined ) v1 = new Vec3();

                return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

            };

        }(),

        setFromMatrixPosition: function ( m ) {

            this.x = m.elements[ 12 ];
            this.y = m.elements[ 13 ];
            this.z = m.elements[ 14 ];

            return this;

        },

        setFromMatrixScale: function ( m ) {

            var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
            var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
            var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

            this.x = sx;
            this.y = sy;
            this.z = sz;

            return this;

        }

    };

    if ( typeof Vec3 === 'function' ) {
        var t = {}, p = {};
        for ( var i in Vec3 ) t[i] = Vec3[i];
        for ( var i in Vec3.prototype ) try { p[i] = Vec3.prototype[i] } catch(e) {};
        scope.Vec3 = Vec3.bind( scope );
    } else {
        scope.Vec3 = Vec3;
    }
    scope.Vec3.prototype = Vec3.prototype;
    for ( var i in t ) scope.Vec3[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Vec3.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Vec3 ) {
        for ( var i = 0, il = scope.__Vec3.length; i < il; i ++ ) scope.__Vec3[ i ]( Vec3 );
        delete scope.__Vec3;
    }

}) ( NWE );


// src/math/Vec4.js

( function ( scope ) {

    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author ohmed
     */

    var Vec4 = function ( x, y, z, w, onUpdate ) {

        if ( !! onUpdate ) {

            x = x || 0;
            y = y || 0;
            z = z || 0;

            w = ( w !== undefined ) ? w : 1;

            this.__defineGetter__('x', function () {
                return x;
            });

            this.__defineGetter__('y', function () {
                return y;
            });

            this.__defineGetter__('z', function () {
                return z;
            });

            this.__defineGetter__('w', function () {
                return w;
            });

            this.__defineSetter__('x', function ( value ) {
                this.onUpdate( x - value, 0, 0, 0 );
                x = value;
            });

            this.__defineSetter__('y', function ( value ) {
                this.onUpdate( 0, y - value, 0, 0 );
                y = value;
            });

            this.__defineSetter__('z', function ( value ) {
                this.onUpdate( 0, 0, z - value, 0 );
                z = value;
            });

            this.__defineSetter__('w', function ( value ) {
                this.onUpdate( 0, 0, 0, w - value );
                w = value;
            });

            this.onUpdate = ( typeof onUpdate === 'function' ) ? onUpdate : function () {};

        } else {

            if ( arguments.length === 4 ) {

                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;

            } else {

                this.x = this.y = this.z = x || 0;

            }

            this.w = ( w !== undefined ) ? w : 1;

        }

    };

    Vec4.prototype = {

        constructor: Vec4,

        set: function ( x, y, z, w ) {

            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;

            return this;

        },

        setX: function ( x ) {

            this.x = x;

            return this;

        },

        setY: function ( y ) {

            this.y = y;

            return this;

        },

        setZ: function ( z ) {

            this.z = z;

            return this;

        },

        setW: function ( w ) {

            this.w = w;

            return this;

        },

        setComponent: function ( index, value ) {

            switch ( index ) {

                case 0: this.x = value; break;
                case 1: this.y = value; break;
                case 2: this.z = value; break;
                case 3: this.w = value; break;
                default: throw new Error( "index is out of range: " + index );

            }

        },

        getComponent: function ( index ) {

            switch ( index ) {

                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                case 3: return this.w;
                default: throw new Error( "index is out of range: " + index );

            }

        },

        copy: function ( v ) {

            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = ( v.w !== undefined ) ? v.w : 1;

            return this;

        },

        add: function ( v ) {

            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;

            return this;

        },

        addScalar: function ( s ) {

            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;

            return this;

        },

        addVectors: function ( a, b ) {

            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;

            return this;

        },

        sub: function ( v ) {

            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;

            return this;

        },

        subVectors: function ( a, b ) {

            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;

            return this;

        },

        multiplyScalar: function ( scalar ) {

            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;

            return this;

        },

        applyMatrix4: function ( m ) {

            var x = this.x;
            var y = this.y;
            var z = this.z;
            var w = this.w;

            var e = m.elements;

            this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

            return this;

        },

        divideScalar: function ( scalar ) {

            if ( scalar !== 0 ) {

                var invScalar = 1 / scalar;

                this.x *= invScalar;
                this.y *= invScalar;
                this.z *= invScalar;
                this.w *= invScalar;

            } else {

                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 1;

            }

            return this;

        },

        setAxisAngleFromQuaternion: function ( q ) {

            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

            // q is assumed to be normalized

            this.w = 2 * Math.acos( q.w );

            var s = Math.sqrt( 1 - q.w * q.w );

            if ( s < 0.0001 ) {

                this.x = 1;
                this.y = 0;
                this.z = 0;

            } else {

                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;

            }

            return this;

        },

        setAxisAngleFromRotationMatrix: function ( m ) {

            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

            var angle, x, y, z,     // variables for result
                epsilon = 0.01,     // margin to allow for rounding errors
                epsilon2 = 0.1,     // margin to distinguish between 0 and 180 degrees

                te = m.elements,

                m11 = te[0], m12 = te[4], m13 = te[8],
                m21 = te[1], m22 = te[5], m23 = te[9],
                m31 = te[2], m32 = te[6], m33 = te[10];

            if ( ( Math.abs( m12 - m21 ) < epsilon )
              && ( Math.abs( m13 - m31 ) < epsilon )
              && ( Math.abs( m23 - m32 ) < epsilon ) ) {

                // singularity found
                // first check for identity matrix which must have +1 for all terms
                // in leading diagonal and zero in other terms

                if ( ( Math.abs( m12 + m21 ) < epsilon2 )
                  && ( Math.abs( m13 + m31 ) < epsilon2 )
                  && ( Math.abs( m23 + m32 ) < epsilon2 )
                  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

                    // this singularity is identity matrix so angle = 0

                    this.set( 1, 0, 0, 0 );

                    return this; // zero angle, arbitrary axis

                }

                // otherwise this singularity is angle = 180

                angle = Math.PI;

                var xx = ( m11 + 1 ) / 2;
                var yy = ( m22 + 1 ) / 2;
                var zz = ( m33 + 1 ) / 2;
                var xy = ( m12 + m21 ) / 4;
                var xz = ( m13 + m31 ) / 4;
                var yz = ( m23 + m32 ) / 4;

                if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

                    if ( xx < epsilon ) {

                        x = 0;
                        y = 0.707106781;
                        z = 0.707106781;

                    } else {

                        x = Math.sqrt( xx );
                        y = xy / x;
                        z = xz / x;

                    }

                } else if ( yy > zz ) { // m22 is the largest diagonal term

                    if ( yy < epsilon ) {

                        x = 0.707106781;
                        y = 0;
                        z = 0.707106781;

                    } else {

                        y = Math.sqrt( yy );
                        x = xy / y;
                        z = yz / y;

                    }

                } else { // m33 is the largest diagonal term so base result on this

                    if ( zz < epsilon ) {

                        x = 0.707106781;
                        y = 0.707106781;
                        z = 0;

                    } else {

                        z = Math.sqrt( zz );
                        x = xz / z;
                        y = yz / z;

                    }

                }

                this.set( x, y, z, angle );

                return this; // return 180 deg rotation

            }

            // as we have reached here there are no singularities so we can handle normally

            var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
                             + ( m13 - m31 ) * ( m13 - m31 )
                             + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

            if ( Math.abs( s ) < 0.001 ) s = 1;

            // prevent divide by zero, should not happen if matrix is orthogonal and should be
            // caught by singularity test above, but I've left it in just in case

            this.x = ( m32 - m23 ) / s;
            this.y = ( m13 - m31 ) / s;
            this.z = ( m21 - m12 ) / s;
            this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

            return this;

        },

        min: function ( v ) {

            if ( this.x > v.x ) {

                this.x = v.x;

            }

            if ( this.y > v.y ) {

                this.y = v.y;

            }

            if ( this.z > v.z ) {

                this.z = v.z;

            }

            if ( this.w > v.w ) {

                this.w = v.w;

            }

            return this;

        },

        max: function ( v ) {

            if ( this.x < v.x ) {

                this.x = v.x;

            }

            if ( this.y < v.y ) {

                this.y = v.y;

            }

            if ( this.z < v.z ) {

                this.z = v.z;

            }

            if ( this.w < v.w ) {

                this.w = v.w;

            }

            return this;

        },

        clamp: function ( min, max ) {

            // This function assumes min < max, if this assumption isn't true it will not operate correctly

            if ( this.x < min.x ) {

                this.x = min.x;

            } else if ( this.x > max.x ) {

                this.x = max.x;

            }

            if ( this.y < min.y ) {

                this.y = min.y;

            } else if ( this.y > max.y ) {

                this.y = max.y;

            }

            if ( this.z < min.z ) {

                this.z = min.z;

            } else if ( this.z > max.z ) {

                this.z = max.z;

            }

            if ( this.w < min.w ) {

                this.w = min.w;

            } else if ( this.w > max.w ) {

                this.w = max.w;

            }

            return this;

        },

        negate: function() {

            return this.multiplyScalar( -1 );

        },

        dot: function ( v ) {

            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

        },

        lengthSq: function () {

            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

        },

        length: function () {

            return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

        },

        lengthManhattan: function () {

            return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

        },

        normalize: function () {

            return this.divideScalar( this.length() );

        },

        setLength: function ( l ) {

            var oldLength = this.length();

            if ( oldLength !== 0 && l !== oldLength ) {

                this.multiplyScalar( l / oldLength );

            }

            return this;

        },

        lerp: function ( v, alpha ) {

            this.x += ( v.x - this.x ) * alpha;
            this.y += ( v.y - this.y ) * alpha;
            this.z += ( v.z - this.z ) * alpha;
            this.w += ( v.w - this.w ) * alpha;

            return this;

        },

        equals: function ( v ) {

            return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

        },

        fromArray: function ( array ) {

            this.x = array[ 0 ];
            this.y = array[ 1 ];
            this.z = array[ 2 ];
            this.w = array[ 3 ];

            return this;

        },

        toArray: function () {

            return [ this.x, this.y, this.z, this.w ];

        },

        clone: function () {

            return new Vec4( this.x, this.y, this.z, this.w );

        }

    };

    if ( typeof Vec4 === 'function' ) {
        var t = {}, p = {};
        for ( var i in Vec4 ) t[i] = Vec4[i];
        for ( var i in Vec4.prototype ) try { p[i] = Vec4.prototype[i] } catch(e) {};
        scope.Vec4 = Vec4.bind( scope );
    } else {
        scope.Vec4 = Vec4;
    }
    scope.Vec4.prototype = Vec4.prototype;
    for ( var i in t ) scope.Vec4[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Vec4.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Vec4 ) {
        for ( var i = 0, il = scope.__Vec4.length; i < il; i ++ ) scope.__Vec4[ i ]( Vec4 );
        delete scope.__Vec4;
    }

}) ( NWE );


// src/math/TypedVec2.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }


    var TypedVec2 = function ( x, y, onUpdate ) {

        this.elements = new Float32Array(2);

        this.elements[0] = x || 0;
        this.elements[1] = y || 0;

        this.__defineGetter__('x', function () {
            return this.elements[0];
        });

        this.__defineGetter__('y', function () {
            return this.elements[1];
        });

        this.__defineSetter__('x', function ( value ) {
            this.elements[0] = value;
            this.onUpdate();
        });

        this.__defineSetter__('y', function ( value ) {
            this.elements[1] = value;
            this.onUpdate();
        });

        this.onUpdate = ( typeof onUpdate === 'function' ) ? onUpdate : function () {};

    };

    TypedVec2.prototype = Object.create( Vec2.prototype );

    TypedVec2.prototype.clone = function () {

        return new TypedVec2( this.x, this.y, this.onUpdate );

    };

    if ( typeof TypedVec2 === 'function' ) {
        var t = {}, p = {};
        for ( var i in TypedVec2 ) t[i] = TypedVec2[i];
        for ( var i in TypedVec2.prototype ) try { p[i] = TypedVec2.prototype[i] } catch(e) {};
        scope.TypedVec2 = TypedVec2.bind( scope );
    } else {
        scope.TypedVec2 = TypedVec2;
    }
    scope.TypedVec2.prototype = TypedVec2.prototype;
    for ( var i in t ) scope.TypedVec2[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.TypedVec2.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__TypedVec2 ) {
        for ( var i = 0, il = scope.__TypedVec2.length; i < il; i ++ ) scope.__TypedVec2[ i ]( TypedVec2 );
        delete scope.__TypedVec2;
    }

}) ( NWE );


// src/math/TypedVec3.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var TypedVec3 = function ( x, y, z, onUpdate ) {

        this.elements = new Float32Array(3);

        this.elements[0] = x || 0;
        this.elements[1] = y || 0;
        this.elements[2] = z || 0;

        this.__defineGetter__('x', function () {
            return this.elements[0];
        });

        this.__defineGetter__('y', function () {
            return this.elements[1];
        });

        this.__defineGetter__('z', function () {
            return this.elements[2];
        });

        this.__defineSetter__('x', function ( value ) {
            this.elements[0] = value;
            this.onUpdate();
        });

        this.__defineSetter__('y', function ( value ) {
            this.elements[1] = value;
            this.onUpdate();
        });

        this.__defineSetter__('z', function ( value ) {
            this.elements[2] = value;
            this.onUpdate();
        });

        this.onUpdate = ( typeof onUpdate === 'function' ) ? onUpdate : function () {};

    };

    TypedVec3.prototype = Object.create( Vec3.prototype );

    TypedVec3.prototype.clone = function () {

        return new TypedVec2( this.x, this.y, this.z, this.onUpdate );

    };

    if ( typeof TypedVec3 === 'function' ) {
        var t = {}, p = {};
        for ( var i in TypedVec3 ) t[i] = TypedVec3[i];
        for ( var i in TypedVec3.prototype ) try { p[i] = TypedVec3.prototype[i] } catch(e) {};
        scope.TypedVec3 = TypedVec3.bind( scope );
    } else {
        scope.TypedVec3 = TypedVec3;
    }
    scope.TypedVec3.prototype = TypedVec3.prototype;
    for ( var i in t ) scope.TypedVec3[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.TypedVec3.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__TypedVec3 ) {
        for ( var i = 0, il = scope.__TypedVec3.length; i < il; i ++ ) scope.__TypedVec3[ i ]( TypedVec3 );
        delete scope.__TypedVec3;
    }

}) ( NWE );


// src/math/TypedVec4.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var Vec4 = NWE.Vec4;
    if ( !Vec4 ) { NWE.__Vec4 = (NWE.__Vec4 || []); NWE.__Vec4.push( function ( obj ) { Vec4 = obj; } ); }


    var TypedVec4 = function ( x, y, z, w, onUpdate ) {

        this.elements = new Float32Array(4);

        this.elements[0] = x || 0;
        this.elements[1] = y || 0;
        this.elements[2] = z || 0;
        this.elements[3] = ( w !== undefined ) ? w : 1;

        this.__defineGetter__('x', function () {
            return this.elements[0];
        });

        this.__defineGetter__('y', function () {
            return this.elements[1];
        });

        this.__defineGetter__('z', function () {
            return this.elements[2];
        });

        this.__defineGetter__('w', function () {
            return this.elements[3];
        });

        this.__defineSetter__('x', function ( value ) {
            this.elements[0] = value;
            this.onUpdate();
        });

        this.__defineSetter__('y', function ( value ) {
            this.elements[1] = value;
            this.onUpdate();
        });

        this.__defineSetter__('z', function ( value ) {
            this.elements[2] = value;
            this.onUpdate();
        });

        this.__defineSetter__('w', function ( value ) {
            this.elements[3] = value;
            this.onUpdate();
        });

        this.onUpdate = ( typeof onUpdate === 'function' ) ? onUpdate : function () {};

    };

    TypedVec4.prototype = Object.create( Vec4.prototype );

    TypedVec4.prototype.clone = function () {

        return new TypedVec2( this.x, this.y, this.z, this.w, this.onUpdate );

    };

    if ( typeof TypedVec4 === 'function' ) {
        var t = {}, p = {};
        for ( var i in TypedVec4 ) t[i] = TypedVec4[i];
        for ( var i in TypedVec4.prototype ) try { p[i] = TypedVec4.prototype[i] } catch(e) {};
        scope.TypedVec4 = TypedVec4.bind( scope );
    } else {
        scope.TypedVec4 = TypedVec4;
    }
    scope.TypedVec4.prototype = TypedVec4.prototype;
    for ( var i in t ) scope.TypedVec4[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.TypedVec4.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__TypedVec4 ) {
        for ( var i = 0, il = scope.__TypedVec4.length; i < il; i ++ ) scope.__TypedVec4[ i ]( TypedVec4 );
        delete scope.__TypedVec4;
    }

}) ( NWE );


// src/math/Euler.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://exocortex.com
     */

    var Quaternion = NWE.Quaternion;
    if ( !Quaternion ) { NWE.__Quaternion = (NWE.__Quaternion || []); NWE.__Quaternion.push( function ( obj ) { Quaternion = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var Euler = function ( x, y, z, order ) {

        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._order = order || NWE.Euler.DefaultOrder;

    };

    Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

    Euler.DefaultOrder = 'XYZ';

    Euler.prototype = {

        constructor: Euler,

        _x: 0, _y: 0, _z: 0, _order: Euler.DefaultOrder,

        _quaternion: undefined,

        _updateQuaternion: function () {

            if ( this._quaternion !== undefined ) {

                this._quaternion.setFromEuler( this, false );

            }

        },

        get x () {

            return this._x;

        },

        set x ( value ) {

            this._x = value;
            this._updateQuaternion();

        },

        get y () {

            return this._y;

        },

        set y ( value ) {

            this._y = value;
            this._updateQuaternion();

        },

        get z () {

            return this._z;

        },

        set z ( value ) {

            this._z = value;
            this._updateQuaternion();

        },

        get order () {

            return this._order;

        },

        set order ( value ) {

            this._order = value;
            this._updateQuaternion();

        },

        set: function ( x, y, z, order ) {

            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order || this._order;

            this._updateQuaternion();

            return this;

        },

        copy: function ( euler ) {

            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;

            this._updateQuaternion();

            return this;

        },

        setFromRotationMatrix: function ( m, order ) {

            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

            // clamp, to handle numerical problems

            function clamp( x ) {

                return Math.min( Math.max( x, -1 ), 1 );

            }

            var te = m.elements;
            var m11 = te[0], m12 = te[4], m13 = te[8];
            var m21 = te[1], m22 = te[5], m23 = te[9];
            var m31 = te[2], m32 = te[6], m33 = te[10];

            order = order || this._order;

            if ( order === 'XYZ' ) {

                this._y = Math.asin( clamp( m13 ) );

                if ( Math.abs( m13 ) < 0.99999 ) {

                    this._x = Math.atan2( - m23, m33 );
                    this._z = Math.atan2( - m12, m11 );

                } else {

                    this._x = Math.atan2( m32, m22 );
                    this._z = 0;

                }

            } else if ( order === 'YXZ' ) {

                this._x = Math.asin( - clamp( m23 ) );

                if ( Math.abs( m23 ) < 0.99999 ) {

                    this._y = Math.atan2( m13, m33 );
                    this._z = Math.atan2( m21, m22 );

                } else {

                    this._y = Math.atan2( - m31, m11 );
                    this._z = 0;

                }

            } else if ( order === 'ZXY' ) {

                this._x = Math.asin( clamp( m32 ) );

                if ( Math.abs( m32 ) < 0.99999 ) {

                    this._y = Math.atan2( - m31, m33 );
                    this._z = Math.atan2( - m12, m22 );

                } else {

                    this._y = 0;
                    this._z = Math.atan2( m21, m11 );

                }

            } else if ( order === 'ZYX' ) {

                this._y = Math.asin( - clamp( m31 ) );

                if ( Math.abs( m31 ) < 0.99999 ) {

                    this._x = Math.atan2( m32, m33 );
                    this._z = Math.atan2( m21, m11 );

                } else {

                    this._x = 0;
                    this._z = Math.atan2( - m12, m22 );

                }

            } else if ( order === 'YZX' ) {

                this._z = Math.asin( clamp( m21 ) );

                if ( Math.abs( m21 ) < 0.99999 ) {

                    this._x = Math.atan2( - m23, m22 );
                    this._y = Math.atan2( - m31, m11 );

                } else {

                    this._x = 0;
                    this._y = Math.atan2( m13, m33 );

                }

            } else if ( order === 'XZY' ) {

                this._z = Math.asin( - clamp( m12 ) );

                if ( Math.abs( m12 ) < 0.99999 ) {

                    this._x = Math.atan2( m32, m22 );
                    this._y = Math.atan2( m13, m11 );

                } else {

                    this._x = Math.atan2( - m23, m33 );
                    this._y = 0;

                }

            } else {

                Logger.warn( 'Euler.setFromRotationMatrix(): given unsupported order: ' + order )

            }

            this._order = order;

            this._updateQuaternion();

            return this;

        },

        setFromQuaternion: function ( q, order, update ) {

            // q is assumed to be normalized

            // clamp, to handle numerical problems

            function clamp( x ) {

                return Math.min( Math.max( x, -1 ), 1 );

            }

            // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m

            var sqx = q.x * q.x;
            var sqy = q.y * q.y;
            var sqz = q.z * q.z;
            var sqw = q.w * q.w;

            order = order || this._order;

            if ( order === 'XYZ' ) {

                this._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
                this._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );
                this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );

            } else if ( order ===  'YXZ' ) {

                this._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );
                this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
                this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );

            } else if ( order === 'ZXY' ) {

                this._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );
                this._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
                this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );

            } else if ( order === 'ZYX' ) {

                this._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
                this._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );
                this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );

            } else if ( order === 'YZX' ) {

                this._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
                this._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
                this._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );

            } else if ( order === 'XZY' ) {

                this._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
                this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
                this._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );

            } else {

                Logger.warn( 'Euler.setFromQuaternion(): given unsupported order: ' + order )

            }

            this._order = order;

            if ( update !== false ) this._updateQuaternion();

            return this;

        },

        reorder: function () {

            // WARNING: this discards revolution information -bhouston

            var q = new Quaternion();

            return function ( newOrder ) {

                q.setFromEuler( this );
                this.setFromQuaternion( q, newOrder );

            };


        }(),

        fromArray: function ( array ) {

            this._x = array[ 0 ];
            this._y = array[ 1 ];
            this._z = array[ 2 ];
            if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

            this._updateQuaternion();

            return this;

        },

        toArray: function () {

            return [ this._x, this._y, this._z, this._order ];

        },

        equals: function ( euler ) {

            return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

        },

        clone: function () {

            return new Euler( this._x, this._y, this._z, this._order );

        }

    };

    if ( typeof Euler === 'function' ) {
        var t = {}, p = {};
        for ( var i in Euler ) t[i] = Euler[i];
        for ( var i in Euler.prototype ) try { p[i] = Euler.prototype[i] } catch(e) {};
        scope.Euler = Euler.bind( scope );
    } else {
        scope.Euler = Euler;
    }
    scope.Euler.prototype = Euler.prototype;
    for ( var i in t ) scope.Euler[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Euler.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Euler ) {
        for ( var i = 0, il = scope.__Euler.length; i < il; i ++ ) scope.__Euler[ i ]( Euler );
        delete scope.__Euler;
    }

}) ( NWE );


// src/math/Line3.js

( function ( scope ) {

    /**
     * @author bhouston / http://exocortex.com
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var Line3 = function ( start, end ) {

        this.start = ( start !== undefined ) ? start : new Vec3();
        this.end = ( end !== undefined ) ? end : new Vec3();

    };

    Line3.prototype = {

        constructor: Line3,

        set: function ( start, end ) {

            this.start.copy( start );
            this.end.copy( end );

            return this;

        },

        copy: function ( line ) {

            this.start.copy( line.start );
            this.end.copy( line.end );

            return this;

        },

        center: function ( optionalTarget ) {

            var result = optionalTarget || new Vec3();
            return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

        },

        delta: function ( optionalTarget ) {

            var result = optionalTarget || new Vec3();
            return result.subVectors( this.end, this.start );

        },

        distanceSq: function () {

            return this.start.distanceToSquared( this.end );

        },

        distance: function () {

            return this.start.distanceTo( this.end );

        },

        at: function ( t, optionalTarget ) {

            var result = optionalTarget || new Vec3();

            return this.delta( result ).multiplyScalar( t ).add( this.start );

        },

        closestPointToPointParameter: function() {

            var startP = new Vec3();
            var startEnd = new Vec3();

            return function ( point, clampToLine ) {

                startP.subVectors( point, this.start );
                startEnd.subVectors( this.end, this.start );

                var startEnd2 = startEnd.dot( startEnd );
                var startEnd_startP = startEnd.dot( startP );

                var t = startEnd_startP / startEnd2;

                if ( clampToLine ) {

                    t = NWE.Math.clamp( t, 0, 1 );

                }

                return t;

            };

        }(),

        closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

            var t = this.closestPointToPointParameter( point, clampToLine );

            var result = optionalTarget || new Vec3();

            return this.delta( result ).multiplyScalar( t ).add( this.start );

        },

        applyMatrix4: function ( matrix ) {

            this.start.applyMatrix4( matrix );
            this.end.applyMatrix4( matrix );

            return this;

        },

        equals: function ( line ) {

            return line.start.equals( this.start ) && line.end.equals( this.end );

        },

        clone: function () {

            return new Line3().copy( this );

        }

    };

    if ( typeof Line3 === 'function' ) {
        var t = {}, p = {};
        for ( var i in Line3 ) t[i] = Line3[i];
        for ( var i in Line3.prototype ) try { p[i] = Line3.prototype[i] } catch(e) {};
        scope.Line3 = Line3.bind( scope );
    } else {
        scope.Line3 = Line3;
    }
    scope.Line3.prototype = Line3.prototype;
    for ( var i in t ) scope.Line3[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Line3.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Line3 ) {
        for ( var i = 0, il = scope.__Line3.length; i < il; i ++ ) scope.__Line3[ i ]( Line3 );
        delete scope.__Line3;
    }

}) ( NWE );


// src/math/Box2.js

( function ( scope ) {

    /**
     * @author bhouston / http://exocortex.com
     */

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }


    var Box2 = function ( min, max ) {

        this.min = ( min !== undefined ) ? min : new Vec2( Infinity, Infinity );
        this.max = ( max !== undefined ) ? max : new Vec2( -Infinity, -Infinity );

    };

    Box2.prototype = {

        constructor: Box2,

        set: function ( min, max ) {

            this.min.copy( min );
            this.max.copy( max );

            return this;

        },

        setFromPoints: function ( points ) {

            if ( points.length > 0 ) {

                var point = points[ 0 ];

                this.min.copy( point );
                this.max.copy( point );

                for ( var i = 1, il = points.length; i < il; i ++ ) {

                    point = points[ i ];

                    if ( point.x < this.min.x ) {

                        this.min.x = point.x;

                    } else if ( point.x > this.max.x ) {

                        this.max.x = point.x;

                    }

                    if ( point.y < this.min.y ) {

                        this.min.y = point.y;

                    } else if ( point.y > this.max.y ) {

                        this.max.y = point.y;

                    }

                }

            } else {

                this.makeEmpty();

            }

            return this;

        },

        setFromCenterAndSize: function () {

            var v1 = new Vec2();

            return function ( center, size ) {

                var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
                this.min.copy( center ).sub( halfSize );
                this.max.copy( center ).add( halfSize );

                return this;

            };

        }(),

        copy: function ( box ) {

            this.min.copy( box.min );
            this.max.copy( box.max );

            return this;

        },

        makeEmpty: function () {

            this.min.x = this.min.y = Infinity;
            this.max.x = this.max.y = -Infinity;

            return this;

        },

        empty: function () {

            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

            return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

        },

        center: function ( optionalTarget ) {

            var result = optionalTarget || new Vec2();
            return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

        },

        size: function ( optionalTarget ) {

            var result = optionalTarget || new Vec2();
            return result.subVectors( this.max, this.min );

        },

        expandByPoint: function ( point ) {

            this.min.min( point );
            this.max.max( point );

            return this;
        },

        expandByVector: function ( vector ) {

            this.min.sub( vector );
            this.max.add( vector );

            return this;
        },

        expandByScalar: function ( scalar ) {

            this.min.addScalar( -scalar );
            this.max.addScalar( scalar );

            return this;
        },

        containsPoint: function ( point ) {

            if ( point.x < this.min.x || point.x > this.max.x ||
                 point.y < this.min.y || point.y > this.max.y ) {

                return false;

            }

            return true;

        },

        containsBox: function ( box ) {

            if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
                 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

                return true;

            }

            return false;

        },

        getParameter: function ( point ) {

            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.

            return new Vec2(
                ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
                ( point.y - this.min.y ) / ( this.max.y - this.min.y )
            );

        },

        isIntersectionBox: function ( box ) {

            // using 6 splitting planes to rule out intersections.

            if ( box.max.x < this.min.x || box.min.x > this.max.x ||
                 box.max.y < this.min.y || box.min.y > this.max.y ) {

                return false;

            }

            return true;

        },

        clampPoint: function ( point, optionalTarget ) {

            var result = optionalTarget || new Vec2();
            return result.copy( point ).clamp( this.min, this.max );

        },

        distanceToPoint: function () {

            var v1 = new Vec2();

            return function ( point ) {

                var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
                return clampedPoint.sub( point ).length();

            };

        }(),

        intersect: function ( box ) {

            this.min.max( box.min );
            this.max.min( box.max );

            return this;

        },

        union: function ( box ) {

            this.min.min( box.min );
            this.max.max( box.max );

            return this;

        },

        translate: function ( offset ) {

            this.min.add( offset );
            this.max.add( offset );

            return this;

        },

        equals: function ( box ) {

            return box.min.equals( this.min ) && box.max.equals( this.max );

        },

        clone: function () {

            return new Box2().copy( this );

        }

    };

    if ( typeof Box2 === 'function' ) {
        var t = {}, p = {};
        for ( var i in Box2 ) t[i] = Box2[i];
        for ( var i in Box2.prototype ) try { p[i] = Box2.prototype[i] } catch(e) {};
        scope.Box2 = Box2.bind( scope );
    } else {
        scope.Box2 = Box2;
    }
    scope.Box2.prototype = Box2.prototype;
    for ( var i in t ) scope.Box2[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Box2.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Box2 ) {
        for ( var i = 0, il = scope.__Box2.length; i < il; i ++ ) scope.__Box2[ i ]( Box2 );
        delete scope.__Box2;
    }

}) ( NWE );


// src/math/Box3.js

( function ( scope ) {

    /**
     * @author bhouston / http://exocortex.com
     * @author WestLangley / http://github.com/WestLangley
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Sphere = NWE.Sphere;
    if ( !Sphere ) { NWE.__Sphere = (NWE.__Sphere || []); NWE.__Sphere.push( function ( obj ) { Sphere = obj; } ); }


    var Box3 = function ( min, max ) {

        this.min = ( min !== undefined ) ? min : new Vec3( Infinity, Infinity, Infinity );
        this.max = ( max !== undefined ) ? max : new Vec3( -Infinity, -Infinity, -Infinity );

    };

    Box3.prototype = {

        constructor: Box3,

        set: function ( min, max ) {

            this.min.copy( min );
            this.max.copy( max );

            return this;

        },

        addPoint: function ( point ) {

            if ( point.x < this.min.x ) {

                this.min.x = point.x;

            } else if ( point.x > this.max.x ) {

                this.max.x = point.x;

            }

            if ( point.y < this.min.y ) {

                this.min.y = point.y;

            } else if ( point.y > this.max.y ) {

                this.max.y = point.y;

            }

            if ( point.z < this.min.z ) {

                this.min.z = point.z;

            } else if ( point.z > this.max.z ) {

                this.max.z = point.z;

            }

        },

        setFromPoints: function ( points ) {

            if ( points.length > 0 ) {

                var point = points[ 0 ];

                this.min.copy( point );
                this.max.copy( point );

                for ( var i = 1, il = points.length; i < il; i ++ ) {

                    this.addPoint( points[ i ] )

                }

            } else {

                this.makeEmpty();

            }

            return this;

        },

        setFromCenterAndSize: function() {

            var v1 = new Vec3();

            return function ( center, size ) {

                var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

                this.min.copy( center ).sub( halfSize );
                this.max.copy( center ).add( halfSize );

                return this;

            };

        }(),

        setFromObject: function() {

            // Computes the world-axis-aligned bounding box of an object (including its children),
            // accounting for both the object's, and childrens', world transforms

            var v1 = new Vec3();

            return function( object ) {

                var scope = this;

                object.updateMatrixWorld( true );

                this.makeEmpty();

                object.traverse( function ( node ) {

                    if ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {

                        var vertices = node.geometry.vertices;

                        for ( var i = 0, il = vertices.length; i < il; i++ ) {

                            v1.copy( vertices[ i ] );

                            v1.applyMatrix4( node.matrixWorld );

                            scope.expandByPoint( v1 );

                        }

                    }

                } );

                return this;

            };

        }(),

        copy: function ( box ) {

            this.min.copy( box.min );
            this.max.copy( box.max );

            return this;

        },

        makeEmpty: function () {

            this.min.x = this.min.y = this.min.z = Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;

            return this;

        },

        empty: function () {

            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

            return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

        },

        center: function ( optionalTarget ) {

            var result = optionalTarget || new Vec3();
            return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

        },

        size: function ( optionalTarget ) {

            var result = optionalTarget || new Vec3();
            return result.subVectors( this.max, this.min );

        },

        expandByPoint: function ( point ) {

            this.min.min( point );
            this.max.max( point );

            return this;

        },

        expandByVector: function ( vector ) {

            this.min.sub( vector );
            this.max.add( vector );

            return this;

        },

        expandByScalar: function ( scalar ) {

            this.min.addScalar( -scalar );
            this.max.addScalar( scalar );

            return this;

        },

        containsPoint: function ( point ) {

            if ( point.x < this.min.x || point.x > this.max.x ||
                 point.y < this.min.y || point.y > this.max.y ||
                 point.z < this.min.z || point.z > this.max.z ) {

                return false;

            }

            return true;

        },

        containsBox: function ( box ) {

            if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
                 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
                 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

                return true;

            }

            return false;

        },

        getParameter: function ( point ) {

            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.

            return new Vec3(
                ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
                ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
                ( point.z - this.min.z ) / ( this.max.z - this.min.z )
            );

        },

        isIntersectionBox: function ( box ) {

            // using 6 splitting planes to rule out intersections.

            if ( box.max.x < this.min.x || box.min.x > this.max.x ||
                 box.max.y < this.min.y || box.min.y > this.max.y ||
                 box.max.z < this.min.z || box.min.z > this.max.z ) {

                return false;

            }

            return true;

        },

        clampPoint: function ( point, optionalTarget ) {

            var result = optionalTarget || new Vec3();
            return result.copy( point ).clamp( this.min, this.max );

        },

        distanceToPoint: function() {

            var v1 = new Vec3();

            return function ( point ) {

                var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
                return clampedPoint.sub( point ).length();

            };

        }(),

        getBoundingSphere: function() {

            var v1 = new Vec3();

            return function ( optionalTarget ) {

                var result = optionalTarget || new Sphere();

                result.center = this.center();
                result.radius = this.size( v1 ).length() * 0.5;

                return result;

            };

        }(),

        intersect: function ( box ) {

            this.min.max( box.min );
            this.max.min( box.max );

            return this;

        },

        union: function ( box ) {

            this.min.min( box.min );
            this.max.max( box.max );

            return this;

        },

        applyMatrix4: function() {

            var points = [
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3()
            ];

            return function ( matrix ) {

                // NOTE: I am using a binary pattern to specify all 2^3 combinations below
                points[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
                points[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
                points[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
                points[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
                points[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
                points[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
                points[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
                points[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

                this.makeEmpty();
                this.setFromPoints( points );

                return this;

            };

        }(),

        translate: function ( offset ) {

            this.min.add( offset );
            this.max.add( offset );

            return this;

        },

        equals: function ( box ) {

            return box.min.equals( this.min ) && box.max.equals( this.max );

        },

        clone: function () {

            return new Box3().copy( this );

        }

    };

    if ( typeof Box3 === 'function' ) {
        var t = {}, p = {};
        for ( var i in Box3 ) t[i] = Box3[i];
        for ( var i in Box3.prototype ) try { p[i] = Box3.prototype[i] } catch(e) {};
        scope.Box3 = Box3.bind( scope );
    } else {
        scope.Box3 = Box3;
    }
    scope.Box3.prototype = Box3.prototype;
    for ( var i in t ) scope.Box3[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Box3.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Box3 ) {
        for ( var i = 0, il = scope.__Box3.length; i < il; i ++ ) scope.__Box3[ i ]( Box3 );
        delete scope.__Box3;
    }

}) ( NWE );


// src/math/Matrix3.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://exocortex.com
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

        this.elements = new Float32Array(9);

        this.set(

            ( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,
            n21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,
            n31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1

        );

    };

    Matrix3.prototype = {

        constructor: Matrix3,

        set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

            var te = this.elements;

            te[0] = n11; te[3] = n12; te[6] = n13;
            te[1] = n21; te[4] = n22; te[7] = n23;
            te[2] = n31; te[5] = n32; te[8] = n33;

            return this;

        },

        identity: function () {

            this.set(

                1, 0, 0,
                0, 1, 0,
                0, 0, 1

            );

            return this;

        },

        copy: function ( m ) {

            var me = m.elements;

            this.set(

                me[0], me[3], me[6],
                me[1], me[4], me[7],
                me[2], me[5], me[8]

            );

            return this;

        },

        multiplyVec3Array: function () {

            var x, y, z;

            return function ( array, blockSize, offset, length ) {

                var te = this.elements;

                if ( blockSize === undefined ) blockSize = 3;
                if ( offset === undefined ) offset = 0;
                if ( length === undefined ) length = array.length;

                for ( var i = offset; i < length; i += blockSize ) {

                    x = array[ i + 0 ];
                    y = array[ i + 1 ];
                    z = array[ i + 2 ];

                    array[ i + 0 ] = te[ 0 ] * x + te[ 3 ] * y + te[ 6 ] * z;
                    array[ i + 1 ] = te[ 1 ] * x + te[ 4 ] * y + te[ 7 ] * z;
                    array[ i + 2 ] = te[ 2 ] * x + te[ 5 ] * y + te[ 8 ] * z;

                }

                return array;

            };

        }(),

        multiplyScalar: function ( s ) {

            var te = this.elements;

            te[0] *= s; te[3] *= s; te[6] *= s;
            te[1] *= s; te[4] *= s; te[7] *= s;
            te[2] *= s; te[5] *= s; te[8] *= s;

            return this;

        },

        determinant: function () {

            var te = this.elements;

            var a = te[0], b = te[1], c = te[2],
                d = te[3], e = te[4], f = te[5],
                g = te[6], h = te[7], i = te[8];

            return a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;

        },

        getInverse: function ( matrix, throwOnInvertible ) {

            // input: Matrix4
            // ( based on http://code.google.com/p/webgl-mjs/ )

            var me = matrix.elements;
            var te = this.elements;

            te[ 0 ] =   me[10] * me[5] - me[6] * me[9];
            te[ 1 ] = - me[10] * me[1] + me[2] * me[9];
            te[ 2 ] =   me[6] * me[1] - me[2] * me[5];
            te[ 3 ] = - me[10] * me[4] + me[6] * me[8];
            te[ 4 ] =   me[10] * me[0] - me[2] * me[8];
            te[ 5 ] = - me[6] * me[0] + me[2] * me[4];
            te[ 6 ] =   me[9] * me[4] - me[5] * me[8];
            te[ 7 ] = - me[9] * me[0] + me[1] * me[8];
            te[ 8 ] =   me[5] * me[0] - me[1] * me[4];

            var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

            // no inverse

            if ( det === 0 ) {

                var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

                if ( throwOnInvertible || false ) {

                    throw new Error( msg ); 

                } else {

                    Logger.warn( 'NWE.Matrix3.getInverse(): ' + msg );

                }

                this.identity();

                return this;

            }

            this.multiplyScalar( 1.0 / det );

            return this;

        },

        transpose: function () {

            var tmp, m = this.elements;

            tmp = m[1]; m[1] = m[3]; m[3] = tmp;
            tmp = m[2]; m[2] = m[6]; m[6] = tmp;
            tmp = m[5]; m[5] = m[7]; m[7] = tmp;

            return this;

        },

        getNormalMatrix: function ( m ) {

            // input: Matrix4

            this.getInverse( m ).transpose();

            return this;

        },

        transposeIntoArray: function ( r ) {

            var m = this.elements;

            r[ 0 ] = m[ 0 ];
            r[ 1 ] = m[ 3 ];
            r[ 2 ] = m[ 6 ];
            r[ 3 ] = m[ 1 ];
            r[ 4 ] = m[ 4 ];
            r[ 5 ] = m[ 7 ];
            r[ 6 ] = m[ 2 ];
            r[ 7 ] = m[ 5 ];
            r[ 8 ] = m[ 8 ];

            return this;

        },

        clone: function () {

            var te = this.elements;

            return new Matrix3(

                te[0], te[3], te[6],
                te[1], te[4], te[7],
                te[2], te[5], te[8]

            );

        }

    };

    if ( typeof Matrix3 === 'function' ) {
        var t = {}, p = {};
        for ( var i in Matrix3 ) t[i] = Matrix3[i];
        for ( var i in Matrix3.prototype ) try { p[i] = Matrix3.prototype[i] } catch(e) {};
        scope.Matrix3 = Matrix3.bind( scope );
    } else {
        scope.Matrix3 = Matrix3;
    }
    scope.Matrix3.prototype = Matrix3.prototype;
    for ( var i in t ) scope.Matrix3[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Matrix3.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Matrix3 ) {
        for ( var i = 0, il = scope.__Matrix3.length; i < il; i ++ ) scope.__Matrix3[ i ]( Matrix3 );
        delete scope.__Matrix3;
    }

}) ( NWE );


// src/math/Matrix4.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author jordi_ros / http://plattsoft.com
     * @author D1plo1d / http://github.com/D1plo1d
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author timknip / http://www.floorplanner.com/
     * @author bhouston / http://exocortex.com
     * @author WestLangley / http://github.com/WestLangley
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Euler = NWE.Euler;
    if ( !Euler ) { NWE.__Euler = (NWE.__Euler || []); NWE.__Euler.push( function ( obj ) { Euler = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

        this.elements = new Float32Array( 16 );

        // TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix
        //   we should not support semi specification of Matrix4, it is just weird.

        var te = this.elements;

        te[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;
        te[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;
        te[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;
        te[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;

    };

    Matrix4.prototype = {

        constructor: Matrix4,

        set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

            var te = this.elements;

            te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
            te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
            te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
            te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;

            return this;

        },

        identity: function () {

            this.set(

                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1

            );

            return this;

        },

        copy: function ( m ) {

            this.elements.set( m.elements );

            return this;

        },

        copyPosition: function ( m ) {

            var te = this.elements;
            var me = m.elements;

            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];

            return this;

        },

        extractRotation: function () {

            var v1 = new Vec3();

            return function ( m ) {

                var te = this.elements;
                var me = m.elements;

                var scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();
                var scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();
                var scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();

                te[0] = me[0] * scaleX;
                te[1] = me[1] * scaleX;
                te[2] = me[2] * scaleX;

                te[4] = me[4] * scaleY;
                te[5] = me[5] * scaleY;
                te[6] = me[6] * scaleY;

                te[8] = me[8] * scaleZ;
                te[9] = me[9] * scaleZ;
                te[10] = me[10] * scaleZ;

                return this;

            };

        }(),

        makeRotationFromEuler: function ( euler ) {

            if ( euler instanceof Euler === false ) {

                Logger.error( 'NWE.Matrix4.makeRotationFromEuler(): method expects a Euler rotation rather than a Vec3.' );

            }

            var te = this.elements;

            var x = euler.x, y = euler.y, z = euler.z;
            var a = Math.cos( x ), b = Math.sin( x );
            var c = Math.cos( y ), d = Math.sin( y );
            var e = Math.cos( z ), f = Math.sin( z );

            if ( euler.order === 'XYZ' ) {

                var ae = a * e, af = a * f, be = b * e, bf = b * f;

                te[0] = c * e;
                te[4] = - c * f;
                te[8] = d;

                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = - b * c;

                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;

            } else if ( euler.order === 'YXZ' ) {

                var ce = c * e, cf = c * f, de = d * e, df = d * f;

                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;

                te[1] = a * f;
                te[5] = a * e;
                te[9] = - b;

                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;

            } else if ( euler.order === 'ZXY' ) {

                var ce = c * e, cf = c * f, de = d * e, df = d * f;

                te[0] = ce - df * b;
                te[4] = - a * f;
                te[8] = de + cf * b;

                te[1] = cf + de * b;
                te[5] = a * e;
                te[9] = df - ce * b;

                te[2] = - a * d;
                te[6] = b;
                te[10] = a * c;

            } else if ( euler.order === 'ZYX' ) {

                var ae = a * e, af = a * f, be = b * e, bf = b * f;

                te[0] = c * e;
                te[4] = be * d - af;
                te[8] = ae * d + bf;

                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;

                te[2] = - d;
                te[6] = b * c;
                te[10] = a * c;

            } else if ( euler.order === 'YZX' ) {

                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;

                te[1] = f;
                te[5] = a * e;
                te[9] = - b * e;

                te[2] = - d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;

            } else if ( euler.order === 'XZY' ) {

                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

                te[0] = c * e;
                te[4] = - f;
                te[8] = d * e;

                te[1] = ac * f + bd;
                te[5] = a * e;
                te[9] = ad * f - bc;

                te[2] = bc * f - ad;
                te[6] = b * e;
                te[10] = bd * f + ac;

            }

            // last column
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;

            // bottom row
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;

            return this;

        },

        makeRotationFromQuaternion: function ( q ) {

            var te = this.elements;

            var x = q.x, y = q.y, z = q.z, w = q.w;
            var x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;

            te[0] = 1 - ( yy + zz );
            te[4] = xy - wz;
            te[8] = xz + wy;

            te[1] = xy + wz;
            te[5] = 1 - ( xx + zz );
            te[9] = yz - wx;

            te[2] = xz - wy;
            te[6] = yz + wx;
            te[10] = 1 - ( xx + yy );

            // last column
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;

            // bottom row
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;

            return this;

        },

        lookAt: function() {

            var x = new Vec3();
            var y = new Vec3();
            var z = new Vec3();

            return function ( eye, target, up ) {

                var te = this.elements;

                z.subVectors( eye, target ).normalize();

                if ( z.length() === 0 ) {

                    z.z = 1;

                }

                x.crossVectors( up, z ).normalize();

                if ( x.length() === 0 ) {

                    z.x += 0.0001;
                    x.crossVectors( up, z ).normalize();

                }

                y.crossVectors( z, x );


                te[0] = x.x; te[4] = y.x; te[8] = z.x;
                te[1] = x.y; te[5] = y.y; te[9] = z.y;
                te[2] = x.z; te[6] = y.z; te[10] = z.z;

                return this;

            };

        }(),

        multiply: function ( a ) {

            return this.multiplyMatrices( this, a );

        },

        multiplyMatrices: function ( a, b ) {

            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;

            var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
            var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
            var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
            var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];

            var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
            var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
            var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
            var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];

            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

            return this;

        },

        multiplyToArray: function ( a, b, r ) {

            var te = this.elements;

            this.multiplyMatrices( a, b );

            r[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];
            r[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];
            r[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];
            r[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];

            return this;

        },

        multiplyScalar: function ( s ) {

            var te = this.elements;

            te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
            te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
            te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
            te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;

            return this;

        },

        multiplyVec3Array: function () {

            var x, y, z;

            return function ( array, blockSize, offset, length ) {

                var te = this.elements;

                if ( blockSize === undefined ) blockSize = 3;
                if ( offset === undefined ) offset = 0;
                if ( length === undefined ) length = array.length;

                for ( var i = offset; i < length; i += blockSize ) {

                    x = array[ i + 0 ];
                    y = array[ i + 1 ];
                    z = array[ i + 2 ];

                    array[ i + 0 ] = te[ 0 ] * x + te[ 4 ] * y + te[ 8 ]  * z + te[ 12 ];
                    array[ i + 1 ] = te[ 1 ] * x + te[ 5 ] * y + te[ 9 ]  * z + te[ 13 ];
                    array[ i + 2 ] = te[ 2 ] * x + te[ 6 ] * y + te[ 10 ] * z + te[ 14 ];

                }

                return array;

            };

        }(),

        determinant: function () {

            var te = this.elements;

            var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
            var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
            var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];

            //TODO: make this more efficient
            //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

            return (
                n41 * (
                    +n14 * n23 * n32
                    -n13 * n24 * n32
                    -n14 * n22 * n33
                    +n12 * n24 * n33
                    +n13 * n22 * n34
                    -n12 * n23 * n34
                ) +
                n42 * (
                    +n11 * n23 * n34
                    -n11 * n24 * n33
                    +n14 * n21 * n33
                    -n13 * n21 * n34
                    +n13 * n24 * n31
                    -n14 * n23 * n31
                ) +
                n43 * (
                    +n11 * n24 * n32
                    -n11 * n22 * n34
                    -n14 * n21 * n32
                    +n12 * n21 * n34
                    +n14 * n22 * n31
                    -n12 * n24 * n31
                ) +
                n44 * (
                    -n13 * n22 * n31
                    -n11 * n23 * n32
                    +n11 * n22 * n33
                    +n13 * n21 * n32
                    -n12 * n21 * n33
                    +n12 * n23 * n31
                )

            );

        },

        transpose: function () {

            var te = this.elements;
            var tmp;

            tmp = te[1]; te[1] = te[4]; te[4] = tmp;
            tmp = te[2]; te[2] = te[8]; te[8] = tmp;
            tmp = te[6]; te[6] = te[9]; te[9] = tmp;

            tmp = te[3]; te[3] = te[12]; te[12] = tmp;
            tmp = te[7]; te[7] = te[13]; te[13] = tmp;
            tmp = te[11]; te[11] = te[14]; te[14] = tmp;

            return this;

        },

        flattenToArray: function ( flat ) {

            var te = this.elements;
            flat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];
            flat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];
            flat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];
            flat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];

            return flat;

        },

        flattenToArrayOffset: function( flat, offset ) {

            var te = this.elements;
            flat[ offset ] = te[0];
            flat[ offset + 1 ] = te[1];
            flat[ offset + 2 ] = te[2];
            flat[ offset + 3 ] = te[3];

            flat[ offset + 4 ] = te[4];
            flat[ offset + 5 ] = te[5];
            flat[ offset + 6 ] = te[6];
            flat[ offset + 7 ] = te[7];

            flat[ offset + 8 ]  = te[8];
            flat[ offset + 9 ]  = te[9];
            flat[ offset + 10 ] = te[10];
            flat[ offset + 11 ] = te[11];

            flat[ offset + 12 ] = te[12];
            flat[ offset + 13 ] = te[13];
            flat[ offset + 14 ] = te[14];
            flat[ offset + 15 ] = te[15];

            return flat;

        },

        setPosition: function ( v ) {

            var te = this.elements;

            te[12] = v.x;
            te[13] = v.y;
            te[14] = v.z;

            return this;

        },

        getInverse: function ( m, throwOnInvertible ) {

            // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
            var te = this.elements;
            var me = m.elements;

            var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
            var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
            var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
            var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];

            te[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;
            te[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;
            te[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;
            te[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;
            te[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;
            te[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;
            te[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;
            te[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;
            te[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;
            te[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;
            te[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;
            te[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;
            te[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;
            te[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;
            te[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;
            te[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;

            var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

            if ( det == 0 ) {

                var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

                if ( throwOnInvertible || false ) {

                    throw new Error( msg ); 

                } else {

                    Logger.warn( 'NWE.Matrix4.getInverse(): ' + msg );

                }

                this.identity();

                return this;
            }

            this.multiplyScalar( 1 / det );

            return this;

        },

        scale: function ( v ) {

            var te = this.elements;
            var x = v.x, y = v.y, z = v.z;

            te[0] *= x; te[4] *= y; te[8] *= z;
            te[1] *= x; te[5] *= y; te[9] *= z;
            te[2] *= x; te[6] *= y; te[10] *= z;
            te[3] *= x; te[7] *= y; te[11] *= z;

            return this;

        },

        getMaxScaleOnAxis: function () {

            var te = this.elements;

            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

            return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

        },

        makeTranslation: function ( x, y, z ) {

            if ( x instanceof Vec3 ) {

                z = x.z;
                y = x.y;
                x = x.x;

            }

            this.set(

                1, 0, 0, x,
                0, 1, 0, y,
                0, 0, 1, z,
                0, 0, 0, 1

            );

            return this;

        },

        makeRotationX: function ( theta ) {

            var c = Math.cos( theta ), s = Math.sin( theta );

            this.set(

                1, 0,  0, 0,
                0, c, -s, 0,
                0, s,  c, 0,
                0, 0,  0, 1

            );

            return this;

        },

        makeRotationY: function ( theta ) {

            var c = Math.cos( theta ), s = Math.sin( theta );

            this.set(

                 c, 0, s, 0,
                 0, 1, 0, 0,
                -s, 0, c, 0,
                 0, 0, 0, 1

            );

            return this;

        },

        makeRotationZ: function ( theta ) {

            var c = Math.cos( theta ), s = Math.sin( theta );

            this.set(

                c, -s, 0, 0,
                s,  c, 0, 0,
                0,  0, 1, 0,
                0,  0, 0, 1

            );

            return this;

        },

        makeRotationAxis: function ( axis, angle ) {

            // Based on http://www.gamedev.net/reference/articles/article1199.asp

            var c = Math.cos( angle );
            var s = Math.sin( angle );
            var t = 1 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;

            this.set(

                tx * x + c, tx * y - s * z, tx * z + s * y, 0,
                tx * y + s * z, ty * y + c, ty * z - s * x, 0,
                tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
                0, 0, 0, 1

            );

             return this;

        },

        makeScale: function ( x, y, z ) {

            if ( x instanceof Vec3 ) {

                z = x.z;
                y = x.y;
                x = x.x;

            }

            this.set(

                x, 0, 0, 0,
                0, y, 0, 0,
                0, 0, z, 0,
                0, 0, 0, 1

            );

            return this;

        },

        compose: function ( position, quaternion, scale ) {

            this.makeRotationFromQuaternion( quaternion );
            this.scale( scale );
            this.setPosition( position );

            return this;

        },

        decompose: function () {

            var vector = new Vec3();
            var matrix = new Matrix4();

            return function ( position, quaternion, scale ) {

                var te = this.elements;

                var sx = vector.set( te[0], te[1], te[2] ).length();
                var sy = vector.set( te[4], te[5], te[6] ).length();
                var sz = vector.set( te[8], te[9], te[10] ).length();

                position.x = te[12];
                position.y = te[13];
                position.z = te[14];

                // scale the rotation part

                matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

                var invSX = 1 / sx;
                var invSY = 1 / sy;
                var invSZ = 1 / sz;

                matrix.elements[0] *= invSX;
                matrix.elements[1] *= invSX;
                matrix.elements[2] *= invSX;

                matrix.elements[4] *= invSY;
                matrix.elements[5] *= invSY;
                matrix.elements[6] *= invSY;

                matrix.elements[8] *= invSZ;
                matrix.elements[9] *= invSZ;
                matrix.elements[10] *= invSZ;

                quaternion.setFromRotationMatrix( matrix );

                scale.x = sx;
                scale.y = sy;
                scale.z = sz;

                return this;

            };

        }(),

        makeFrustum: function ( left, right, bottom, top, near, far ) {

            var te = this.elements;
            var x = 2 * near / ( right - left );
            var y = 2 * near / ( top - bottom );

            var a = ( right + left ) / ( right - left );
            var b = ( top + bottom ) / ( top - bottom );
            var c = - ( far + near ) / ( far - near );
            var d = - 2 * far * near / ( far - near );

            te[0] = x;  te[4] = 0;  te[8] = a;  te[12] = 0;
            te[1] = 0;  te[5] = y;  te[9] = b;  te[13] = 0;
            te[2] = 0;  te[6] = 0;  te[10] = c; te[14] = d;
            te[3] = 0;  te[7] = 0;  te[11] = - 1;   te[15] = 0;

            return this;

        },

        makePerspective: function ( fov, aspect, near, far ) {

            var ymax = near * Math.tan( NWE.Math.degToRad( fov * 0.5 ) );
            var ymin = - ymax;
            var xmin = ymin * aspect;
            var xmax = ymax * aspect;

            return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

        },

        makeOrthographic: function ( left, right, top, bottom, near, far ) {

            var te = this.elements;
            var w = right - left;
            var h = top - bottom;
            var p = far - near;

            var x = ( right + left ) / w;
            var y = ( top + bottom ) / h;
            var z = ( far + near ) / p;

            te[0] = 2 / w;  te[4] = 0;  te[8] = 0;  te[12] = -x;
            te[1] = 0;  te[5] = 2 / h;  te[9] = 0;  te[13] = -y;
            te[2] = 0;  te[6] = 0;  te[10] = -2/p;  te[14] = -z;
            te[3] = 0;  te[7] = 0;  te[11] = 0; te[15] = 1;

            return this;

        },

        fromArray: function ( array ) {

            this.elements.set( array );

            return this;

        },

        toArray: function () {

            var te = this.elements;

            return [
                te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
                te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
                te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
                te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
            ];

        },

        clone: function () {

            var te = this.elements;

            return new Matrix4(

                te[0], te[4], te[8], te[12],
                te[1], te[5], te[9], te[13],
                te[2], te[6], te[10], te[14],
                te[3], te[7], te[11], te[15]

            );

        }

    };

    if ( typeof Matrix4 === 'function' ) {
        var t = {}, p = {};
        for ( var i in Matrix4 ) t[i] = Matrix4[i];
        for ( var i in Matrix4.prototype ) try { p[i] = Matrix4.prototype[i] } catch(e) {};
        scope.Matrix4 = Matrix4.bind( scope );
    } else {
        scope.Matrix4 = Matrix4;
    }
    scope.Matrix4.prototype = Matrix4.prototype;
    for ( var i in t ) scope.Matrix4[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Matrix4.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Matrix4 ) {
        for ( var i = 0, il = scope.__Matrix4.length; i < il; i ++ ) scope.__Matrix4[ i ]( Matrix4 );
        delete scope.__Matrix4;
    }

}) ( NWE );


// src/math/Ray.js

( function ( scope ) {

    /**
     * @author bhouston / http://exocortex.com
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var Ray = function ( origin, direction ) {

        this.origin = ( origin !== undefined ) ? origin : new Vec3();
        this.direction = ( direction !== undefined ) ? direction : new Vec3();

    };

    Ray.prototype = {

        constructor: Ray,

        set: function ( origin, direction ) {

            this.origin.copy( origin );
            this.direction.copy( direction );

            return this;

        },

        copy: function ( ray ) {

            this.origin.copy( ray.origin );
            this.direction.copy( ray.direction );

            return this;

        },

        at: function ( t, optionalTarget ) {

            var result = optionalTarget || new Vec3();

            return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

        },

        recast: function () {

            var v1 = new Vec3();

            return function ( t ) {

                this.origin.copy( this.at( t, v1 ) );

                return this;

            };

        }(),

        closestPointToPoint: function ( point, optionalTarget ) {

            var result = optionalTarget || new Vec3();
            result.subVectors( point, this.origin );
            var directionDistance = result.dot( this.direction );

            if ( directionDistance < 0 ) {

                return result.copy( this.origin );

            }

            return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

        },

        distanceToPoint: function () {

            var v1 = new Vec3();

            return function ( point ) {

                var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

                // point behind the ray

                if ( directionDistance < 0 ) {

                    return this.origin.distanceTo( point );

                }

                v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

                return v1.distanceTo( point );

            };

        }(),

        distanceSqToSegment: function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

            // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment

            var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
            var segDir = v1.clone().sub( v0 ).normalize();
            var segExtent = v0.distanceTo( v1 ) * 0.5;
            var diff = this.origin.clone().sub( segCenter );
            var a01 = - this.direction.dot( segDir );
            var b0 = diff.dot( this.direction );
            var b1 = - diff.dot( segDir );
            var c = diff.lengthSq();
            var det = Math.abs( 1 - a01 * a01 );
            var s0, s1, sqrDist, extDet;

            if ( det >= 0 ) {

                // The ray and segment are not parallel.

                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;

                if ( s0 >= 0 ) {

                    if ( s1 >= - extDet ) {

                        if ( s1 <= extDet ) {

                            // region 0
                            // Minimum at interior points of ray and segment.

                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

                        } else {

                            // region 1

                            s1 = segExtent;
                            s0 = Math.max( 0, - ( a01 * s1 + b0) );
                            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                        }

                    } else {

                        // region 5

                        s1 = - segExtent;
                        s0 = Math.max( 0, - ( a01 * s1 + b0) );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                } else {

                    if ( s1 <= - extDet) {

                        // region 4

                        s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    } else if ( s1 <= extDet ) {

                        // region 3

                        s0 = 0;
                        s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = s1 * ( s1 + 2 * b1 ) + c;

                    } else {

                        // region 2

                        s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                }

            } else {

                // Ray and segment are parallel.

                s1 = ( a01 > 0 ) ? - segExtent : segExtent;
                s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

            if ( optionalPointOnRay ) {

                optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );

            }

            if ( optionalPointOnSegment ) {

                optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );

            }

            return sqrDist;

        },

        isIntersectionSphere: function ( sphere ) {

            return this.distanceToPoint( sphere.center ) <= sphere.radius;

        },

        isIntersectionPlane: function ( plane ) {

            // check if the ray lies on the plane first

            var distToPoint = plane.distanceToPoint( this.origin );

            if ( distToPoint === 0 ) {

                return true;

            }

            var denominator = plane.normal.dot( this.direction );

            if ( denominator * distToPoint < 0 ) {

                return true

            }

            // ray origin is behind the plane (and is pointing behind it)

            return false;

        },

        distanceToPlane: function ( plane ) {

            var denominator = plane.normal.dot( this.direction );
            if ( denominator == 0 ) {

                // line is coplanar, return origin
                if( plane.distanceToPoint( this.origin ) == 0 ) {

                    return 0;

                }

                // Null is preferable to undefined since undefined means.... it is undefined

                return null;

            }

            var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

            // Return if the ray never intersects the plane

            return t >= 0 ? t :  null;

        },

        intersectPlane: function ( plane, optionalTarget ) {

            var t = this.distanceToPlane( plane );

            if ( t === null ) {

                return null;
            }

            return this.at( t, optionalTarget );

        },

        isIntersectionBox: function () {
            
            var v = new Vec3();

            return function ( box ) {

                return this.intersectBox( box, v ) !== null;

            }

        }(),

        intersectBox: function ( box , optionalTarget ) {

            // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

            var tmin,tmax,tymin,tymax,tzmin,tzmax;

            var invdirx = 1/this.direction.x,
                invdiry = 1/this.direction.y,
                invdirz = 1/this.direction.z;

            var origin = this.origin;

            if (invdirx >= 0) {
                    
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;

            } else { 

                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
            }           

            if (invdiry >= 0) {
            
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;

            } else {

                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
            }

            if ((tmin > tymax) || (tymin > tmax)) return null;

            // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN
            
            if (tymin > tmin || tmin !== tmin ) tmin = tymin;

            if (tymax < tmax || tmax !== tmax ) tmax = tymax;

            if (invdirz >= 0) {
            
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;

            } else {

                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
            }

            if ((tmin > tzmax) || (tzmin > tmax)) return null;

            if (tzmin > tmin || tmin !== tmin ) tmin = tzmin;

            if (tzmax < tmax || tmax !== tmax ) tmax = tzmax;

            //return point closest to the ray (positive side)

            if ( tmax < 0 ) return null;

            return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

        },

        intersectTriangle: function() {

            // Compute the offset origin, edges, and normal.
            var diff = new Vec3();
            var edge1 = new Vec3();
            var edge2 = new Vec3();
            var normal = new Vec3();

            return function ( a, b, c, backfaceCulling, optionalTarget ) {

                // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

                edge1.subVectors( b, a );
                edge2.subVectors( c, a );
                normal.crossVectors( edge1, edge2 );

                // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
                // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
                //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
                //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
                //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
                var DdN = this.direction.dot( normal );
                var sign;

                if ( DdN > 0 ) {

                    if ( backfaceCulling ) return null;
                    sign = 1;

                } else if ( DdN < 0 ) {

                    sign = - 1;
                    DdN = - DdN;

                } else {

                    return null;

                }

                diff.subVectors( this.origin, a );
                var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

                // b1 < 0, no intersection
                if ( DdQxE2 < 0 ) {

                    return null;

                }

                var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

                // b2 < 0, no intersection
                if ( DdE1xQ < 0 ) {

                    return null;

                }

                // b1+b2 > 1, no intersection
                if ( DdQxE2 + DdE1xQ > DdN ) {

                    return null;

                }

                // Line intersects triangle, check if ray does.
                var QdN = - sign * diff.dot( normal );

                // t < 0, no intersection
                if ( QdN < 0 ) {

                    return null;

                }

                // Ray intersects triangle.
                return this.at( QdN / DdN, optionalTarget );
        
            }
        
        }(),

        applyMatrix4: function ( matrix4 ) {

            this.direction.add( this.origin ).applyMatrix4( matrix4 );
            this.origin.applyMatrix4( matrix4 );
            this.direction.sub( this.origin );
            this.direction.normalize();

            return this;
        },

        equals: function ( ray ) {

            return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

        },

        clone: function () {

            return new Ray().copy( this );

        }

    };

    if ( typeof Ray === 'function' ) {
        var t = {}, p = {};
        for ( var i in Ray ) t[i] = Ray[i];
        for ( var i in Ray.prototype ) try { p[i] = Ray.prototype[i] } catch(e) {};
        scope.Ray = Ray.bind( scope );
    } else {
        scope.Ray = Ray;
    }
    scope.Ray.prototype = Ray.prototype;
    for ( var i in t ) scope.Ray[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Ray.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Ray ) {
        for ( var i = 0, il = scope.__Ray.length; i < il; i ++ ) scope.__Ray[ i ]( Ray );
        delete scope.__Ray;
    }

}) ( NWE );


// src/math/Sphere.js

( function ( scope ) {

    /**
     * @author bhouston / http://exocortex.com
     * @author mrdoob / http://mrdoob.com/
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Box3 = NWE.Box3;
    if ( !Box3 ) { NWE.__Box3 = (NWE.__Box3 || []); NWE.__Box3.push( function ( obj ) { Box3 = obj; } ); }


    var Sphere = function ( center, radius ) {

        this.center = ( center !== undefined ) ? center : new Vec3();
        this.radius = ( radius !== undefined ) ? radius : 0;

    };

    Sphere.prototype = {

        constructor: Sphere,

        set: function ( center, radius ) {

            this.center.copy( center );
            this.radius = radius;

            return this;
        },


        setFromPoints: function () {

            var box = new Box3();

            return function ( points, optionalCenter )  {

                var center = this.center;

                if ( optionalCenter !== undefined ) {

                    center.copy( optionalCenter );

                } else {

                    box.setFromPoints( points ).center( center );

                }

                var maxRadiusSq = 0;

                for ( var i = 0, il = points.length; i < il; i ++ ) {

                    maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

                }

                this.radius = Math.sqrt( maxRadiusSq );

                return this;            
            
            };

        }(),

        copy: function ( sphere ) {

            this.center.copy( sphere.center );
            this.radius = sphere.radius;

            return this;

        },

        empty: function () {

            return ( this.radius <= 0 );

        },

        containsPoint: function ( point ) {

            return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

        },

        distanceToPoint: function ( point ) {

            return ( point.distanceTo( this.center ) - this.radius );

        },

        intersectsSphere: function ( sphere ) {

            var radiusSum = this.radius + sphere.radius;

            return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

        },

        clampPoint: function ( point, optionalTarget ) {

            var deltaLengthSq = this.center.distanceToSquared( point );

            var result = optionalTarget || new Vec3();
            result.copy( point );

            if ( deltaLengthSq > ( this.radius * this.radius ) ) {

                result.sub( this.center ).normalize();
                result.multiplyScalar( this.radius ).add( this.center );

            }

            return result;

        },

        getBoundingBox: function ( optionalTarget ) {

            var box = optionalTarget || new Box3();

            box.set( this.center, this.center );
            box.expandByScalar( this.radius );

            return box;

        },

        applyMatrix4: function ( matrix ) {

            this.center.applyMatrix4( matrix );
            this.radius = this.radius * matrix.getMaxScaleOnAxis();

            return this;

        },

        translate: function ( offset ) {

            this.center.add( offset );

            return this;

        },

        equals: function ( sphere ) {

            return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

        },

        clone: function () {

            return new Sphere().copy( this );

        }

    };

    if ( typeof Sphere === 'function' ) {
        var t = {}, p = {};
        for ( var i in Sphere ) t[i] = Sphere[i];
        for ( var i in Sphere.prototype ) try { p[i] = Sphere.prototype[i] } catch(e) {};
        scope.Sphere = Sphere.bind( scope );
    } else {
        scope.Sphere = Sphere;
    }
    scope.Sphere.prototype = Sphere.prototype;
    for ( var i in t ) scope.Sphere[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Sphere.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Sphere ) {
        for ( var i = 0, il = scope.__Sphere.length; i < il; i ++ ) scope.__Sphere[ i ]( Sphere );
        delete scope.__Sphere;
    }

}) ( NWE );


// src/math/Frustum.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / http://exocortex.com
     * @author ohmed
     */

    var Plane = NWE.Plane;
    if ( !Plane ) { NWE.__Plane = (NWE.__Plane || []); NWE.__Plane.push( function ( obj ) { Plane = obj; } ); }

    var Box3 = NWE.Box3;
    if ( !Box3 ) { NWE.__Box3 = (NWE.__Box3 || []); NWE.__Box3.push( function ( obj ) { Box3 = obj; } ); }

    var Sphere = NWE.Sphere;
    if ( !Sphere ) { NWE.__Sphere = (NWE.__Sphere || []); NWE.__Sphere.push( function ( obj ) { Sphere = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

        this.planes = [

            ( p0 !== undefined ) ? p0 : new Plane(),
            ( p1 !== undefined ) ? p1 : new Plane(),
            ( p2 !== undefined ) ? p2 : new Plane(),
            ( p3 !== undefined ) ? p3 : new Plane(),
            ( p4 !== undefined ) ? p4 : new Plane(),
            ( p5 !== undefined ) ? p5 : new Plane()

        ];

    };

    Frustum.prototype = {

        constructor: Frustum,

        set: function ( p0, p1, p2, p3, p4, p5 ) {

            var planes = this.planes;

            planes[0].copy( p0 );
            planes[1].copy( p1 );
            planes[2].copy( p2 );
            planes[3].copy( p3 );
            planes[4].copy( p4 );
            planes[5].copy( p5 );

            return this;

        },

        copy: function ( frustum ) {

            var planes = this.planes;

            for( var i = 0; i < 6; i ++ ) {

                planes[i].copy( frustum.planes[i] );

            }

            return this;

        },

        setFromMatrix: function ( m ) {

            var planes = this.planes;
            var me = m.elements;
            var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
            var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
            var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
            var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];

            planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
            planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
            planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
            planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
            planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
            planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

            return this;

        },

        intersectsObject: function () {

            var sphere = new Sphere();
            var box = new Box3();

            return function ( object ) {

                var geometry = object.geometry;

                if ( geometry.boundingSphere !== null ) {

                    sphere.copy( geometry.boundingSphere );
                    sphere.applyMatrix4( object.matrixWorld );
                    return this.intersectsSphere( sphere );

                } else if ( geometry.boundingBox !== null ) {

                    box.copy( geometry.boundingBox );
                    box.applyMatrix4( object.matrixWorld );
                    return this.intersectsBox( box );

                } else {

                    geometry.computeBoundingSphere();

                    sphere.copy( geometry.boundingSphere );
                    sphere.applyMatrix4( object.matrixWorld );
                    return this.intersectsSphere( sphere );

                }

            };

        }(),

        intersectsSphere: function ( sphere ) {

            var planes = this.planes;
            var center = sphere.center;
            var negRadius = -sphere.radius;

            for ( var i = 0; i < 6; i ++ ) {

                var distance = planes[ i ].distanceToPoint( center );

                if ( distance < negRadius ) {

                    return false;

                }

            }

            return true;

        },

        intersectsBox : function() {

            var p1 = new Vec3(),
                p2 = new Vec3();

            return function( box ) {

                var planes = this.planes;
                
                for ( var i = 0; i < 6 ; i ++ ) {
                
                    var plane = planes[i];
                    
                    p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                    p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                    p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                    p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                    p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                    p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                    var d1 = plane.distanceToPoint( p1 );
                    var d2 = plane.distanceToPoint( p2 );
                    
                    // if both outside plane, no intersection

                    if ( d1 < 0 && d2 < 0 ) {
                        
                        return false;
            
                    }
                }

                return true;
            };

        }(),


        containsPoint: function ( point ) {

            var planes = this.planes;

            for ( var i = 0; i < 6; i ++ ) {

                if ( planes[ i ].distanceToPoint( point ) < 0 ) {

                    return false;

                }

            }

            return true;

        },

        clone: function () {

            return new Frustum().copy( this );

        }

    };

    if ( typeof Frustum === 'function' ) {
        var t = {}, p = {};
        for ( var i in Frustum ) t[i] = Frustum[i];
        for ( var i in Frustum.prototype ) try { p[i] = Frustum.prototype[i] } catch(e) {};
        scope.Frustum = Frustum.bind( scope );
    } else {
        scope.Frustum = Frustum;
    }
    scope.Frustum.prototype = Frustum.prototype;
    for ( var i in t ) scope.Frustum[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Frustum.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Frustum ) {
        for ( var i = 0, il = scope.__Frustum.length; i < il; i ++ ) scope.__Frustum[ i ]( Frustum );
        delete scope.__Frustum;
    }

}) ( NWE );


// src/math/Plane.js

( function ( scope ) {

    /**
     * @author bhouston / http://exocortex.com
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Matrix3 = NWE.Matrix3;
    if ( !Matrix3 ) { NWE.__Matrix3 = (NWE.__Matrix3 || []); NWE.__Matrix3.push( function ( obj ) { Matrix3 = obj; } ); }


    var Plane = function ( normal, constant ) {

        this.normal = ( normal !== undefined ) ? normal : new Vec3( 1, 0, 0 );
        this.constant = ( constant !== undefined ) ? constant : 0;

    };

    Plane.prototype = {

        constructor: Plane,

        set: function ( normal, constant ) {

            this.normal.copy( normal );
            this.constant = constant;

            return this;

        },

        setComponents: function ( x, y, z, w ) {

            this.normal.set( x, y, z );
            this.constant = w;

            return this;

        },

        setFromNormalAndCoplanarPoint: function ( normal, point ) {

            this.normal.copy( normal );
            this.constant = - point.dot( this.normal ); // must be this.normal, not normal, as this.normal is normalized

            return this;

        },

        setFromCoplanarPoints: function() {

            var v1 = new Vec3();
            var v2 = new Vec3();

            return function ( a, b, c ) {

                var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

                // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

                this.setFromNormalAndCoplanarPoint( normal, a );

                return this;

            };

        }(),


        copy: function ( plane ) {

            this.normal.copy( plane.normal );
            this.constant = plane.constant;

            return this;

        },

        normalize: function () {

            // Note: will lead to a divide by zero if the plane is invalid.

            var inverseNormalLength = 1.0 / this.normal.length();
            this.normal.multiplyScalar( inverseNormalLength );
            this.constant *= inverseNormalLength;

            return this;

        },

        negate: function () {

            this.constant *= -1;
            this.normal.negate();

            return this;

        },

        distanceToPoint: function ( point ) {

            return this.normal.dot( point ) + this.constant;

        },

        distanceToSphere: function ( sphere ) {

            return this.distanceToPoint( sphere.center ) - sphere.radius;

        },

        projectPoint: function ( point, optionalTarget ) {

            return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

        },

        orthoPoint: function ( point, optionalTarget ) {

            var perpendicularMagnitude = this.distanceToPoint( point );

            var result = optionalTarget || new Vec3();
            return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

        },

        isIntersectionLine: function ( line ) {

            // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

            var startSign = this.distanceToPoint( line.start );
            var endSign = this.distanceToPoint( line.end );

            return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

        },

        intersectLine: function() {

            var v1 = new Vec3();

            return function ( line, optionalTarget ) {

                var result = optionalTarget || new Vec3();

                var direction = line.delta( v1 );

                var denominator = this.normal.dot( direction );

                if ( denominator == 0 ) {

                    // line is coplanar, return origin
                    if( this.distanceToPoint( line.start ) == 0 ) {

                        return result.copy( line.start );

                    }

                    // Unsure if this is the correct method to handle this case.
                    return undefined;

                }

                var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

                if( t < 0 || t > 1 ) {

                    return undefined;

                }

                return result.copy( direction ).multiplyScalar( t ).add( line.start );

            };

        }(),


        coplanarPoint: function ( optionalTarget ) {

            var result = optionalTarget || new Vec3();
            return result.copy( this.normal ).multiplyScalar( - this.constant );

        },

        applyMatrix4: function() {

            var v1 = new Vec3();
            var v2 = new Vec3();

            return function ( matrix, optionalNormalMatrix ) {

                // compute new normal based on theory here:
                // http://www.songho.ca/opengl/gl_normaltransform.html
                optionalNormalMatrix = optionalNormalMatrix || new Matrix3().getNormalMatrix( matrix );
                var newNormal = v1.copy( this.normal ).applyMatrix3( optionalNormalMatrix );

                var newCoplanarPoint = this.coplanarPoint( v2 );
                newCoplanarPoint.applyMatrix4( matrix );

                this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

                return this;

            };

        }(),

        translate: function ( offset ) {

            this.constant = this.constant - offset.dot( this.normal );

            return this;

        },

        equals: function ( plane ) {

            return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

        },

        clone: function () {

            return new Plane().copy( this );

        }

    };

    if ( typeof Plane === 'function' ) {
        var t = {}, p = {};
        for ( var i in Plane ) t[i] = Plane[i];
        for ( var i in Plane.prototype ) try { p[i] = Plane.prototype[i] } catch(e) {};
        scope.Plane = Plane.bind( scope );
    } else {
        scope.Plane = Plane;
    }
    scope.Plane.prototype = Plane.prototype;
    for ( var i in t ) scope.Plane[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Plane.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Plane ) {
        for ( var i = 0, il = scope.__Plane.length; i < il; i ++ ) scope.__Plane[ i ]( Plane );
        delete scope.__Plane;
    }

}) ( NWE );


// src/math/Spline.js

( function ( scope ) {

    /**
     * Spline from Tween.js, slightly optimized (and trashed)
     * http://sole.github.com/tween.js/examples/05_spline.html
     *
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var Spline = function ( points ) {

        this.points = points;

        var c = [], v3 = { x: 0, y: 0, z: 0 },
        point, intPoint, weight, w2, w3,
        pa, pb, pc, pd;

        this.initFromArray = function( a ) {

            this.points = [];

            for ( var i = 0; i < a.length; i++ ) {

                this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

            }

        };

        this.getPoint = function ( k ) {

            point = ( this.points.length - 1 ) * k;
            intPoint = Math.floor( point );
            weight = point - intPoint;

            c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
            c[ 1 ] = intPoint;
            c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
            c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

            pa = this.points[ c[ 0 ] ];
            pb = this.points[ c[ 1 ] ];
            pc = this.points[ c[ 2 ] ];
            pd = this.points[ c[ 3 ] ];

            w2 = weight * weight;
            w3 = weight * w2;

            v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
            v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
            v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

            return v3;

        };

        this.getControlPointsArray = function () {

            var i, p, l = this.points.length,
                coords = [];

            for ( i = 0; i < l; i ++ ) {

                p = this.points[ i ];
                coords[ i ] = [ p.x, p.y, p.z ];

            }

            return coords;

        };

        // approximate length by summing linear segments

        this.getLength = function ( nSubDivisions ) {

            var i, index, nSamples, position,
                point = 0, intPoint = 0, oldIntPoint = 0,
                oldPosition = new Vec3(),
                tmpVec = new Vec3(),
                chunkLengths = [],
                totalLength = 0;

            // first point has 0 length

            chunkLengths[ 0 ] = 0;

            if ( !nSubDivisions ) nSubDivisions = 100;

            nSamples = this.points.length * nSubDivisions;

            oldPosition.copy( this.points[ 0 ] );

            for ( i = 1; i < nSamples; i ++ ) {

                index = i / nSamples;

                position = this.getPoint( index );
                tmpVec.copy( position );

                totalLength += tmpVec.distanceTo( oldPosition );

                oldPosition.copy( position );

                point = ( this.points.length - 1 ) * index;
                intPoint = Math.floor( point );

                if ( intPoint != oldIntPoint ) {

                    chunkLengths[ intPoint ] = totalLength;
                    oldIntPoint = intPoint;

                }

            }

            // last point ends with total length

            chunkLengths[ chunkLengths.length ] = totalLength;

            return { chunks: chunkLengths, total: totalLength };

        };

        this.reparametrizeByArcLength = function ( samplingCoef ) {

            var i, j,
                index, indexCurrent, indexNext,
                linearDistance, realDistance,
                sampling, position,
                newpoints = [],
                tmpVec = new Vec3(),
                sl = this.getLength();

            newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

            for ( i = 1; i < this.points.length; i++ ) {

                //tmpVec.copy( this.points[ i - 1 ] );
                //linearDistance = tmpVec.distanceTo( this.points[ i ] );

                realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

                sampling = Math.ceil( samplingCoef * realDistance / sl.total );

                indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
                indexNext = i / ( this.points.length - 1 );

                for ( j = 1; j < sampling - 1; j++ ) {

                    index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

                    position = this.getPoint( index );
                    newpoints.push( tmpVec.copy( position ).clone() );

                }

                newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

            }

            this.points = newpoints;

        };

        // Catmull-Rom

        function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

            var v0 = ( p2 - p0 ) * 0.5,
                v1 = ( p3 - p1 ) * 0.5;

            return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

        };

    };

    if ( typeof Spline === 'function' ) {
        var t = {}, p = {};
        for ( var i in Spline ) t[i] = Spline[i];
        for ( var i in Spline.prototype ) try { p[i] = Spline.prototype[i] } catch(e) {};
        scope.Spline = Spline.bind( scope );
    } else {
        scope.Spline = Spline;
    }
    scope.Spline.prototype = Spline.prototype;
    for ( var i in t ) scope.Spline[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Spline.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Spline ) {
        for ( var i = 0, il = scope.__Spline.length; i < il; i ++ ) scope.__Spline[ i ]( Spline );
        delete scope.__Spline;
    }

}) ( NWE );


// src/math/Triangle.js

( function ( scope ) {

    /**
     * @author bhouston / http://exocortex.com
     * @author mrdoob / http://mrdoob.com/
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Plane = NWE.Plane;
    if ( !Plane ) { NWE.__Plane = (NWE.__Plane || []); NWE.__Plane.push( function ( obj ) { Plane = obj; } ); }


    var Triangle = function ( a, b, c ) {

        this.a = ( a !== undefined ) ? a : new Vec3();
        this.b = ( b !== undefined ) ? b : new Vec3();
        this.c = ( c !== undefined ) ? c : new Vec3();

    };

    Triangle.normal = function() {

        var v0 = new Vec3();

        return function ( a, b, c, optionalTarget ) {

            var result = optionalTarget || new Vec3();

            result.subVectors( c, b );
            v0.subVectors( a, b );
            result.cross( v0 );

            var resultLengthSq = result.lengthSq();
            if( resultLengthSq > 0 ) {

                return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

            }

            return result.set( 0, 0, 0 );

        };

    }();

    // static/instance method to calculate barycoordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    Triangle.barycoordFromPoint = function() {

        var v0 = new Vec3();
        var v1 = new Vec3();
        var v2 = new Vec3();

        return function ( point, a, b, c, optionalTarget ) {

            v0.subVectors( c, a );
            v1.subVectors( b, a );
            v2.subVectors( point, a );

            var dot00 = v0.dot( v0 );
            var dot01 = v0.dot( v1 );
            var dot02 = v0.dot( v2 );
            var dot11 = v1.dot( v1 );
            var dot12 = v1.dot( v2 );

            var denom = ( dot00 * dot11 - dot01 * dot01 );

            var result = optionalTarget || new Vec3();

            // colinear or singular triangle
            if( denom == 0 ) {
                // arbitrary location outside of triangle?
                // not sure if this is the best idea, maybe should be returning undefined
                return result.set( -2, -1, -1 );
            }

            var invDenom = 1 / denom;
            var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
            var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

            // barycoordinates must always sum to 1
            return result.set( 1 - u - v, v, u );

        };

    }();

    Triangle.containsPoint = function() {

        var v1 = new Vec3();

        return function ( point, a, b, c ) {

            var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

            return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

        };

    }();

    Triangle.prototype = {

        constructor: Triangle,

        set: function ( a, b, c ) {

            this.a.copy( a );
            this.b.copy( b );
            this.c.copy( c );

            return this;

        },

        setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

            this.a.copy( points[i0] );
            this.b.copy( points[i1] );
            this.c.copy( points[i2] );

            return this;

        },

        copy: function ( triangle ) {

            this.a.copy( triangle.a );
            this.b.copy( triangle.b );
            this.c.copy( triangle.c );

            return this;

        },

        area: function() {

            var v0 = new Vec3();
            var v1 = new Vec3();

            return function () {

                v0.subVectors( this.c, this.b );
                v1.subVectors( this.a, this.b );

                return v0.cross( v1 ).length() * 0.5;

            };

        }(),

        midpoint: function ( optionalTarget ) {

            var result = optionalTarget || new Vec3();
            return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

        },

        normal: function ( optionalTarget ) {

            return Triangle.normal( this.a, this.b, this.c, optionalTarget );

        },

        plane: function ( optionalTarget ) {

            var result = optionalTarget || new Plane();

            return result.setFromCoplanarPoints( this.a, this.b, this.c );

        },

        barycoordFromPoint: function ( point, optionalTarget ) {

            return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

        },

        containsPoint: function ( point ) {

            return Triangle.containsPoint( point, this.a, this.b, this.c );

        },

        equals: function ( triangle ) {

            return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

        },

        clone: function () {

            return new Triangle().copy( this );

        }

    };

    if ( typeof Triangle === 'function' ) {
        var t = {}, p = {};
        for ( var i in Triangle ) t[i] = Triangle[i];
        for ( var i in Triangle.prototype ) try { p[i] = Triangle.prototype[i] } catch(e) {};
        scope.Triangle = Triangle.bind( scope );
    } else {
        scope.Triangle = Triangle;
    }
    scope.Triangle.prototype = Triangle.prototype;
    for ( var i in t ) scope.Triangle[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Triangle.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Triangle ) {
        for ( var i = 0, il = scope.__Triangle.length; i < il; i ++ ) scope.__Triangle[ i ]( Triangle );
        delete scope.__Triangle;
    }

}) ( NWE );


// src/graphics/Gfx.js

( function ( scope ) {

    /*
     * @author ohmed
    */



    // nothing here as for now

}) ( NWE.gfx );


// src/graphics/core/Const.js

( function ( scope ) {

    /*
     * @author ohmed
    */



    var Const = {

        Int8:       Int8Array,
        Uint8:      Uint8Array,
        Int16:      Int16Array,
        Uint16:     Uint16Array,
        Int32:      Int32Array,
        Uint32:     Uint32Array,
        Float32:    Float32Array,
        Float64:    Float64Array,

        // GL STATE CONSTANTS

        CullFaceNone:      0,
        CullFaceBack:      1,
        CullFaceFront:     2,
        CullFaceFrontBack: 3,

        FrontFaceDirectionCW:  0,
        FrontFaceDirectionCCW: 1,

        // MATERIAL CONSTANTS

        // side

        FrontSide:  0,
        BackSide:   1,
        DoubleSide: 2,

        // shading

        NoShading:     0,
        FlatShading:   1,
        SmoothShading: 2,

        // colors

        NoColors:     0,
        FaceColors:   1,
        VertexColors: 2,

        // blending modes

        NoBlending:          0,
        NormalBlending:      1,
        AdditiveBlending:    2,
        SubtractiveBlending: 3,
        MultiplyBlending:    4,
        CustomBlending:      5,

        // custom blending equations
        // (numbers start from 100 not to clash with other
        //  mappings to OpenGL constants defined in Texture.js)

        AddEquation:             100,
        SubtractEquation:        101,
        ReverseSubtractEquation: 102,

        // custom blending destination factors

        ZeroFactor:             200,
        OneFactor:              201,
        SrcColorFactor:         202,
        OneMinusSrcColorFactor: 203,
        SrcAlphaFactor:         204,
        OneMinusSrcAlphaFactor: 205,
        DstAlphaFactor:         206,
        OneMinusDstAlphaFactor: 207,

        // custom blending source factors

        //ZeroFactor:             200,
        //OneFactor:              201,
        //SrcAlphaFactor:         204,
        //OneMinusSrcAlphaFactor: 205,
        //DstAlphaFactor:         206,
        //OneMinusDstAlphaFactor: 207,
        DstColorFactor:         208,
        OneMinusDstColorFactor: 209,
        SrcAlphaSaturateFactor: 210,

        // TEXTURE CONSTANTS

        MultiplyOperation: 0,
        MixOperation:      1,
        AddOperation:      2,

        UVMapping:          function () {},

        // Wrapping modes

        RepeatWrapping:         1000,
        ClampToEdgeWrapping:    1001,
        MirroredRepeatWrapping: 1002,

        // Filters

        NearestFilter:              1003,
        NearestMipMapNearestFilter: 1004,
        NearestMipMapLinearFilter:  1005,
        LinearFilter:               1006,
        LinearMipMapNearestFilter:  1007,
        LinearMipMapLinearFilter:   1008,

        // Data types

        UnsignedByteType:  1009,
        ByteType:          1010,
        ShortType:         1011,
        UnsignedShortType: 1012,
        IntType:           1013,
        UnsignedIntType:   1014,
        FloatType:         1015,

        // Pixel types

        // UnsignedByteType:    1009;
        UnsignedShort4444Type: 1016,
        UnsignedShort5551Type: 1017,
        UnsignedShort565Type:  1018,

        // Pixel formats

        AlphaFormat:          1019,
        RGBFormat:            1020,
        RGBAFormat:           1021,
        LuminanceFormat:      1022,
        LuminanceAlphaFormat: 1023,

        // Compressed texture formats

        RGB_S3TC_DXT1_Format:  2001,
        RGBA_S3TC_DXT1_Format: 2002,
        RGBA_S3TC_DXT3_Format: 2003,
        RGBA_S3TC_DXT5_Format: 2004,

        /*
        // Potential future PVRTC compressed texture formats
        RGB_PVRTC_4BPPV1_Format:  2100,
        RGB_PVRTC_2BPPV1_Format:  2101,
        RGBA_PVRTC_4BPPV1_Format: 2102,
        RGBA_PVRTC_2BPPV1_Format: 2103,
        */

    };

    scope.Const = Const;
    if ( scope.__Const ) {
        for ( var i = 0, il = scope.__Const.length; i < il; i ++ ) scope.__Const[ i ]( Const );
        delete scope.__Const;
    }

}) ( NWE.gfx );


// src/graphics/core/Geometry.js

( function ( scope ) {

    /*
     * @author ohmed
    */



    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Sphere = NWE.Sphere;
    if ( !Sphere ) { NWE.__Sphere = (NWE.__Sphere || []); NWE.__Sphere.push( function ( obj ) { Sphere = obj; } ); }


    var Geometry = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        this.uuid = Math.generateUUID();
        internal[ this.uuid ] = objInternal;

        this.id = NWE.gfx.GeometryIdCount ++;
        this.name = params.name || '';

        // attributes

        this.attributes = {};
        internal[ this.uuid ].attributesList = [];

        // attributes typed arrays are kept only if dynamic flag is set

        this.dynamic = false;
        this.needsUpdate = false;

        // boundings

        this.boundingBox = null;
        this.boundingSphere = null;

        //

        this.instanceof = 'Geometry';

    };

    NWE.gfx.GeometryIdCount = 0;

    Geometry.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Geometry.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Geometry.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Geometry.setInternal = function ( name, value ) { internal[ name ] = value; };
    Geometry.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Geometry === 'function' ) {
        var t = {}, p = {};
        for ( var i in Geometry ) t[i] = Geometry[i];
        for ( var i in Geometry.prototype ) try { p[i] = Geometry.prototype[i] } catch(e) {};
        scope.Geometry = Geometry.bind( scope );
    } else {
        scope.Geometry = Geometry;
    }
    internal['constructor'] = Geometry;
    scope.Geometry.prototype = Geometry.prototype;
    for ( var i in t ) scope.Geometry[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Geometry.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Geometry ) {
        for ( var i = 0, il = scope.__Geometry.length; i < il; i ++ ) scope.__Geometry[ i ]( Geometry );
        delete scope.__Geometry;
    }

}) ( NWE.gfx );


// src/graphics/core/BufferAttribute.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var BufferAttribute = function () {};

    BufferAttribute.prototype = {

        constructor: BufferAttribute,

        get length () {

            return this.array.length;

        },

        set: function ( value ) {

            this.array.set( value );

        },

        setX: function ( index, x ) {

            this.array[ index * this.itemSize + 0 ] = x;

        },

        setY: function ( index, y ) {

            this.array[ index * this.itemSize + 1 ] = y;

        },

        setZ: function ( index, z ) {

            this.array[ index * this.itemSize + 2 ] = z;

        },

        setXY: function ( index, x, y ) {

            index *= this.itemSize;

            this.array[ index + 0 ] = x;
            this.array[ index + 1 ] = y;

        },

        setXYZ: function ( index, x, y, z ) {

            index *= this.itemSize;

            this.array[ index + 0 ] = x;
            this.array[ index + 1 ] = y;
            this.array[ index + 2 ] = z;

        },

        setXYZW: function ( index, x, y, z, w ) {

            index *= this.itemSize;

            this.array[ index + 0 ] = x;
            this.array[ index + 1 ] = y;
            this.array[ index + 2 ] = z;
            this.array[ index + 3 ] = w;

        }

    };

    //

    var Int8Attribute = function ( source, size, itemSize, offsetBytes ) {

        if ( source && offsetBytes !== undefined ) {

            this.array = new Int8Array( source, offsetBytes, size * itemSize );
            this.byteSize = Int8Array.BYTES_PER_ELEMENT * size * itemSize;

        } else {

            this.array = new Int8Array( size * itemSize );

        }

        this.itemSize = itemSize;

    };
    Int8Attribute.prototype = Object.create( BufferAttribute.prototype );

    //

    var Uint8Attribute = function ( source, size, itemSize, offsetBytes ) {

        if ( source && offsetBytes !== undefined ) {

            this.array = new Uint8Array( source, offsetBytes, size * itemSize );
            this.byteSize = Uint8Array.BYTES_PER_ELEMENT * size * itemSize;

        } else {

            this.array = new Uint8Array( size * itemSize );

        }

        this.itemSize = itemSize;

    };
    Uint8Attribute.prototype = Object.create( BufferAttribute.prototype );

    //

    var Uint8ClampedAttribute = function ( source, size, itemSize, offsetBytes ) {

        if ( source && offsetBytes !== undefined ) {

            this.array = new Uint8ClampedArray( source, offsetBytes, size * itemSize );
            this.byteSize = Uint8ClampedArray.BYTES_PER_ELEMENT * size * itemSize;

        } else {

            this.array = new Uint8ClampedArray( size * itemSize );

        }

        this.itemSize = itemSize;

    };
    Uint8ClampedAttribute.prototype = Object.create( BufferAttribute.prototype );

    //

    var Int16Attribute = function ( source, size, itemSize, offsetBytes ) {

        if ( source && offsetBytes !== undefined ) {

            this.array = new Int16Array( source, offsetBytes, size * itemSize );
            this.byteSize = Int16Array.BYTES_PER_ELEMENT * size * itemSize;

        } else {

            this.array = new Int16Array( size * itemSize );

        }

        this.itemSize = itemSize;

    };
    Int16Attribute.prototype = Object.create( BufferAttribute.prototype );

    //

    var Uint16Attribute = function ( source, size, itemSize, offsetBytes ) {

        if ( source && offsetBytes !== undefined ) {

            this.array = new Uint16Array( source, offsetBytes, size * itemSize );
            this.byteSize = Uint16Array.BYTES_PER_ELEMENT * size * itemSize;

        } else {

            this.array = new Uint16Array( size * itemSize );

        }

        this.itemSize = itemSize;

    };
    Uint16Attribute.prototype = Object.create( BufferAttribute.prototype );

    //

    var Int32Attribute = function ( source, size, itemSize, offsetBytes ) {

        if ( source && offsetBytes !== undefined ) {

            this.array = new Int32Array( source, offsetBytes, size * itemSize );
            this.byteSize = Int32Array.BYTES_PER_ELEMENT * size * itemSize;

        } else {

            this.array = new Int32Array( size * itemSize );

        }

        this.itemSize = itemSize;

    };
    Int32Attribute.prototype = Object.create( BufferAttribute.prototype );

    //

    var Uint32Attribute = function ( source, size, itemSize, offsetBytes ) {

        if ( source && offsetBytes !== undefined ) {

            this.array = new Uint32Array( source, offsetBytes, size * itemSize );
            this.byteSize = Uint32Array.BYTES_PER_ELEMENT * size * itemSize;

        } else {

            this.array = new Uint32Array( size * itemSize );

        }

        this.itemSize = itemSize;

    };
    Uint32Attribute.prototype = Object.create( BufferAttribute.prototype );

    //

    var Float32Attribute = function ( source, size, itemSize, offsetBytes ) {

        if ( source && offsetBytes !== undefined ) {

            this.array = new Float32Array( source, offsetBytes, size * itemSize );
            this.byteSize = Float32Array.BYTES_PER_ELEMENT * size * itemSize;

        } else {

            this.array = new Float32Array( size * itemSize );

        }

        this.itemSize = itemSize;

    };
    Float32Attribute.prototype = Object.create( BufferAttribute.prototype );

    //

    var Float64Attribute = function ( source, size, itemSize, offsetBytes ) {

        if ( source && offsetBytes !== undefined ) {

            this.array = new Float64Array( source, offsetBytes, size * itemSize );
            this.byteSize = Float64Array.BYTES_PER_ELEMENT * size * itemSize;

        } else {

            this.array = new Float64Array( size * itemSize );

        }

        this.itemSize = itemSize;

    };
    Float64Attribute.prototype = Object.create( BufferAttribute.prototype );

    if ( typeof Int8Attribute === 'function' ) {
        var t = {}, p = {};
        for ( var i in Int8Attribute ) t[i] = Int8Attribute[i];
        for ( var i in Int8Attribute.prototype ) try { p[i] = Int8Attribute.prototype[i] } catch(e) {};
        scope.Int8Attribute = Int8Attribute.bind( scope );
    } else {
        scope.Int8Attribute = Int8Attribute;
    }
    scope.Int8Attribute.prototype = Int8Attribute.prototype;
    for ( var i in t ) scope.Int8Attribute[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Int8Attribute.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Int8Attribute ) {
        for ( var i = 0, il = scope.__Int8Attribute.length; i < il; i ++ ) scope.__Int8Attribute[ i ]( Int8Attribute );
        delete scope.__Int8Attribute;
    }

    if ( typeof Uint8Attribute === 'function' ) {
        var t = {}, p = {};
        for ( var i in Uint8Attribute ) t[i] = Uint8Attribute[i];
        for ( var i in Uint8Attribute.prototype ) try { p[i] = Uint8Attribute.prototype[i] } catch(e) {};
        scope.Uint8Attribute = Uint8Attribute.bind( scope );
    } else {
        scope.Uint8Attribute = Uint8Attribute;
    }
    scope.Uint8Attribute.prototype = Uint8Attribute.prototype;
    for ( var i in t ) scope.Uint8Attribute[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Uint8Attribute.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Uint8Attribute ) {
        for ( var i = 0, il = scope.__Uint8Attribute.length; i < il; i ++ ) scope.__Uint8Attribute[ i ]( Uint8Attribute );
        delete scope.__Uint8Attribute;
    }

    if ( typeof Uint8ClampedAttribute === 'function' ) {
        var t = {}, p = {};
        for ( var i in Uint8ClampedAttribute ) t[i] = Uint8ClampedAttribute[i];
        for ( var i in Uint8ClampedAttribute.prototype ) try { p[i] = Uint8ClampedAttribute.prototype[i] } catch(e) {};
        scope.Uint8ClampedAttribute = Uint8ClampedAttribute.bind( scope );
    } else {
        scope.Uint8ClampedAttribute = Uint8ClampedAttribute;
    }
    scope.Uint8ClampedAttribute.prototype = Uint8ClampedAttribute.prototype;
    for ( var i in t ) scope.Uint8ClampedAttribute[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Uint8ClampedAttribute.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Uint8ClampedAttribute ) {
        for ( var i = 0, il = scope.__Uint8ClampedAttribute.length; i < il; i ++ ) scope.__Uint8ClampedAttribute[ i ]( Uint8ClampedAttribute );
        delete scope.__Uint8ClampedAttribute;
    }

    if ( typeof Int16Attribute === 'function' ) {
        var t = {}, p = {};
        for ( var i in Int16Attribute ) t[i] = Int16Attribute[i];
        for ( var i in Int16Attribute.prototype ) try { p[i] = Int16Attribute.prototype[i] } catch(e) {};
        scope.Int16Attribute = Int16Attribute.bind( scope );
    } else {
        scope.Int16Attribute = Int16Attribute;
    }
    scope.Int16Attribute.prototype = Int16Attribute.prototype;
    for ( var i in t ) scope.Int16Attribute[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Int16Attribute.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Int16Attribute ) {
        for ( var i = 0, il = scope.__Int16Attribute.length; i < il; i ++ ) scope.__Int16Attribute[ i ]( Int16Attribute );
        delete scope.__Int16Attribute;
    }

    if ( typeof Uint16Attribute === 'function' ) {
        var t = {}, p = {};
        for ( var i in Uint16Attribute ) t[i] = Uint16Attribute[i];
        for ( var i in Uint16Attribute.prototype ) try { p[i] = Uint16Attribute.prototype[i] } catch(e) {};
        scope.Uint16Attribute = Uint16Attribute.bind( scope );
    } else {
        scope.Uint16Attribute = Uint16Attribute;
    }
    scope.Uint16Attribute.prototype = Uint16Attribute.prototype;
    for ( var i in t ) scope.Uint16Attribute[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Uint16Attribute.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Uint16Attribute ) {
        for ( var i = 0, il = scope.__Uint16Attribute.length; i < il; i ++ ) scope.__Uint16Attribute[ i ]( Uint16Attribute );
        delete scope.__Uint16Attribute;
    }

    if ( typeof Int32Attribute === 'function' ) {
        var t = {}, p = {};
        for ( var i in Int32Attribute ) t[i] = Int32Attribute[i];
        for ( var i in Int32Attribute.prototype ) try { p[i] = Int32Attribute.prototype[i] } catch(e) {};
        scope.Int32Attribute = Int32Attribute.bind( scope );
    } else {
        scope.Int32Attribute = Int32Attribute;
    }
    scope.Int32Attribute.prototype = Int32Attribute.prototype;
    for ( var i in t ) scope.Int32Attribute[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Int32Attribute.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Int32Attribute ) {
        for ( var i = 0, il = scope.__Int32Attribute.length; i < il; i ++ ) scope.__Int32Attribute[ i ]( Int32Attribute );
        delete scope.__Int32Attribute;
    }

    if ( typeof Uint32Attribute === 'function' ) {
        var t = {}, p = {};
        for ( var i in Uint32Attribute ) t[i] = Uint32Attribute[i];
        for ( var i in Uint32Attribute.prototype ) try { p[i] = Uint32Attribute.prototype[i] } catch(e) {};
        scope.Uint32Attribute = Uint32Attribute.bind( scope );
    } else {
        scope.Uint32Attribute = Uint32Attribute;
    }
    scope.Uint32Attribute.prototype = Uint32Attribute.prototype;
    for ( var i in t ) scope.Uint32Attribute[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Uint32Attribute.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Uint32Attribute ) {
        for ( var i = 0, il = scope.__Uint32Attribute.length; i < il; i ++ ) scope.__Uint32Attribute[ i ]( Uint32Attribute );
        delete scope.__Uint32Attribute;
    }

    if ( typeof Float32Attribute === 'function' ) {
        var t = {}, p = {};
        for ( var i in Float32Attribute ) t[i] = Float32Attribute[i];
        for ( var i in Float32Attribute.prototype ) try { p[i] = Float32Attribute.prototype[i] } catch(e) {};
        scope.Float32Attribute = Float32Attribute.bind( scope );
    } else {
        scope.Float32Attribute = Float32Attribute;
    }
    scope.Float32Attribute.prototype = Float32Attribute.prototype;
    for ( var i in t ) scope.Float32Attribute[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Float32Attribute.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Float32Attribute ) {
        for ( var i = 0, il = scope.__Float32Attribute.length; i < il; i ++ ) scope.__Float32Attribute[ i ]( Float32Attribute );
        delete scope.__Float32Attribute;
    }

    if ( typeof Float64Attribute === 'function' ) {
        var t = {}, p = {};
        for ( var i in Float64Attribute ) t[i] = Float64Attribute[i];
        for ( var i in Float64Attribute.prototype ) try { p[i] = Float64Attribute.prototype[i] } catch(e) {};
        scope.Float64Attribute = Float64Attribute.bind( scope );
    } else {
        scope.Float64Attribute = Float64Attribute;
    }
    scope.Float64Attribute.prototype = Float64Attribute.prototype;
    for ( var i in t ) scope.Float64Attribute[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Float64Attribute.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Float64Attribute ) {
        for ( var i = 0, il = scope.__Float64Attribute.length; i < il; i ++ ) scope.__Float64Attribute[ i ]( Float64Attribute );
        delete scope.__Float64Attribute;
    }

}) ( NWE.gfx );


// src/graphics/core/BufferGeometry.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Box3 = NWE.Box3;
    if ( !Box3 ) { NWE.__Box3 = (NWE.__Box3 || []); NWE.__Box3.push( function ( obj ) { Box3 = obj; } ); }

    var Matrix3 = NWE.Matrix3;
    if ( !Matrix3 ) { NWE.__Matrix3 = (NWE.__Matrix3 || []); NWE.__Matrix3.push( function ( obj ) { Matrix3 = obj; } ); }

    var Sphere = NWE.Sphere;
    if ( !Sphere ) { NWE.__Sphere = (NWE.__Sphere || []); NWE.__Sphere.push( function ( obj ) { Sphere = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }

    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var DeviceCapabilities = NWE.gfx.DeviceCapabilities;
    if ( !DeviceCapabilities ) { NWE.gfx.__DeviceCapabilities = (NWE.gfx.__DeviceCapabilities || []); NWE.gfx.__DeviceCapabilities.push( function ( obj ) { DeviceCapabilities = obj; } ); }

    var Geometry = NWE.gfx.Geometry;
    if ( !Geometry ) { NWE.gfx.__Geometry = (NWE.gfx.__Geometry || []); NWE.gfx.__Geometry.push( function ( obj ) { Geometry = obj; } ); }


    var BufferGeometry = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Geometry.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.numVertices = params.vertCount || 0;
        this.numTriangles = params.trisCount || 0;
        this.numPoints = params.pointsCount || 0;

        // offsets for chunks when using indexed elements

        this.offsets = [];

        // for addAttribute method

        this.blockSize = 0;
        this.vertexByteSize = 0;

        //

        internal[ this.uuid ].usedVertices = 0;
        internal[ this.uuid ].usedFaces = 0;
        internal[ this.uuid ].chunks = [];

        //

        internal[ this.uuid ].vertices = this.numVertices;
        internal[ this.uuid ].triangles = this.numTriangles;
        internal[ this.uuid ].points = this.numPoints;

        //

        this.instanceof = 'DirrectBuffers';
        this.type = 'Basic';

    };

    BufferGeometry.prototype = Object.create( Geometry.prototype );

    BufferGeometry.prototype.addPart = function ( geometry, materials ) {

        // todo

    };

    BufferGeometry.prototype.computeChunkOffsets = function () {

        var chunks = internal[ this.uuid ].chunks,

            triangles = 0,
            vertices = 0,
            points = 0,

            i, il;

        chunks.push({

            triangles: internal[ this.uuid ].triangles,
            vertices: internal[ this.uuid ].vertices,
            points: internal[ this.uuid ].points

        });

        for ( i = 0, il = chunks.length; i < il; i ++ ) {

            this.offsets.push({

                start: ( ! internal[ this.uuid ].points ) ? 3 * triangles : points,
                index: vertices,
                count: ( ! internal[ this.uuid ].points ) ? 3 * chunks[ i ].triangles : chunks[ i ].points

            });

            triangles += chunks[ i ].triangles;
            vertices  += chunks[ i ].vertices;
            points    += chunks[ i ].points;

        }

    };

    BufferGeometry.prototype.setVertexColor = function ( color ) {

        var attribute = this.addAttribute( 'color', 3 );

        for ( var i = 0, il = attribute.array.length; i < il; i += 3 ) {

            attribute.array[ i + 0 ] = color.r;
            attribute.array[ i + 1 ] = color.g;
            attribute.array[ i + 2 ] = color.b;

        }

    };

    BufferGeometry.prototype.addAttribute = function ( name, itemSize, AttrType ) {

        if ( ! name ) {

            return Logger.warn( 'NWE.gfx.BufferGeometry.addAttribute(): Undefined name for attribute.' );

        }

        var attribute;

        if ( name === 'index' ) {

            // setup geometry index

            AttrType = AttrType || Const.Uint16;

            if ( itemSize > 64000 ) AttrType = Const.Uint32;

            if ( AttrType === Const.Uint32 && ! DeviceCapabilities.supportsIndexUINT() ) {

                return Logger.warn( 'NWE.gfx.BufferGeometry.addAttribute(): Geometry index type (Uint32) not supported.' );

            }

            attribute = {

                itemSize: 1,
                numItems: itemSize,
                type: AttrType,
                rawType: AttrType,
                array: new AttrType( itemSize ),
                needsUpdate: true

            };

        } else {

            // other attributes

            if ( ! itemSize ) {

                return Logger.warn( 'NWE.gfx.BufferGeometry.addAttribute(): Undefined size for "' + name + '" attribute.' );

            }

            AttrType = AttrType || Const.Float32;

            attribute = {

                itemSize: itemSize,
                numItems: itemSize * this.numVertices,
                type:     Const.FloatType,
                rawType:  AttrType,
                array:    new AttrType( itemSize * this.numVertices ),
                needsUpdate: true

            };

            // update vertex size in bytes

            this.vertexByteSize += itemSize * Float32Array.BYTES_PER_ELEMENT;

        }

        this.attributes[ name ] = attribute;
        internal[ this.uuid ].attributesList.push( [ name, attribute ] );

        return attribute;

    };

    BufferGeometry.prototype.fillAttribute = function ( name, inputAttribute ) {

        // todo

    };

    BufferGeometry.prototype.getAttribute = function ( name ) {

        if ( ! this.attributes[ name ] ) {

            Logger.warn( 'NWE.gfx.BufferGeometry.getAttribute(): Attribute "' + name + '" not found.' );
            return false;

        }

        return this.attributes[ name ];

    };

    BufferGeometry.prototype.applyMatrix = function ( matrix ) {

        var position = this.attributes['position'];
        var normal = this.attributes['normal'];

        if ( position ) {

            if ( !! position.array ) {

                matrix.multiplyVec3Array( position.array );
                this.verticesneedsUpdate = true;

            } else if ( position.array === null ) {

                return Logger.error( 'NWE.gfx.BufferGeometry.applyMatrix(): This geometry is not dynamic, transform it before adding to scene.' );

            }

        }

        if ( normal ) {

            if ( !! normal.array ) {

                var normalMatrix = new Matrix3().getNormalMatrix( matrix );

                normalMatrix.multiplyVec3Array( normal.array );

                this.normalizeNormals();

                this.normalsneedsUpdate = true;

            } else if ( normal.array === null ) {

                return Logger.error( 'NWE.gfx.BufferGeometry.applyMatrix(): This geometry is not dynamic, transform it before adding to scene.' );

            }

        }

    };

    BufferGeometry.prototype.computeBoundingBox = function () {

        if ( this.boundingBox === null ) {

            this.boundingBox = new Box3();

        }

        var positions = this.attributes['position'].array;

        if ( positions ) {

            var bb = this.boundingBox;
            var x, y, z;

            if ( positions.length >= 3 ) {
                bb.min.x = bb.max.x = positions[ 0 ];
                bb.min.y = bb.max.y = positions[ 1 ];
                bb.min.z = bb.max.z = positions[ 2 ];
            }

            for ( var i = 3, il = positions.length; i < il; i += 3 ) {

                x = positions[ i ];
                y = positions[ i + 1 ];
                z = positions[ i + 2 ];

                // bounding box

                if ( x < bb.min.x ) {

                    bb.min.x = x;

                } else if ( x > bb.max.x ) {

                    bb.max.x = x;

                }

                if ( y < bb.min.y ) {

                    bb.min.y = y;

                } else if ( y > bb.max.y ) {

                    bb.max.y = y;

                }

                if ( z < bb.min.z ) {

                    bb.min.z = z;

                } else if ( z > bb.max.z ) {

                    bb.max.z = z;

                }

            }

        }

        if ( positions === undefined || positions.length === 0 ) {

            this.boundingBox.min.set( 0, 0, 0 );
            this.boundingBox.max.set( 0, 0, 0 );

        }

    };

    BufferGeometry.prototype.computeBoundingSphere = function () {

        var box = new Box3();
        var vector = new Vec3();

        return function () {

            if ( this.boundingSphere === null ) {

                this.boundingSphere = new Sphere();

            }

            var positions = this.attributes['position'].array;

            if ( positions ) {

                box.makeEmpty();

                var center = this.boundingSphere.center;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
                    box.expandByPoint( vector );

                }

                box.center( center );

                // hoping to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

                var maxRadiusSq = 0;

                for ( var i = 0, il = positions.length; i < il; i += 3 ) {

                    vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
                    maxRadiusSq = window.Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

                }

                this.boundingSphere.radius = window.Math.sqrt( maxRadiusSq );

                if ( isNaN( this.boundingSphere.radius ) ) {

                    Logger.error( 'NWE.gfx.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );

                }

            }

        }

    }();

    BufferGeometry.prototype.computeVertexNormals = function () {

        if ( this.attributes['position'] ) {

            var i, il;
            var j, jl;

            var nVertexElements = this.attributes['position'].array.length;

            if ( this.attributes['normal'] === undefined ) {

                this.attributes['normal'] = {

                    itemSize: 3,
                    array: new Float32Array( nVertexElements )

                };

            } else {

                // reset existing normals to zero

                for ( i = 0, il = this.attributes['normal'].array.length; i < il; i ++ ) {

                    this.attributes['normal'].array[ i ] = 0;

                }

            }

            var positions = this.attributes['position'].array;
            var normals = this.attributes['normal'].array;

            var vA, vB, vC, x, y, z,

            pA = new Vec3(),
            pB = new Vec3(),
            pC = new Vec3(),

            cb = new Vec3(),
            ab = new Vec3();

            // indexed elements

            if ( this.attributes['index'] ) {

                var indices = this.attributes['index'].array,

                    offsets = this.offsets,
                    start, count, index;

                for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

                    start = offsets[ j ].start;
                    count = offsets[ j ].count;
                    index = offsets[ j ].index;

                    for ( i = start, il = start + count; i < il; i += 3 ) {

                        vA = index + indices[ i ];
                        vB = index + indices[ i + 1 ];
                        vC = index + indices[ i + 2 ];

                        x = positions[ vA * 3 ];
                        y = positions[ vA * 3 + 1 ];
                        z = positions[ vA * 3 + 2 ];
                        pA.set( x, y, z );

                        x = positions[ vB * 3 ];
                        y = positions[ vB * 3 + 1 ];
                        z = positions[ vB * 3 + 2 ];
                        pB.set( x, y, z );

                        x = positions[ vC * 3 ];
                        y = positions[ vC * 3 + 1 ];
                        z = positions[ vC * 3 + 2 ];
                        pC.set( x, y, z );

                        cb.subVectors( pC, pB );
                        ab.subVectors( pA, pB );
                        cb.cross( ab );

                        normals[ vA * 3 ]     += cb.x;
                        normals[ vA * 3 + 1 ] += cb.y;
                        normals[ vA * 3 + 2 ] += cb.z;

                        normals[ vB * 3 ]     += cb.x;
                        normals[ vB * 3 + 1 ] += cb.y;
                        normals[ vB * 3 + 2 ] += cb.z;

                        normals[ vC * 3 ]     += cb.x;
                        normals[ vC * 3 + 1 ] += cb.y;
                        normals[ vC * 3 + 2 ] += cb.z;

                    }

                }

            // non-indexed elements (unconnected triangle soup)

            } else {

                for ( i = 0, il = positions.length; i < il; i += 9 ) {

                    x = positions[ i ];
                    y = positions[ i + 1 ];
                    z = positions[ i + 2 ];
                    pA.set( x, y, z );

                    x = positions[ i + 3 ];
                    y = positions[ i + 4 ];
                    z = positions[ i + 5 ];
                    pB.set( x, y, z );

                    x = positions[ i + 6 ];
                    y = positions[ i + 7 ];
                    z = positions[ i + 8 ];
                    pC.set( x, y, z );

                    cb.subVectors( pC, pB );
                    ab.subVectors( pA, pB );
                    cb.cross( ab );

                    normals[ i ]     = cb.x;
                    normals[ i + 1 ] = cb.y;
                    normals[ i + 2 ] = cb.z;

                    normals[ i + 3 ] = cb.x;
                    normals[ i + 4 ] = cb.y;
                    normals[ i + 5 ] = cb.z;

                    normals[ i + 6 ] = cb.x;
                    normals[ i + 7 ] = cb.y;
                    normals[ i + 8 ] = cb.z;

                }

            }

            this.normalizeNormals();

            this.normalsneedsUpdate = true;

        }

    };

    BufferGeometry.prototype.normalizeNormals = function () {

        var normals = this.attributes['normal'].array;

        var x, y, z, n;

        for ( var i = 0, il = normals.length; i < il; i += 3 ) {

            x = normals[ i ];
            y = normals[ i + 1 ];
            z = normals[ i + 2 ];

            n = 1.0 / window.Math.sqrt( x * x + y * y + z * z );

            normals[ i ]     *= n;
            normals[ i + 1 ] *= n;
            normals[ i + 2 ] *= n;

        }

    };

    BufferGeometry.prototype.clone = function () {

        var geometry = new BufferGeometry(),

            types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ],

            attr, type,
            sourceAttr, sourceArray, attribute, offset,

            i, il;

        for ( attr in this.attributes ) {

            sourceAttr = this.attributes[ attr ];
            sourceArray = sourceAttr.array;

            attribute = {

                itemSize: sourceAttr.itemSize,
                numItems: sourceAttr.numItems,
                type:     sourceAttr.type,
                array:    null

            };

            for ( i = 0, il = types.length; i < il; i ++ ) {

                type = types[ i ];

                if ( sourceArray instanceof type ) {

                    attribute.array = new type( sourceArray );
                    break;

                }

            }

            geometry.attributes[ attr ] = attribute;

        }

        //

        geometry.setInternal( 'vertices', this.numVertices );
        geometry.setInternal( 'triangles', this.numTriangles );
        geometry.setInternal( 'points', this.numPoints );

        geometry.numVertices = this.numVertices;
        geometry.numTriangles = this.numTriangles;
        geometry.numPoints = this.numPoints;

        geometry.vertexByteSize = this.vertexByteSize;

        //

        var attrList = internal[ this.uuid ].attributesList;
        var attrListNew = [];

        for ( var i = 0, il = attrList.length; i < il; i ++ ) {

            attrListNew.push( [ attrList[ i ][ 0 ], geometry.attributes[ attrList[ i ][ 0 ] ] ] );

        }

        geometry.setInternal( 'attributesList', attrListNew );

        //

        for ( i = 0, il = this.offsets.length; i < il; i ++ ) {

            offset = this.offsets[ i ];

            geometry.offsets.push( {

                start: offset.start,
                index: offset.index,
                count: offset.count

            } );

        }

        return geometry;

    };

    BufferGeometry.prototype.dispose = function () {

        this.dispatchEvent( { type: 'dispose' } );

    };

    //

    BufferGeometry.merge = function ( geometryList ) {

        var geo;
        var resultGeo;

        var numVertices = 0;
        var numTriangles = 0;
        var numPoints = 0;

        var attributes = {};
        var geoAttributes;
        var attribute;
        var attributeName;

        // gether attributes options

        for ( var i = 0, il = geometryList.length; i < il; i ++ ) {

            geo = geometryList[ i ];

            if ( geo.instanceof !== 'DirrectBuffers' && geo.type === 'Basic' ) {

                Logger.error( 'NWE.gfx.BufferGeometry.merge(): all geometries in geometryList need to have `BufferGeometry` type.' );
                return false;

            }

            geoAttributes = geo.getInternal( 'attributesList' );

            for ( var j = 0, jl = geoAttributes.length; j < jl; j ++ ) {

                attribute = geoAttributes[ j ];

                if ( ! attributes[ attribute[ 0 ] ] ) {

                    attributes[ attribute[ 0 ] ] = {

                        type: attribute[ 1 ].type,
                        itemSize: attribute[ 1 ].itemSize,
                        numItems: attribute[ 1 ].numItems,
                        currentOffset: 0

                    };

                } else {

                    attributes[ attribute[ 0 ] ].numItems += attribute[ 1 ].numItems;

                }

            }

            numVertices += geo.numVertices;
            numTriangles += geo.numTriangles;
            numPoints += geo.numPoints;

        }

        // create basae geo with attributes

        resultGeo = new BufferGeometry({ vertCount: numVertices, trisCount: numTriangles, pointsCount: numPoints });

        for ( var name in attributes ) {

            attribute = attributes[ name ];

            if ( name !== 'index' ) {

                resultGeo.addAttribute( name, attribute.itemSize, attribute.rawType );

            } else {

                resultGeo.addAttribute( name, attribute.numItems );

            }

        }

        // fill up attributes

        var attributeArray;
        var sourceArray;
        var offset;
        var valueOffset;

        for ( var i = 0, il = geometryList.length; i < il; i ++ ) {

            geo = geometryList[ i ];

            geoAttributes = geo.getInternal( 'attributesList' );

            for ( var j = 0, jl = geoAttributes.length; j < jl; j ++ ) {

                attributeName = geoAttributes[ j ][ 0 ];
                attribute = geo.attributes[ attributeName ];

                if ( ! geo.attributes[ geoAttributes[ j ][ 0 ] ].array ) {

                    Logger.warn( 'NWE.gfx.BufferGeometry.merge(): Merging geometry [' + geo.uuid + '] input mast have raw attribute array data.' );
                    continue;

                }

                sourceArray = attribute.array;
                attributeArray = resultGeo.attributes[ attributeName ].array;
                offset = attributes[ attributeName ].currentOffset;

                valueOffset = ( geoAttributes[ j ][ 0 ] === 'index' ) ? attributes[ 'position' ].currentOffset / 3 : 0;

                for ( var k = 0, kl = sourceArray.length; k < kl; k ++ ) {

                    attributeArray[ offset + k ] = sourceArray[ k ] + valueOffset;

                }

                attributes[ attributeName ].currentOffset += sourceArray.length;

            }

        }

        resultGeo.computeChunkOffsets();
        resultGeo.computeBoundingBox();

        //

        return resultGeo;

    };

    EventDispatcher.prototype.apply( BufferGeometry.prototype );

    BufferGeometry.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    BufferGeometry.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    BufferGeometry.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    BufferGeometry.setInternal = function ( name, value ) { internal[ name ] = value; };
    BufferGeometry.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof BufferGeometry === 'function' ) {
        var t = {}, p = {};
        for ( var i in BufferGeometry ) t[i] = BufferGeometry[i];
        for ( var i in BufferGeometry.prototype ) try { p[i] = BufferGeometry.prototype[i] } catch(e) {};
        scope.BufferGeometry = BufferGeometry.bind( scope );
    } else {
        scope.BufferGeometry = BufferGeometry;
    }
    internal['constructor'] = BufferGeometry;
    scope.BufferGeometry.prototype = BufferGeometry.prototype;
    for ( var i in t ) scope.BufferGeometry[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.BufferGeometry.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__BufferGeometry ) {
        for ( var i = 0, il = scope.__BufferGeometry.length; i < il; i ++ ) scope.__BufferGeometry[ i ]( BufferGeometry );
        delete scope.__BufferGeometry;
    }

}) ( NWE.gfx );


// src/graphics/core/LayoutBufferGeometry.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Box3 = NWE.Box3;
    if ( !Box3 ) { NWE.__Box3 = (NWE.__Box3 || []); NWE.__Box3.push( function ( obj ) { Box3 = obj; } ); }

    var Matrix3 = NWE.Matrix3;
    if ( !Matrix3 ) { NWE.__Matrix3 = (NWE.__Matrix3 || []); NWE.__Matrix3.push( function ( obj ) { Matrix3 = obj; } ); }

    var Sphere = NWE.Sphere;
    if ( !Sphere ) { NWE.__Sphere = (NWE.__Sphere || []); NWE.__Sphere.push( function ( obj ) { Sphere = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }

    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Geometry = NWE.gfx.Geometry;
    if ( !Geometry ) { NWE.gfx.__Geometry = (NWE.gfx.__Geometry || []); NWE.gfx.__Geometry.push( function ( obj ) { Geometry = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var DeviceCapabilities = NWE.gfx.DeviceCapabilities;
    if ( !DeviceCapabilities ) { NWE.gfx.__DeviceCapabilities = (NWE.gfx.__DeviceCapabilities || []); NWE.gfx.__DeviceCapabilities.push( function ( obj ) { DeviceCapabilities = obj; } ); }


    var LayoutBufferGeometry = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Geometry.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.numVertices = params.vertCount || 0;
        this.numTriangles = params.trisCount || 0;

        // offsets for chunks when using indexed elements

        this.offsets = [];

        // for addAtribute method

        this.blockSize = 0;
        this.vertexByteSize = 0;

        //

        internal[ this.uuid ].usedVertices = 0;
        internal[ this.uuid ].usedFaces = 0;
        internal[ this.uuid ].chunks = [];

        //

        internal[ this.uuid ].vertices = this.numVertices;
        internal[ this.uuid ].triangles = this.numTriangles;

        //

        this.array = null;

        this.instanceof = 'DirrectBuffers';
        this.type = 'Layout';

    };

    LayoutBufferGeometry.prototype = Object.create( Geometry.prototype );

    LayoutBufferGeometry.prototype.addPart = function ( rawGeometry, params ) {

        var vertices = internal[ this.uuid ].vertices,
            triangles = internal[ this.uuid ].triangles,

            attributes = this.attributes,

            offset = this.blockSize,
            tIndexName, tIndex,

            chunks = internal[ this.uuid ].chunks;

        // count chank sizes if needs

        if ( vertices + rawGeometry.vertices > window.Math.pow( 2, 8 * attributes.index.type.BYTES_PER_ELEMENT ) ) {

            chunks.push({
                triangles: triangles,
                vertices: vertices
            });

            triangles = vertices = 0;
            
        }

        //

        if ( attributes['position'] ) {

            var positionAttr = attributes['position'].array;
            var rawPositionAttr = rawGeometry.attributes['position'].array;

        }

        if ( attributes['normal'] ) {

            var normalAttr = attributes['normal'].array;
            var rawNormalAttr = rawGeometry.attributes['normal'].array;

        }

        if ( attributes['uv'] ) {

            var uvAttr = attributes['uv'].array;
            var rawUvAttr = rawGeometry.attributes['uv'].array;

        }

        if ( attributes['uvOffset'] ) {

            var uvOffsetAttr = attributes['uvOffset'].array;

        }

        if ( attributes['index'] ) {

            var indexAttr = attributes['index'].array;
            var rawIndexAttr = rawGeometry.attributes['index'].array;

        }

        var tmpVertexArray = [ 0, 0, 0 ];

        for ( var k = 0, kl = rawGeometry.vertices; k < kl; k ++ ) {

            // set vertices positions

            if ( positionAttr ) {

                tmpVertexArray[ 0 ] = rawPositionAttr[ 3 * k + 0 ];
                tmpVertexArray[ 1 ] = rawPositionAttr[ 3 * k + 1 ];
                tmpVertexArray[ 2 ] = rawPositionAttr[ 3 * k + 2 ];

                if ( params.matrix ) {

                    params.matrix.multiplyVec3Array( tmpVertexArray );

                }

                positionAttr[ offset * ( internal[ this.uuid ].usedVertices + k ) + 0 ] = tmpVertexArray[ 0 ];
                positionAttr[ offset * ( internal[ this.uuid ].usedVertices + k ) + 1 ] = tmpVertexArray[ 1 ];
                positionAttr[ offset * ( internal[ this.uuid ].usedVertices + k ) + 2 ] = tmpVertexArray[ 2 ];

            }

            // set vertices normals

            if ( normalAttr ) {

                normalAttr[ offset * ( internal[ this.uuid ].usedVertices + k ) + 0 ] = rawNormalAttr[ 3 * k + 0 ];
                normalAttr[ offset * ( internal[ this.uuid ].usedVertices + k ) + 1 ] = rawNormalAttr[ 3 * k + 1 ];
                normalAttr[ offset * ( internal[ this.uuid ].usedVertices + k ) + 2 ] = rawNormalAttr[ 3 * k + 2 ];

            }

            // set vertices uvs

            if ( uvAttr ) {

                uvAttr[ offset * ( internal[ this.uuid ].usedVertices + k ) + 0 ] = ( rawUvAttr[ 2 * k + 0 ] % 1000 ) / params.atlasTextureItemsPerRow;
                uvAttr[ offset * ( internal[ this.uuid ].usedVertices + k ) + 1 ] = ( rawUvAttr[ 2 * k + 1 ] % 1000 ) / params.atlasTextureItemsPerRow;

            }

            // set vertices uvOffset

            if ( uvOffsetAttr ) {

                tIndex = window.Math.floor( rawGeometry.attributes['uv'].array[ 2 * k + 0 ] / 1000 );
                tIndexName = rawGeometry.textures[ tIndex ];
                tIndex = params.texturesID[ tIndexName ];

                uvOffsetAttr[ offset * ( internal[ this.uuid ].usedVertices + k ) + 0 ] = ( tIndex % params.atlasTextureItemsPerRow ) / params.atlasTextureItemsPerRow;
                uvOffsetAttr[ offset * ( internal[ this.uuid ].usedVertices + k ) + 1 ] = window.Math.floor( tIndex / params.atlasTextureItemsPerRow ) / params.atlasTextureItemsPerRow;

            }

            // set vertices instance indexes

            if ( attributes['instance_index'] ) {

                if ( params.objInstanceID !== undefined ) { // some hackery

                    attributes['instance_index'].array[ offset * ( internal[ this.uuid ].usedVertices + k ) + 0 ] = k;

                } else {

                    attributes['instance_index'].array[ offset * ( internal[ this.uuid ].usedVertices + k ) + 0 ] = params.id + params.aIndexOffset;

                }

            }

            if ( attributes['texture_index'] && rawGeometry.textures ) {

                tIndex = window.Math.floor( rawGeometry.attributes['uv'].array[ 2 * k + 0 ] / 1000 );
                tIndexName = rawGeometry.textures[ tIndex ];

                attributes['texture_index'].array[ offset * ( internal[ this.uuid ].usedVertices + k ) + 0 ] = 1000 * ( tIndex + 1 ) + params.texturesID[ tIndexName ];

            }

            // set vertices object index

            if ( attributes['vertex_index'] ) {

                attributes['vertex_index'].array[ offset * ( internal[ this.uuid ].usedVertices + k ) + 0 ] = k;

            }

        }

        for ( k = 0, kl = 3 * rawGeometry.triangles; k < kl; k ++ ) {

            indexAttr[ 3 * internal[ this.uuid ].usedFaces + k ] = internal[ this.uuid ].usedVertices + rawIndexAttr[ k ];

        }

        internal[ this.uuid ].usedVertices += rawGeometry.vertices;
        internal[ this.uuid ].usedFaces += rawGeometry.triangles;

    };

    LayoutBufferGeometry.prototype.computeChunkOffsets = function () {

        var chunks = internal[ this.uuid ].chunks,

            triangles = 0,
            vertices = 0,

            i, il;

        chunks.push({

            triangles: internal[ this.uuid ].triangles,
            vertices: internal[ this.uuid ].vertices

        });

        for ( i = 0, il = chunks.length; i < il; i ++ ) {

            this.offsets.push({

                start: 3 * triangles,
                index: vertices,
                count: 3 * chunks[i].triangles

            });

            triangles += chunks[i].triangles;
            vertices  += chunks[i].vertices;

        }

    };

    LayoutBufferGeometry.prototype.addAttribute = function ( name, itemSize, AttrType ) {

        if ( !name ) {

            return Logger.warn( 'NWE.gfx.LayoutBufferGeometry.addAttribute(): Undefined name for attribute.' );

        }

        var attribute;

        if ( name === 'index' ) {

            // setup geometry index

            AttrType = AttrType || Const.Uint16;

            if ( AttrType === Const.Uint32 && ! DeviceCapabilities.supportsIndexUINT() ) {

                return Logger.warn( 'NWE.gfx.LayoutBufferGeometry.addAttribute(): Geometry index type (Uint32) not supported.' );

            }

            attribute = {

                itemSize: 1,
                numItems: itemSize,
                type: AttrType,
                array: new AttrType( itemSize ),
                needsUpdate: true

            };

        } else {

            // other attributes

            if ( !itemSize ) {

                return Logger.warn( 'NWE.gfx.LayoutBufferGeometry.addAttribute(): Undefined size for "' + name + '" attribute.' );

            }

            AttrType = AttrType || Const.Float32;

            attribute = {

                itemSize:    itemSize,
                numItems:    itemSize * this.numVertices,
                type:        Const.FloatType,
                array:       null,
                offsetBytes: this.blockSize * AttrType.BYTES_PER_ELEMENT,
                offset:      this.blockSize,
                needsUpdate: true

            };

            this.blockSize += itemSize;

            // update vertex size in bytes

            this.vertexByteSize += itemSize * AttrType.BYTES_PER_ELEMENT;

        }

        this.attributes[ name ] = attribute;
        internal[ this.uuid ].attributesList.push( [name, attribute] );

        return attribute;

    };

    LayoutBufferGeometry.prototype.fillAttribute = function ( name, inputAttribute ) {

        var attribute = this.attributes[ name ];

        var i, il,
            j, jl,
            k = 0,

            offset = ( name === 'index' ) ? 1 : this.blockSize,

            itemSize = inputAttribute.itemSize,
            source = inputAttribute.array;

        for ( i = 0, il = source.length; i < il; i += itemSize ) {

            for ( j = 0; j < itemSize; j ++ ) {

                attribute.array[ offset * k + j ] = source[ i + j ];

            }

            k ++;

        }

    };

    LayoutBufferGeometry.prototype.bindArrays = function () {

        this.array = new ArrayBuffer( this.numVertices * this.vertexByteSize );

        for ( var i in this.attributes ) {

            if ( i === 'index' ) continue;

            this.attributes[ i ].array = new Float32Array( this.array, this.attributes[ i ].offsetBytes );

        }

    };

    LayoutBufferGeometry.prototype.computeBoundingBox = function () {

        if ( this.boundingBox === null ) {

            this.boundingBox = new Box3();

        }

        var positions = this.attributes['position'].array;
        var positionsOffset = this.attributes['position'].indexMultiplier;

        if ( positions ) {

            var bb = this.boundingBox;
            var x, y, z;

            if ( positions.length >= 3 ) {
                bb.min.x = bb.max.x = positions[ 0 ];
                bb.min.y = bb.max.y = positions[ 1 ];
                bb.min.z = bb.max.z = positions[ 2 ];
            }

            for ( var i = 3, il = positions.length; i < il; i += positionsOffset ) {

                x = positions[ i ];
                y = positions[ i + 1 ];
                z = positions[ i + 2 ];

                // bounding box

                if ( x < bb.min.x ) {

                    bb.min.x = x;

                } else if ( x > bb.max.x ) {

                    bb.max.x = x;

                }

                if ( y < bb.min.y ) {

                    bb.min.y = y;

                } else if ( y > bb.max.y ) {

                    bb.max.y = y;

                }

                if ( z < bb.min.z ) {

                    bb.min.z = z;

                } else if ( z > bb.max.z ) {

                    bb.max.z = z;

                }

            }

        }

        if ( positions === undefined || positions.length === 0 ) {

            this.boundingBox.min.set( 0, 0, 0 );
            this.boundingBox.max.set( 0, 0, 0 );

        }

    };

    LayoutBufferGeometry.prototype.computeBoundingSphere = function () {

        var box = new Box3();
        var vector = new Vec3();

        return function () {

            if ( this.boundingSphere === null ) {

                this.boundingSphere = new Sphere();

            }

            var positions = this.attributes['position'];
            var offset = this.blockSize;

            if ( positions ) {

                box.makeEmpty();

                var center = this.boundingSphere.center;
                var i, il;

                for ( i = 0, il = positions.numItems; i < il; i ++ ) {

                    vector.set( positions.array[ i * offset + 0 ], positions.array[ i * offset + 1 ], positions.array[ i * offset + 2 ] );
                    box.expandByPoint( vector );

                }

                // box.center( center );

                // hoping to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

                var maxRadiusSq = 0;

                for ( i = 0, il = positions.numItems; i < il; i ++ ) {

                    vector.set( positions.array[ 3 * i + 0 ], positions.array[ 3 * i + 1 ], positions.array[ 3 * i + 2 ] );
                    maxRadiusSq = window.Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

                }

                this.boundingSphere.radius = window.Math.sqrt( maxRadiusSq );

                if ( isNaN( this.boundingSphere.radius ) ) {

                    Logger.error( 'NWE.gfx.LayoutBufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );

                }

            }

        }

    }();

    LayoutBufferGeometry.prototype.applyMatrix = function ( matrix ) {

        var position = this.attributes['position'];
        var normal = this.attributes['normal'];

        if ( position ) {

            if ( !! position.array ) {

                matrix.multiplyVec3Array( position.array, this.blockSize );

            } else if ( position.array === null ) {

                return Logger.error( 'NWE.gfx.LayoutBufferGeometry.applyMatrix(): This geometry is not dynamic, transform it before adding to scene.' );

            }

        }

        if ( normal ) {

            if ( !! normal.array ) {

                var normalMatrix = new Matrix3().getNormalMatrix( matrix );

                normalMatrix.multiplyVec3Array( normal.array, this.blockSize, 0 );

                this.normalizeNormals();

            } else if ( normal.array === null ) {

                return Logger.error( 'NWE.gfx.LayoutBufferGeometry.applyMatrix(): This geometry is not dynamic, transform it before adding to scene.' );

            }

        }

    };

    LayoutBufferGeometry.prototype.computeVertexNormals = function () {}; // needs update

    LayoutBufferGeometry.prototype.normalizeNormals = function () {

        var normals = this.attributes['normal'].array;

        var x, y, z, n;

        for ( var i = 0, il = normals.length; i < il; i += this.blockSize ) {

            x = normals[ i     ];
            y = normals[ i + 1 ];
            z = normals[ i + 2 ];

            n = 1.0 / window.Math.sqrt( x * x + y * y + z * z );

            normals[ i     ] *= n;
            normals[ i + 1 ] *= n;
            normals[ i + 2 ] *= n;

        }

    };

    LayoutBufferGeometry.prototype.computeTangents = function () {};  // needs update

    LayoutBufferGeometry.prototype.clone = function () {

        // todo

    };

    LayoutBufferGeometry.prototype.dispose = function () {

        this.dispatchEvent( { type: 'dispose' } );

    };

    EventDispatcher.prototype.apply( LayoutBufferGeometry.prototype );

    LayoutBufferGeometry.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    LayoutBufferGeometry.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    LayoutBufferGeometry.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    LayoutBufferGeometry.setInternal = function ( name, value ) { internal[ name ] = value; };
    LayoutBufferGeometry.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof LayoutBufferGeometry === 'function' ) {
        var t = {}, p = {};
        for ( var i in LayoutBufferGeometry ) t[i] = LayoutBufferGeometry[i];
        for ( var i in LayoutBufferGeometry.prototype ) try { p[i] = LayoutBufferGeometry.prototype[i] } catch(e) {};
        scope.LayoutBufferGeometry = LayoutBufferGeometry.bind( scope );
    } else {
        scope.LayoutBufferGeometry = LayoutBufferGeometry;
    }
    internal['constructor'] = LayoutBufferGeometry;
    scope.LayoutBufferGeometry.prototype = LayoutBufferGeometry.prototype;
    for ( var i in t ) scope.LayoutBufferGeometry[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.LayoutBufferGeometry.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__LayoutBufferGeometry ) {
        for ( var i = 0, il = scope.__LayoutBufferGeometry.length; i < il; i ++ ) scope.__LayoutBufferGeometry[ i ]( LayoutBufferGeometry );
        delete scope.__LayoutBufferGeometry;
    }

}) ( NWE.gfx );


// src/graphics/core/Object3D.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author ohmed
     */



    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var Euler = NWE.Euler;
    if ( !Euler ) { NWE.__Euler = (NWE.__Euler || []); NWE.__Euler.push( function ( obj ) { Euler = obj; } ); }

    var Quaternion = NWE.Quaternion;
    if ( !Quaternion ) { NWE.__Quaternion = (NWE.__Quaternion || []); NWE.__Quaternion.push( function ( obj ) { Quaternion = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var Object3D = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        this.uuid = Math.generateUUID();
        internal[ this.uuid ] = objInternal;

        this.id = NWE.gfx.Object3DIdCount ++;

        this.name = params.name || '';

        this.parent = undefined;
        this.children = [];

        this.up = new Vec3( 0, 1, 0 );

        this.position = new Vec3();
        this.rotation = new Euler();
        this.quaternion = new Quaternion();
        this.scale = new Vec3( 1, 1, 1 );

        // keep rotation and quaternion in sync

        this.rotation._quaternion = this.quaternion;
        this.quaternion._euler = this.rotation;

        this.renderDepth = null;

        this.rotationAutoUpdate = true;

        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();

        this.matrixAutoUpdate = true;
        this.matrixWorldNeedsUpdate = true;

        this.visible = true;

        this.frustumCulled = true;

        this.scenesOwners = [];

        this.status = {};

        this.userData = {};

        //

        this.instanceof = 'Object3D';

    };


    Object3D.prototype = {

        constructor: Object3D,

        applyMatrix: function () {

            var m1 = new Matrix4();

            return function ( matrix ) {

                this.matrix.multiplyMatrices( matrix, this.matrix );

                this.position.getPositionFromMatrix( this.matrix );

                this.scale.getScaleFromMatrix( this.matrix );

                m1.extractRotation( this.matrix );

                this.quaternion.setFromRotationMatrix( m1 );

            }

        }(),

        setRotationFromAxisAngle: function ( axis, angle ) {

            // assumes axis is normalized

            this.quaternion.setFromAxisAngle( axis, angle );

        },

        setRotationFromEuler: function ( euler ) {

            this.quaternion.setFromEuler( euler, true );

        },

        setRotationFromMatrix: function ( m ) {

            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

            this.quaternion.setFromRotationMatrix( m );

        },

        setRotationFromQuaternion: function ( q ) {

            // assumes q is normalized

            this.quaternion.copy( q );

        },

        rotateOnAxis: function () {

            // rotate object on axis in object space
            // axis is assumed to be normalized

            var q1 = new Quaternion();

            return function ( axis, angle ) {

                q1.setFromAxisAngle( axis, angle );

                this.quaternion.multiply( q1 );

                return this;

            }

        }(),

        rotateX: function () {

            var v1 = new Vec3( 1, 0, 0 );

            return function ( angle ) {

                return this.rotateOnAxis( v1, angle );

            };

        }(),

        rotateY: function () {

            var v1 = new Vec3( 0, 1, 0 );

            return function ( angle ) {

                return this.rotateOnAxis( v1, angle );

            };

        }(),

        rotateZ: function () {

            var v1 = new Vec3( 0, 0, 1 );

            return function ( angle ) {

                return this.rotateOnAxis( v1, angle );

            };

        }(),

        translateOnAxis: function () {

            // translate object by distance along axis in object space
            // axis is assumed to be normalized

            var v1 = new Vec3();

            return function ( axis, distance ) {

                v1.copy( axis );

                v1.applyQuaternion( this.quaternion );

                this.position.add( v1.multiplyScalar( distance ) );

                return this;

            }

        }(),

        translateX: function () {

            var v1 = new Vec3( 1, 0, 0 );

            return function ( distance ) {

                return this.translateOnAxis( v1, distance );

            };

        }(),

        translateY: function () {

            var v1 = new Vec3( 0, 1, 0 );

            return function ( distance ) {

                return this.translateOnAxis( v1, distance );

            };

        }(),

        translateZ: function () {

            var v1 = new Vec3( 0, 0, 1 );

            return function ( distance ) {

                return this.translateOnAxis( v1, distance );

            };

        }(),

        localToWorld: function ( vector ) {

            return vector.applyMatrix4( this.matrixWorld );

        },

        worldToLocal: function () {

            var m1 = new Matrix4();

            return function ( vector ) {

                return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

            };

        }(),

        lookAt: function () {

            // This routine does not support objects with rotated and/or translated parent(s)

            var m1 = new Matrix4();

            return function ( vector ) {

                m1.lookAt( vector, this.position, this.up );

                this.quaternion.setFromRotationMatrix( m1 );

            };

        }(),

        add: function ( object ) {

            if ( object === this ) {

                Logger.warn( 'NWE.gfx.Object3D.add(): An object can\'t be added as a child of itself.' );
                return;

            }

            if ( object instanceof Object3D ) {

                if ( object.parent !== undefined ) {

                    object.parent.remove( object );

                }

                object.parent = this;
                object.dispatchEvent( { type: 'added' } );

                object.scenesOwners = this.scenesOwners;

                this.children.push( object );

            } else {

                Logger.error( 'NWE.Object3D.add():' + object + 'is not an instance of NWE.Object3D.' );

            }

        },

        remove: function ( object ) {

            var index = this.children.indexOf( object );

            if ( index !== - 1 ) {

                object.parent = undefined;
                object.dispatchEvent( { type: 'remove' } );

                this.children.splice( index, 1 );

                // remove from scene

                var scene = this;

                while ( scene.parent !== undefined ) {

                    scene = scene.parent;

                }

            }

        },

        traverse: function ( callback ) {

            callback( this );

            for ( var i = 0, l = this.children.length; i < l; i ++ ) {

                this.children[ i ].traverse( callback );

            }

        },

        getObjectById: function ( id, recursive ) {

            for ( var i = 0, l = this.children.length; i < l; i ++ ) {

                var child = this.children[ i ];

                if ( child.id === id ) {

                    return child;

                }

                if ( recursive === true ) {

                    child = child.getObjectById( id, recursive );

                    if ( child !== undefined ) {

                        return child;

                    }

                }

            }

            return undefined;

        },

        getObjectByName: function ( name, recursive ) {

            for ( var i = 0, l = this.children.length; i < l; i ++ ) {

                var child = this.children[ i ];

                if ( child.name === name ) {

                    return child;

                }

                if ( recursive === true ) {

                    child = child.getObjectByName( name, recursive );

                    if ( child !== undefined ) {

                        return child;

                    }

                }

            }

            return undefined;

        },

        getDescendants: function ( array ) {

            if ( array === undefined ) array = [];

            Array.prototype.push.apply( array, this.children );

            for ( var i = 0, l = this.children.length; i < l; i ++ ) {

                this.children[ i ].getDescendants( array );

            }

            return array;

        },

        updateMatrix: function () {

            this.matrix.compose( this.position, this.quaternion, this.scale );

            this.matrixWorldNeedsUpdate = true;

        },

        updateMatrixWorld: function ( force ) {

            if ( this.matrixAutoUpdate === true ) this.updateMatrix();

            if ( this.matrixWorldNeedsUpdate === true || force === true ) {

                if ( this.parent === undefined || ! this.parent.matrixWorld ) {

                    this.matrixWorld.copy( this.matrix );

                } else {

                    this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

                }

                this.matrixWorldNeedsUpdate = false;

                force = true;

            }

            // update children

            for ( var i = 0, l = this.children.length; i < l; i ++ ) {

                this.children[ i ].updateMatrixWorld( force );

            }

        },

        clone: function ( object, recursive ) {

            if ( object === undefined ) object = new Object3D();
            if ( recursive === undefined ) recursive = true;

            object.name = this.name;

            object.up.copy( this.up );

            object.position.copy( this.position );
            object.quaternion.copy( this.quaternion );
            object.scale.copy( this.scale );

            object.renderDepth = this.renderDepth;

            object.rotationAutoUpdate = this.rotationAutoUpdate;

            object.matrix.copy( this.matrix );
            object.matrixWorld.copy( this.matrixWorld );

            object.matrixAutoUpdate = this.matrixAutoUpdate;
            object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

            object.visible = this.visible;

            object.frustumCulled = this.frustumCulled;

            object.userData = JSON.parse( JSON.stringify( this.userData ) );

            if ( recursive === true ) {

                for ( var i = 0; i < this.children.length; i ++ ) {

                    var child = this.children[ i ];
                    object.add( child.clone() );

                }

            }

            return object;

        }

    };

    EventDispatcher.prototype.apply( Object3D.prototype );

    NWE.gfx.Object3DIdCount = 0;

    Object3D.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Object3D.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Object3D.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Object3D.setInternal = function ( name, value ) { internal[ name ] = value; };
    Object3D.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Object3D === 'function' ) {
        var t = {}, p = {};
        for ( var i in Object3D ) t[i] = Object3D[i];
        for ( var i in Object3D.prototype ) try { p[i] = Object3D.prototype[i] } catch(e) {};
        scope.Object3D = Object3D.bind( scope );
    } else {
        scope.Object3D = Object3D;
    }
    internal['constructor'] = Object3D;
    scope.Object3D.prototype = Object3D.prototype;
    for ( var i in t ) scope.Object3D[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Object3D.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Object3D ) {
        for ( var i = 0, il = scope.__Object3D.length; i < il; i ++ ) scope.__Object3D[ i ]( Object3D );
        delete scope.__Object3D;
    }

}) ( NWE.gfx );


// src/graphics/core/Projector.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author julianwa / https://github.com/julianwa
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Vec4 = NWE.Vec4;
    if ( !Vec4 ) { NWE.__Vec4 = (NWE.__Vec4 || []); NWE.__Vec4.push( function ( obj ) { Vec4 = obj; } ); }

    var Box3 = NWE.Box3;
    if ( !Box3 ) { NWE.__Box3 = (NWE.__Box3 || []); NWE.__Box3.push( function ( obj ) { Box3 = obj; } ); }

    var Matrix3 = NWE.Matrix3;
    if ( !Matrix3 ) { NWE.__Matrix3 = (NWE.__Matrix3 || []); NWE.__Matrix3.push( function ( obj ) { Matrix3 = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var Frustum = NWE.Frustum;
    if ( !Frustum ) { NWE.__Frustum = (NWE.__Frustum || []); NWE.__Frustum.push( function ( obj ) { Frustum = obj; } ); }


    var Raycaster = NWE.gfx.Raycaster;
    if ( !Raycaster ) { NWE.gfx.__Raycaster = (NWE.gfx.__Raycaster || []); NWE.gfx.__Raycaster.push( function ( obj ) { Raycaster = obj; } ); }


    var Mesh = NWE.gfx.Mesh;
    if ( !Mesh ) { NWE.gfx.__Mesh = (NWE.gfx.__Mesh || []); NWE.gfx.__Mesh.push( function ( obj ) { Mesh = obj; } ); }

    var Line = NWE.gfx.Line;
    if ( !Line ) { NWE.gfx.__Line = (NWE.gfx.__Line || []); NWE.gfx.__Line.push( function ( obj ) { Line = obj; } ); }

    var Sprite = NWE.gfx.Sprite;
    if ( !Sprite ) { NWE.gfx.__Sprite = (NWE.gfx.__Sprite || []); NWE.gfx.__Sprite.push( function ( obj ) { Sprite = obj; } ); }


    var RenderableObject = NWE.gfx.RenderableObject;
    if ( !RenderableObject ) { NWE.gfx.__RenderableObject = (NWE.gfx.__RenderableObject || []); NWE.gfx.__RenderableObject.push( function ( obj ) { RenderableObject = obj; } ); }

    var RenderableVertex = NWE.gfx.RenderableVertex;
    if ( !RenderableVertex ) { NWE.gfx.__RenderableVertex = (NWE.gfx.__RenderableVertex || []); NWE.gfx.__RenderableVertex.push( function ( obj ) { RenderableVertex = obj; } ); }

    var RenderableFace = NWE.gfx.RenderableFace;
    if ( !RenderableFace ) { NWE.gfx.__RenderableFace = (NWE.gfx.__RenderableFace || []); NWE.gfx.__RenderableFace.push( function ( obj ) { RenderableFace = obj; } ); }


    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var Projector = function () {

        var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
        _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
        _face, _faceCount, _facePool = [], _facePoolLength = 0,
        _line, _lineCount, _linePool = [], _linePoolLength = 0,

        _renderData = { objects: [], sprites: [], elements: [] },

        _vector3 = new Vec3(),
        _vector4 = new Vec4(),

        _clipBox = new Box3( new Vec3( -1, -1, -1 ), new Vec3( 1, 1, 1 ) ),
        _boundingBox = new Box3(),
        _points3 = new Array( 3 ),
        _points4 = new Array( 4 ),

        _viewMatrix = new Matrix4(),
        _viewProjectionMatrix = new Matrix4(),

        _modelMatrix,
        _modelViewProjectionMatrix = new Matrix4(),

        _normalMatrix = new Matrix3(),
        _normalViewMatrix = new Matrix3(),

        _centroid = new Vec3(),

        _frustum = new Frustum(),

        _clippedVertex1PositionScreen = new Vec4(),
        _clippedVertex2PositionScreen = new Vec4();

        this.projectVector = function ( vector, camera ) {

            camera.matrixWorldInverse.getInverse( camera.matrixWorld );

            _viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );

            return vector.applyProjection( _viewProjectionMatrix );

        };

        this.unprojectVector = function ( vector, camera ) {

            camera.projectionMatrixInverse.getInverse( camera.projectionMatrix );

            _viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, camera.projectionMatrixInverse );

            return vector.applyProjection( _viewProjectionMatrix );

        };

        this.pickingRay = function ( vector, camera ) {

            // set two vectors with opposing z values
            vector.z = -1.0;
            var end = new Vec3( vector.x, vector.y, 1.0 );

            this.unprojectVector( vector, camera );
            this.unprojectVector( end, camera );

            // find direction from vector to end
            end.sub( vector ).normalize();

            return new Raycaster( vector, end );

        };

        var getObject = function ( object ) {

            _object = getNextObjectInPool();
            _object.id = object.id;
            _object.object = object;

            if ( object.renderDepth !== null ) {

                _object.z = object.renderDepth;

            } else {

                _vector3.getPositionFromMatrix( object.matrixWorld );
                _vector3.applyProjection( _viewProjectionMatrix );
                _object.z = _vector3.z;

            }

            return _object;

        };

        var projectObject = function ( object ) {

            if ( object.visible === false ) return;

            if ( object.instanceof === 'Mesh' || object.instanceof === 'Line' ) {

                if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

                    _renderData.objects.push( getObject( object ) );

                }

            } else if ( object.instanceof === 'Sprite' ) {

                _renderData.sprites.push( getObject( object ) );

            }

            for ( var i = 0, l = object.children.length; i < l; i ++ ) {

                projectObject( object.children[ i ] );

            }

        };

        var projectGraph = function ( root, sortObjects ) {

            _objectCount = 0;

            _renderData.objects.length = 0;
            _renderData.sprites.length = 0;

            projectObject( root );

            if ( sortObjects === true ) {

                _renderData.objects.sort( painterSort );

            }

        };

        this.projectScene = function ( scene, camera, sortObjects, sortElements ) {

            var visible = false,
            o, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object,
            geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,
            v1, v2, v3, v4, isFaceMaterial, objectMaterials;

            _faceCount = 0;
            _lineCount = 0;

            _renderData.elements.length = 0;

            if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
            if ( camera.parent === undefined ) camera.updateMatrixWorld();

            _viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );
            _viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

            _normalViewMatrix.getNormalMatrix( _viewMatrix );

            _frustum.setFromMatrix( _viewProjectionMatrix );

            projectGraph( scene, sortObjects );

            for ( o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {

                object = _renderData.objects[ o ].object;

                _modelMatrix = object.matrixWorld;

                _vertexCount = 0;

                if ( object.instanceof === 'Mesh' ) {

                    geometry = object.geometry;

                    vertices = geometry.vertices;
                    faces = geometry.faces;
                    faceVertexUvs = geometry.faceVertexUvs;

                    _normalMatrix.getNormalMatrix( _modelMatrix );

                    objectMaterials = null;

                    for ( v = 0, vl = vertices.length; v < vl; v ++ ) {

                        _vertex = getNextVertexInPool();

                        _vertex.positionWorld.copy( vertices[ v ] ).applyMatrix4( _modelMatrix );
                        _vertex.positionScreen.copy( _vertex.positionWorld ).applyMatrix4( _viewProjectionMatrix );

                        var invW = 1 / _vertex.positionScreen.w;

                        _vertex.positionScreen.x *= invW;
                        _vertex.positionScreen.y *= invW;
                        _vertex.positionScreen.z *= invW;

                        _vertex.visible = ! ( _vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 ||
                                              _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 ||
                                              _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1 );

                    }

                    for ( f = 0, fl = faces.length; f < fl; f ++ ) {

                        face = faces[ f ];

                        var material = isFaceMaterial === true
                            ? objectMaterials.materials[ face.materialIndex ]
                            : object.material;

                        if ( material === undefined ) continue;

                        var side = material.side;

                        v1 = _vertexPool[ face.a ];
                        v2 = _vertexPool[ face.b ];
                        v3 = _vertexPool[ face.c ];

                        _points3[ 0 ] = v1.positionScreen;
                        _points3[ 1 ] = v2.positionScreen;
                        _points3[ 2 ] = v3.positionScreen;

                        if ( v1.visible === true || v2.visible === true || v3.visible === true ||
                            _clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {

                            visible = ( ( v3.positionScreen.x - v1.positionScreen.x ) *
                                    ( v2.positionScreen.y - v1.positionScreen.y ) -
                                    ( v3.positionScreen.y - v1.positionScreen.y ) *
                                    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;

                            if ( side === Const.DoubleSide || visible === ( side === Const.FrontSide ) ) {

                                _face = getNextfaceInPool();

                                _face.id = object.id;
                                _face.v1.copy( v1 );
                                _face.v2.copy( v2 );
                                _face.v3.copy( v3 );

                            } else {

                                continue;

                            }

                        } else {

                            continue;

                        }

                        _face.normalModel.copy( face.normal );

                        if ( visible === false && ( side === Const.BackSide || side === Const.DoubleSide ) ) {

                            _face.normalModel.negate();

                        }

                        _face.normalModel.applyMatrix3( _normalMatrix ).normalize();

                        _face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );

                        _face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );

                        faceVertexNormals = face.vertexNormals;

                        for ( n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {

                            var normalModel = _face.vertexNormalsModel[ n ];
                            normalModel.copy( faceVertexNormals[ n ] );

                            if ( visible === false && ( side === Const.BackSide || side === Const.DoubleSide ) ) {

                                normalModel.negate();

                            }

                            normalModel.applyMatrix3( _normalMatrix ).normalize();

                            var normalModelView = _face.vertexNormalsModelView[ n ];
                            normalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );

                        }

                        _face.vertexNormalsLength = faceVertexNormals.length;

                        for ( c = 0, cl = Math.min( faceVertexUvs.length, 3 ); c < cl; c ++ ) {

                            uvs = faceVertexUvs[ c ][ f ];

                            if ( uvs === undefined ) continue;

                            for ( u = 0, ul = uvs.length; u < ul; u ++ ) {

                                _face.uvs[ c ][ u ] = uvs[ u ];

                            }

                        }

                        _face.color = face.color;
                        _face.material = material;

                        _centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );

                        _face.z = _centroid.z;

                        _renderData.elements.push( _face );

                    }

                } else if ( object.instanceof === 'Line' ) {

                    _modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

                    vertices = object.geometry.vertices;

                    v1 = getNextVertexInPool();
                    v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );

                    // Handle LineStrip and LinePieces
                    var step = ( object.type === Const.LinePieces ) ? 2 : 1;

                    for ( v = 1, vl = vertices.length; v < vl; v ++ ) {

                        v1 = getNextVertexInPool();
                        v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );

                        if ( ( v + 1 ) % step > 0 ) continue;

                        v2 = _vertexPool[ _vertexCount - 2 ];

                        _clippedVertex1PositionScreen.copy( v1.positionScreen );
                        _clippedVertex2PositionScreen.copy( v2.positionScreen );

                        if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {

                            // Perform the perspective divide
                            _clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
                            _clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

                            _line = getNextLineInPool();

                            _line.id = object.id;
                            _line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
                            _line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

                            _line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

                            _line.material = object.material;

                            if ( object.material.vertexColors === Const.VertexColors ) {

                                _line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );
                                _line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );

                            }

                            _renderData.elements.push( _line );

                        }

                    }

                }

            }

            for ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {

                object = _renderData.sprites[ o ].object;

                _modelMatrix = object.matrixWorld;

            }

            if ( sortElements === true ) _renderData.elements.sort( painterSort );

            return _renderData;

        };

        // Pools

        function getNextObjectInPool() {

            if ( _objectCount === _objectPoolLength ) {

                var object = new RenderableObject();
                _objectPool.push( object );
                _objectPoolLength ++;
                _objectCount ++;
                return object;

            }

            return _objectPool[ _objectCount ++ ];

        }

        function getNextVertexInPool() {

            if ( _vertexCount === _vertexPoolLength ) {

                var vertex = new RenderableVertex();
                _vertexPool.push( vertex );
                _vertexPoolLength ++;
                _vertexCount ++;
                return vertex;

            }

            return _vertexPool[ _vertexCount ++ ];

        }

        function getNextfaceInPool() {

            if ( _faceCount === _facePoolLength ) {

                var face = new RenderableFace();
                _facePool.push( face );
                _facePoolLength ++;
                _faceCount ++;
                return face;

            }

            return _facePool[ _faceCount ++ ];


        }

        function getNextLineInPool() {

            if ( _lineCount === _linePoolLength ) {

                var line = new RenderableLine();
                _linePool.push( line );
                _linePoolLength ++;
                _lineCount ++
                return line;

            }

            return _linePool[ _lineCount ++ ];

        }

        //

        function painterSort( a, b ) {

            if ( a.z !== b.z ) {

                return b.z - a.z;

            } else if ( a.id !== b.id ) {

                return a.id - b.id;

            } else {

                return 0;

            }

        }

        function clipLine( s1, s2 ) {

            var alpha1 = 0, alpha2 = 1,

            // Calculate the boundary coordinate of each vertex for the near and far clip planes,
            // Z = -1 and Z = +1, respectively.
            bc1near =  s1.z + s1.w,
            bc2near =  s2.z + s2.w,
            bc1far =  - s1.z + s1.w,
            bc2far =  - s2.z + s2.w;

            if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

                // Both vertices lie entirely within all clip planes.
                return true;

            } else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {

                // Both vertices lie entirely outside one of the clip planes.
                return false;

            } else {

                // The line segment spans at least one clip plane.

                if ( bc1near < 0 ) {

                    // v1 lies outside the near plane, v2 inside
                    alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

                } else if ( bc2near < 0 ) {

                    // v2 lies outside the near plane, v1 inside
                    alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

                }

                if ( bc1far < 0 ) {

                    // v1 lies outside the far plane, v2 inside
                    alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

                } else if ( bc2far < 0 ) {

                    // v2 lies outside the far plane, v2 inside
                    alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

                }

                if ( alpha2 < alpha1 ) {

                    // The line segment spans two boundaries, but is outside both of them.
                    // (This can't happen when we're only clipping against just near/far but good
                    //  to leave the check here for future usage if other clip planes are added.)
                    return false;

                } else {

                    // Update the s1 and s2 vertices to match the clipped line segment.
                    s1.lerp( s2, alpha1 );
                    s2.lerp( s1, 1 - alpha2 );

                    return true;

                }

            }

        }

    };

    if ( typeof Projector === 'function' ) {
        var t = {}, p = {};
        for ( var i in Projector ) t[i] = Projector[i];
        for ( var i in Projector.prototype ) try { p[i] = Projector.prototype[i] } catch(e) {};
        scope.Projector = Projector.bind( scope );
    } else {
        scope.Projector = Projector;
    }
    scope.Projector.prototype = Projector.prototype;
    for ( var i in t ) scope.Projector[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Projector.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Projector ) {
        for ( var i = 0, il = scope.__Projector.length; i < il; i ++ ) scope.__Projector[ i ]( Projector );
        delete scope.__Projector;
    }

}) ( NWE.gfx );


// src/graphics/core/Raycaster.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author bhouston / http://exocortex.com/
     * @author stephomi / http://stephaneginier.com/
     */

    var LOD = NWE.gfx.LOD;
    if ( !LOD ) { NWE.gfx.__LOD = (NWE.gfx.__LOD || []); NWE.gfx.__LOD.push( function ( obj ) { LOD = obj; } ); }

    var Mesh = NWE.gfx.Mesh;
    if ( !Mesh ) { NWE.gfx.__Mesh = (NWE.gfx.__Mesh || []); NWE.gfx.__Mesh.push( function ( obj ) { Mesh = obj; } ); }

    var Line = NWE.gfx.Line;
    if ( !Line ) { NWE.gfx.__Line = (NWE.gfx.__Line || []); NWE.gfx.__Line.push( function ( obj ) { Line = obj; } ); }

    var BufferGeometry = NWE.gfx.BufferGeometry;
    if ( !BufferGeometry ) { NWE.gfx.__BufferGeometry = (NWE.gfx.__BufferGeometry || []); NWE.gfx.__BufferGeometry.push( function ( obj ) { BufferGeometry = obj; } ); }

    var Ray = NWE.Ray;
    if ( !Ray ) { NWE.__Ray = (NWE.__Ray || []); NWE.__Ray.push( function ( obj ) { Ray = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var Plane = NWE.Plane;
    if ( !Plane ) { NWE.__Plane = (NWE.__Plane || []); NWE.__Plane.push( function ( obj ) { Plane = obj; } ); }

    var Sphere = NWE.Sphere;
    if ( !Sphere ) { NWE.__Sphere = (NWE.__Sphere || []); NWE.__Sphere.push( function ( obj ) { Sphere = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var Raycaster = function ( origin, direction, near, far ) {

        this.ray = new Ray( origin, direction );
        // direction is assumed to be normalized (for accurate distance calculations)

        this.near = near || 0;
        this.far = far || Infinity;

    };

    var sphere = new Sphere();
    var localRay = new Ray();
    var facePlane = new Plane();
    var intersectPoint = new Vec3();
    var matrixPosition = new Vec3();

    var inverseMatrix = new Matrix4();

    var descSort = function ( a, b ) {

        return a.distance - b.distance;

    };

    var vA = new Vec3();
    var vB = new Vec3();
    var vC = new Vec3();

    var intersectObject = function ( object, raycaster, intersects ) {

        if ( object.instanceof === 'LOD' ) {

            matrixPosition.getPositionFromMatrix( object.matrixWorld );
            var distance = raycaster.ray.origin.distanceTo( matrixPosition );

            intersectObject( object.getObjectForDistance( distance ), raycaster, intersects );

        } else if ( object.instanceof === 'Mesh' ) {

            var geometry = object.geometry;

            // Checking boundingSphere distance to ray

            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

            sphere.copy( geometry.boundingSphere );
            sphere.applyMatrix4( object.matrixWorld );

            if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

                return intersects;

            }

            // Check boundingBox before continuing
            
            inverseMatrix.getInverse( object.matrixWorld );  
            localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

            if ( geometry.boundingBox !== null ) {

                if ( localRay.isIntersectionBox( geometry.boundingBox ) === false )  {

                    return intersects;

                }

            } 

            if ( geometry.instanceof === 'DirrectBuffers' ) {

                var material = object.material;

                if ( material === undefined ) return intersects;
                if ( geometry.dynamic === false ) return intersects;

                var a, b, c;
                var precision = raycaster.precision;

                if ( geometry.attributes.index !== undefined ) {

                    var offsets = geometry.offsets;
                    var indices = geometry.attributes.index.array;
                    var positions = geometry.attributes.position.array;
                    var offLength = geometry.offsets.length;

                    var fl = geometry.attributes.index.array.length / 3;

                    for ( var oi = 0; oi < offLength; ++oi ) {

                        var start = offsets[ oi ].start;
                        var count = offsets[ oi ].count;
                        var index = offsets[ oi ].index;

                        for ( var i = start, il = start + count; i < il; i += 3 ) {

                            a = index + indices[ i ];
                            b = index + indices[ i + 1 ]; 
                            c = index + indices[ i + 2 ];

                            vA.set(
                                positions[ a * 3 ],
                                positions[ a * 3 + 1 ],
                                positions[ a * 3 + 2 ]
                            );
                            vB.set(
                                positions[ b * 3 ],
                                positions[ b * 3 + 1 ],
                                positions[ b * 3 + 2 ]
                            );
                            vC.set(
                                positions[ c * 3 ],
                                positions[ c * 3 + 1 ],
                                positions[ c * 3 + 2 ]
                            );

                            var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== Const.DoubleSide );

                            if ( intersectionPoint === null ) continue;

                            intersectionPoint.applyMatrix4( object.matrixWorld );

                            var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

                            if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

                            intersects.push( {

                                distance: distance,
                                point: intersectionPoint,
                                face: null,
                                faceIndex: null,
                                object: object

                            } );

                        }

                    }

                } else {

                    var offsets = geometry.offsets;
                    var positions = geometry.attributes.position.array;
                    var offLength = geometry.offsets.length;

                    var fl = geometry.attributes.position.array.length;

                    for ( var i = 0; i < fl; i += 3 ) {

                        a = i;
                        b = i + 1;
                        c = i + 2;

                        vA.set(
                            positions[ a * 3 ],
                            positions[ a * 3 + 1 ],
                            positions[ a * 3 + 2 ]
                        );
                        vB.set(
                            positions[ b * 3 ],
                            positions[ b * 3 + 1 ],
                            positions[ b * 3 + 2 ]
                        );
                        vC.set(
                            positions[ c * 3 ],
                            positions[ c * 3 + 1 ],
                            positions[ c * 3 + 2 ]
                        );

                        var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== Const.DoubleSide );

                        if ( intersectionPoint === null ) continue;

                        intersectionPoint.applyMatrix4( object.matrixWorld );

                        var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

                        if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

                        intersects.push( {

                            distance: distance,
                            point: intersectionPoint,
                            face: null,
                            faceIndex: null,
                            object: object

                        } );

                    }

                }

            }

        } else if ( object.instanceof === 'Line' ) {

            var precision = raycaster.linePrecision;
            var precisionSq = precision * precision;

            var geometry = object.geometry;

            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

            // Checking boundingSphere distance to ray

            sphere.copy( geometry.boundingSphere );
            sphere.applyMatrix4( object.matrixWorld );
            
            if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

                return intersects;

            }
            
            inverseMatrix.getInverse( object.matrixWorld );
            localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        }

    };

    var intersectDescendants = function ( object, raycaster, intersects ) {

        var descendants = object.getDescendants();

        for ( var i = 0, l = descendants.length; i < l; i ++ ) {

            intersectObject( descendants[ i ], raycaster, intersects );

        }

    };

    //

    Raycaster.prototype.precision = 0.0001;
    Raycaster.prototype.linePrecision = 1;

    Raycaster.prototype.set = function ( origin, direction ) {

        this.ray.set( origin, direction );
        // direction is assumed to be normalized (for accurate distance calculations)

    };

    Raycaster.prototype.intersectObject = function ( object, recursive ) {

        var intersects = [];

        if ( recursive === true ) {

            intersectDescendants( object, this, intersects );

        }

        intersectObject( object, this, intersects );

        intersects.sort( descSort );

        return intersects;

    };

    Raycaster.prototype.intersectObjects = function ( objects, recursive ) {

        var intersects = [];

        for ( var i = 0, l = objects.length; i < l; i ++ ) {

            intersectObject( objects[ i ], this, intersects );

            if ( recursive === true ) {

                intersectDescendants( objects[ i ], this, intersects );

            }

        }

        intersects.sort( descSort );

        return intersects;

    };

    if ( typeof Raycaster === 'function' ) {
        var t = {}, p = {};
        for ( var i in Raycaster ) t[i] = Raycaster[i];
        for ( var i in Raycaster.prototype ) try { p[i] = Raycaster.prototype[i] } catch(e) {};
        scope.Raycaster = Raycaster.bind( scope );
    } else {
        scope.Raycaster = Raycaster;
    }
    scope.Raycaster.prototype = Raycaster.prototype;
    for ( var i in t ) scope.Raycaster[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Raycaster.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Raycaster ) {
        for ( var i = 0, il = scope.__Raycaster.length; i < il; i ++ ) scope.__Raycaster[ i ]( Raycaster );
        delete scope.__Raycaster;
    }

}) ( NWE.gfx );


// src/graphics/core/Uniform.js

( function ( scope ) {

    /**
     * author: @ohmed
    */

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var Uniform = function ( id, type, value, globalLevel ) {

        this.id = id;
        this.type = type;
        this.value = value;
        this.globalLevel = globalLevel;

        if ( Uniform.typesList.indexOf( this.type ) === -1 ) {

            Logger.error( 'NWE.gfx.Uniform(): Unknown uniform type.' );
            return false;

        }

        this.needsUpdate = true;

        //

        this.instanceof = 'Uniform';

    };

    Uniform.prototype = {};

    Uniform.typesList = [ 'i', 'c', 'f', 'v2', 'v3', 'v4', 'iv', 'iv1', 'fv', 'fv1', 'v2v', 't' ];

    if ( typeof Uniform === 'function' ) {
        var t = {}, p = {};
        for ( var i in Uniform ) t[i] = Uniform[i];
        for ( var i in Uniform.prototype ) try { p[i] = Uniform.prototype[i] } catch(e) {};
        scope.Uniform = Uniform.bind( scope );
    } else {
        scope.Uniform = Uniform;
    }
    scope.Uniform.prototype = Uniform.prototype;
    for ( var i in t ) scope.Uniform[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Uniform.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Uniform ) {
        for ( var i = 0, il = scope.__Uniform.length; i < il; i ++ ) scope.__Uniform[ i ]( Uniform );
        delete scope.__Uniform;
    }

}) ( NWE.gfx );


// src/graphics/core/Scene.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }

    var Camera = NWE.gfx.Camera;
    if ( !Camera ) { NWE.gfx.__Camera = (NWE.gfx.__Camera || []); NWE.gfx.__Camera.push( function ( obj ) { Camera = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var Scene = function ( params ) {

        params = params || {};

        var objInternal = {};
        Object3D.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.fog = null;
        this.overrideMaterial = null;

        this.autoUpdate = true; // checked by the renderer
        this.matrixAutoUpdate = false;

        internal[ this.uuid ].gpuSelectors = [];

        this.objects = [];

        this.instanceof = 'Scene';

    };

    Scene.prototype = Object.create( Object3D.prototype );

    Scene.prototype.add = function ( object ) {

        if ( object.instanceof === 'Scene' ) {

            Logger.warn( 'NWE.gfx.Scene.add(): Scene object type can\'t be added to Scene.' );
            return;

        }

        if ( object.scenesOwners && object.scenesOwners[ this.id ] ) {

            Logger.warn( 'NWE.gfx.Scene.add(): Object can be added to the scene only once.' );
            return;

        }

        if ( object instanceof Object3D ) {

            object.dispatchEvent( { type: 'added' } );

            this.children.push( object );
            object.scenesOwners[ this.id ] = true;

        }

        if ( Scene.objectTypes[ object.instanceof ] ) {

            this.objects.push( object );
            Scene.objectTypes[ object.instanceof ].add.call( this, object );

        }

    };

    Scene.prototype.remove = function ( object ) {

        if ( ! object ) {

            return;

        }

        object.scenesOwners[ this.id ] = undefined;

        var index = this.children.indexOf( object );

        if ( index !== - 1 ) {

            object.parent = undefined;
            object.dispatchEvent( { type: 'remove' } );

            this.children.splice( index, 1 );

        }

        object.scenesOwners[ this.id ] = 0;

        if ( Scene.objectTypes[ object.instanceof ] ) {

            Scene.objectTypes[ object.instanceof ].remove.call( this, object );

        }

    };

    Scene.prototype.update = function ( camera, delta ) {

        var object;

        for ( var i = 0, il = this.children.length; i < il; i ++ ) {

            object = this.children[ i ];

            if ( object.autoUpdate ) {

                object.update( camera, delta );

            }

        }

        for ( var i = 0, il = this.objects.length; i < il; i ++ ) {

            object = this.objects[ i ];

            if ( object.autoUpdate ) {

                object.update( delta );

            }

        }

    };

    Scene.prototype.clone = function ( object ) {

        if ( object === undefined ) object = new Scene();

        Object3D.prototype.clone.call(this, object);

        if ( this.fog !== null ) object.fog = this.fog.clone();
        if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

        object.autoUpdate = this.autoUpdate;
        object.matrixAutoUpdate = this.matrixAutoUpdate;

        return object;

    };

    //

    Scene.objectTypes = {};

    Scene.registerObject = function ( objectName, addFn, removeFn ) {

        this.objectTypes[ objectName ] = {

            add: addFn,
            remove: removeFn

        };

    };

    Scene.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Scene.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Scene.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Scene.setInternal = function ( name, value ) { internal[ name ] = value; };
    Scene.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Scene === 'function' ) {
        var t = {}, p = {};
        for ( var i in Scene ) t[i] = Scene[i];
        for ( var i in Scene.prototype ) try { p[i] = Scene.prototype[i] } catch(e) {};
        scope.Scene = Scene.bind( scope );
    } else {
        scope.Scene = Scene;
    }
    internal['constructor'] = Scene;
    scope.Scene.prototype = Scene.prototype;
    for ( var i in t ) scope.Scene[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Scene.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Scene ) {
        for ( var i = 0, il = scope.__Scene.length; i < il; i ++ ) scope.__Scene[ i ]( Scene );
        delete scope.__Scene;
    }

}) ( NWE.gfx );


// src/graphics/cameras/Camera.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author WestLangley / http://github.com/WestLangley
    */



    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }


    var Camera = function ( objInternal ) {

        objInternal = objInternal || {};
        Object3D.getInternal('constructor').call( this, {}, objInternal );
        internal[ this.uuid ] = objInternal;

        this.matrixWorldInverse = new Matrix4();

        this.projectionMatrix = new Matrix4();
        this.projectionMatrixInverse = new Matrix4();

        this.needsUpdate = true;

        //

        this.instanceof = 'Camera';

    };

    Camera.prototype = Object.create( Object3D.prototype );

    Camera.prototype.lookAt = function () {

        // This routine does not support cameras with rotated and/or translated parent(s)

        var m1 = new Matrix4();

        return function ( vector ) {

            m1.lookAt( this.position, vector, this.up );

            this.quaternion.setFromRotationMatrix( m1 );

        };

    }();

    Camera.prototype.clone = function () {

        var camera = new Camera();

        Object3D.prototype.clone.call( this, camera );

        camera.matrixWorldInverse.copy( this.matrixWorldInverse );
        camera.projectionMatrix.copy( this.projectionMatrix );
        camera.projectionMatrixInverse.copy( this.projectionMatrixInverse );

        return camera;

    };

    Camera.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Camera.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Camera.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Camera.setInternal = function ( name, value ) { internal[ name ] = value; };
    Camera.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Camera === 'function' ) {
        var t = {}, p = {};
        for ( var i in Camera ) t[i] = Camera[i];
        for ( var i in Camera.prototype ) try { p[i] = Camera.prototype[i] } catch(e) {};
        scope.Camera = Camera.bind( scope );
    } else {
        scope.Camera = Camera;
    }
    internal['constructor'] = Camera;
    scope.Camera.prototype = Camera.prototype;
    for ( var i in t ) scope.Camera[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Camera.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Camera ) {
        for ( var i = 0, il = scope.__Camera.length; i < il; i ++ ) scope.__Camera[ i ]( Camera );
        delete scope.__Camera;
    }

}) ( NWE.gfx );


// src/graphics/cameras/OrthographicCamera.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var Camera = NWE.gfx.Camera;
    if ( !Camera ) { NWE.gfx.__Camera = (NWE.gfx.__Camera || []); NWE.gfx.__Camera.push( function ( obj ) { Camera = obj; } ); }




    var OrthographicCamera = function ( left, right, top, bottom, near, far, objInternal ) {

        objInternal = objInternal || {};
        Camera.getInternal('constructor').call( this, {}, objInternal );
        internal[ this.uuid ] = objInternal;

        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;

        this.near = ( near !== undefined ) ? near : 0.1;
        this.far = ( far !== undefined ) ? far : 2000;

        this.updateProjectionMatrix();

        //

        this.instanceof = 'OrthographicCamera';

    };

    OrthographicCamera.prototype = Object.create( Camera.prototype );

    OrthographicCamera.prototype.updateProjectionMatrix = function () {

        this.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );

        this.needsUpdate = true;

    };

    OrthographicCamera.prototype.clone = function () {

        var camera = new OrthographicCamera();

        Camera.prototype.clone.call( this, camera );

        camera.left = this.left;
        camera.right = this.right;
        camera.top = this.top;
        camera.bottom = this.bottom;
        
        camera.near = this.near;
        camera.far = this.far;

        return camera;

    };

    OrthographicCamera.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    OrthographicCamera.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    OrthographicCamera.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    OrthographicCamera.setInternal = function ( name, value ) { internal[ name ] = value; };
    OrthographicCamera.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof OrthographicCamera === 'function' ) {
        var t = {}, p = {};
        for ( var i in OrthographicCamera ) t[i] = OrthographicCamera[i];
        for ( var i in OrthographicCamera.prototype ) try { p[i] = OrthographicCamera.prototype[i] } catch(e) {};
        scope.OrthographicCamera = OrthographicCamera.bind( scope );
    } else {
        scope.OrthographicCamera = OrthographicCamera;
    }
    internal['constructor'] = OrthographicCamera;
    scope.OrthographicCamera.prototype = OrthographicCamera.prototype;
    for ( var i in t ) scope.OrthographicCamera[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.OrthographicCamera.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__OrthographicCamera ) {
        for ( var i = 0, il = scope.__OrthographicCamera.length; i < il; i ++ ) scope.__OrthographicCamera[ i ]( OrthographicCamera );
        delete scope.__OrthographicCamera;
    }

}) ( NWE.gfx );


// src/graphics/cameras/PerspectiveCamera.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author greggman / http://games.greggman.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */



    var Camera = NWE.gfx.Camera;
    if ( !Camera ) { NWE.gfx.__Camera = (NWE.gfx.__Camera || []); NWE.gfx.__Camera.push( function ( obj ) { Camera = obj; } ); }

    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }


    var PerspectiveCamera = function ( fov, aspect, near, far, objInternal ) {

        objInternal = objInternal || {};
        Camera.getInternal('constructor').call( this, {}, objInternal );
        internal[ this.uuid ] = objInternal;

        this.fov = fov !== undefined ? fov : 50;
        this.aspect = aspect !== undefined ? aspect : 1;
        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;

        this.updateProjectionMatrix();

        //

        this.instanceof = 'PerspectiveCamera';

    };

    PerspectiveCamera.prototype = Object.create( Camera.prototype );

    /**
     * Uses Focal Length (in mm) to estimate and set FOV
     * 35mm (fullframe) camera is used if frame size is not specified;
     * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
     */

    PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

        if ( frameHeight === undefined ) frameHeight = 24;

        this.fov = 2 * Math.radToDeg( window.Math.atan( frameHeight / ( focalLength * 2 ) ) );
        this.updateProjectionMatrix();

    }

    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or
     * multi-monitor/multi-machine setups.
     *
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
     * the monitors are in grid like this
     *
     *   +---+---+---+
     *   | A | B | C |
     *   +---+---+---+
     *   | D | E | F |
     *   +---+---+---+
     *
     * then for each monitor you would call it like this
     *
     *   var w = 1920;
     *   var h = 1080;
     *   var fullWidth = w * 3;
     *   var fullHeight = h * 2;
     *
     *   --A--
     *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
     *   --B--
     *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
     *   --C--
     *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
     *   --D--
     *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
     *   --E--
     *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
     *   --F--
     *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
     *
     *   Note there is no reason monitors have to be the same size or in a grid.
     */

    PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

        this.fullWidth = fullWidth;
        this.fullHeight = fullHeight;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        this.updateProjectionMatrix();

    };

    PerspectiveCamera.prototype.updateProjectionMatrix = function () {

        if ( this.fullWidth ) {

            var aspect = this.fullWidth / this.fullHeight;
            var top = window.Math.tan( Math.degToRad( this.fov * 0.5 ) ) * this.near;
            var bottom = -top;
            var left = aspect * bottom;
            var right = aspect * top;
            var width = window.Math.abs( right - left );
            var height = window.Math.abs( top - bottom );

            this.projectionMatrix.makeFrustum(
                left + this.x * width / this.fullWidth,
                left + ( this.x + this.width ) * width / this.fullWidth,
                top - ( this.y + this.height ) * height / this.fullHeight,
                top - this.y * height / this.fullHeight,
                this.near,
                this.far
            );

        } else {

            this.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );

        }

        this.needsUpdate = true;

    };

    PerspectiveCamera.prototype.clone = function () {

        var camera = new PerspectiveCamera();

        Camera.prototype.clone.call( this, camera );

        camera.fov = this.fov;
        camera.aspect = this.aspect;
        camera.near = this.near;
        camera.far = this.far;

        camera.updateProjectionMatrix();

        return camera;

    };

    PerspectiveCamera.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    PerspectiveCamera.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    PerspectiveCamera.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    PerspectiveCamera.setInternal = function ( name, value ) { internal[ name ] = value; };
    PerspectiveCamera.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof PerspectiveCamera === 'function' ) {
        var t = {}, p = {};
        for ( var i in PerspectiveCamera ) t[i] = PerspectiveCamera[i];
        for ( var i in PerspectiveCamera.prototype ) try { p[i] = PerspectiveCamera.prototype[i] } catch(e) {};
        scope.PerspectiveCamera = PerspectiveCamera.bind( scope );
    } else {
        scope.PerspectiveCamera = PerspectiveCamera;
    }
    internal['constructor'] = PerspectiveCamera;
    scope.PerspectiveCamera.prototype = PerspectiveCamera.prototype;
    for ( var i in t ) scope.PerspectiveCamera[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.PerspectiveCamera.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__PerspectiveCamera ) {
        for ( var i = 0, il = scope.__PerspectiveCamera.length; i < il; i ++ ) scope.__PerspectiveCamera[ i ]( PerspectiveCamera );
        delete scope.__PerspectiveCamera;
    }

}) ( NWE.gfx );


// src/graphics/renderers/core/RawUniform.js

( function ( scope ) {

    /**
     * author: @ohmed
    */

    var RawUniform = function ( _gl, program, id ) {

        this.id = id;
        this.location = _gl.getUniformLocation( program, id );
        this.needsUpdate = true;
        this.globalLevel = 0;

        //

        this.instanceof = 'RawUniform';

    };

    RawUniform.prototype = {};

    if ( typeof RawUniform === 'function' ) {
        var t = {}, p = {};
        for ( var i in RawUniform ) t[i] = RawUniform[i];
        for ( var i in RawUniform.prototype ) try { p[i] = RawUniform.prototype[i] } catch(e) {};
        scope.RawUniform = RawUniform.bind( scope );
    } else {
        scope.RawUniform = RawUniform;
    }
    scope.RawUniform.prototype = RawUniform.prototype;
    for ( var i in t ) scope.RawUniform[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.RawUniform.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__RawUniform ) {
        for ( var i = 0, il = scope.__RawUniform.length; i < il; i ++ ) scope.__RawUniform[ i ]( RawUniform );
        delete scope.__RawUniform;
    }

}) ( NWE.gfx );


// src/graphics/renderers/core/UniformUtils.js

( function ( scope ) {

    /**
     * author: @ohmed
    */



    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Vec4 = NWE.Vec4;
    if ( !Vec4 ) { NWE.__Vec4 = (NWE.__Vec4 || []); NWE.__Vec4.push( function ( obj ) { Vec4 = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }


    var UniformUtils = {

        clone: function ( source ) {

            var u, p, parameter, parameter_src, uniforms_dst = {};

            for ( u in source ) {

                uniforms_dst[ u ] = {};

                for ( p in source[ u ] ) {

                    parameter_src = source[ u ][ p ];

                    if ( parameter_src instanceof Color ||
                         parameter_src instanceof Vec2 ||
                         parameter_src instanceof Vec3 ||
                         parameter_src instanceof Vec4 ||
                         parameter_src instanceof Matrix4 ||
                         parameter_src instanceof Texture ) {

                        uniforms_dst[ u ][ p ] = parameter_src.clone();

                    } else if ( parameter_src instanceof Array ) {

                        uniforms_dst[ u ][ p ] = parameter_src.slice();

                    } else {

                        uniforms_dst[ u ][ p ] = parameter_src;

                    }

                }

            }

            return uniforms_dst;

        }

    };

    scope.UniformUtils = UniformUtils;
    if ( scope.__UniformUtils ) {
        for ( var i = 0, il = scope.__UniformUtils.length; i < il; i ++ ) scope.__UniformUtils[ i ]( UniformUtils );
        delete scope.__UniformUtils;
    }

}) ( NWE.gfx );


// src/graphics/renderers/core/Program.js

( function ( scope ) {

    /**
     * author: @ohmed
    */

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var ShaderLib = NWE.gfx.ShaderLib;
    if ( !ShaderLib ) { NWE.gfx.__ShaderLib = (NWE.gfx.__ShaderLib || []); NWE.gfx.__ShaderLib.push( function ( obj ) { ShaderLib = obj; } ); }

    var RawUniform = NWE.gfx.RawUniform;
    if ( !RawUniform ) { NWE.gfx.__RawUniform = (NWE.gfx.__RawUniform || []); NWE.gfx.__RawUniform.push( function ( obj ) { RawUniform = obj; } ); }


    var Program = function ( material, parameters ) {

        this.uuid = Math.generateUUID();

        this.shaderID = material.shaderID;
        this.fragmentShader = material.fragmentShader;
        this.vertexShader = material.vertexShader;
        this.uniforms = material.uniforms;
        this.attributes = material.attributes;
        this.varyings = material.varyings;
        this.defines = material.defines;
        this.parameters = parameters;

    };

    Program.prototype.build = function ( renderer ) {

        var _gl = renderer.getContext();

        // Generate code

        if ( typeof this.fragmentShader !== 'string' ) {

            var fragmentShader = '';

            for ( var part in this.fragmentShader ) {

                fragmentShader += this.fragmentShader[ part ] + '\n';

            }

            this.fragmentShader = fragmentShader;

        }

        if ( typeof this.vertexShader !== 'string' ) {

            var vertexShader = '';

            for ( var part in this.vertexShader ) {

                vertexShader += this.vertexShader[part] + '\n';

            }

            this.vertexShader = vertexShader;

        }

        //

        var code = generateCode( this.fragmentShader, this.vertexShader, this.defines, this.parameters );

        // Check if code has been already compiled

        var programs = renderer.programs,
            programInfo,

            p, pl;

        for ( p = 0, pl = programs.length; p < pl; p ++ ) {

            programInfo = programs[ p ];

            if ( programInfo.code === code ) {

                programInfo.usedTimes ++;

                return {

                    subId: programInfo.usedTimes,
                    program: programInfo.program

                };

            }

        }

        // Build program

        var program = _gl.createProgram();

        var customDefines = generateDefines( this.defines );
        var customUniforms = generateUniforms( this.uniforms );
        var customAttributes = generateAttributes( this.attributes );
        var customVaryings = generateVaryings( this.varyings );

        var prefix_vertex = [

            'precision ' + renderer.device.getPrecision() + ' float;',
            'precision ' + renderer.device.getPrecision() + ' int;',

            customDefines,

            renderer.device.supportsVertexTextures() ? '#define VERTEX_TEXTURES' : '',

            this.parameters.map ? '#define USE_MAP' : '',
            this.parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            this.parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            this.parameters.normalMap ? '#define USE_NORMALMAP' : '',
            this.parameters.vertexColors ? '#define USE_COLOR' : '',

            this.parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            this.parameters.flipSided ? '#define FLIP_SIDED' : '',

            customUniforms,
            customAttributes,
            customVaryings,

            ''

        ].join('\n');

        var prefix_fragment = [

            'precision ' + renderer.device.getPrecision() + ' float;',
            'precision ' + renderer.device.getPrecision() + ' int;',

            customDefines,
            customUniforms,
            customVaryings,

            this.parameters.alphaTest ? '#define ALPHATEST ' + this.parameters.alphaTest: '',

            ( this.parameters.fog ) ? '#define USE_FOG' : '',
            ( this.parameters.fogExp ) ? '#define FOG_EXP2' : '',

            this.parameters.map ? '#define USE_MAP' : '',
            this.parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            this.parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            this.parameters.normalMap ? '#define USE_NORMALMAP' : '',
            this.parameters.vertexColors ? '#define USE_COLOR' : '',

            this.parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            this.parameters.flipSided ? '#define FLIP_SIDED' : '',

            ''

        ].join('\n');

        var glVertexShader = getShader( _gl, 'vertex', prefix_vertex + this.vertexShader );
        var glFragmentShader = getShader( _gl, 'fragment', prefix_fragment + this.fragmentShader );

        _gl.attachShader( program, glVertexShader );
        _gl.attachShader( program, glFragmentShader );

        // Force a particular attribute to index 0.
        // because potentially expensive emulation is done by browser if attribute 0 is disabled.

        var index0AttributeName = undefined; // TODO: tmp

        if ( index0AttributeName ) {

            _gl.bindAttribLocation( program, 0, 'position' );

        }

        _gl.linkProgram( program );

        if ( ! _gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {

            Logger.error( 'NWE.gfx.Program.build(): gl.VALIDATE_STATUS\n' + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
            Logger.error( 'NWE.gfx.Program.build(): gl.getError()\n' + _gl.getError() );

        }

        if ( _gl.getProgramInfoLog( program ) !== '' ) {

            var error = _gl.getProgramInfoLog( program );

            if ( error.indexOf( 'WARNING: Output of vertex shader' ) === -1 ) {

                Logger.error( 'NWE.gfx.Program.build(): gl.getProgramInfoLog()\n' + error );

            }

        }

        // clean up

        _gl.deleteShader( glFragmentShader );
        _gl.deleteShader( glVertexShader );

        var identifiers;

        // cache uniform locations

        identifiers = [];

        for ( var u in this.uniforms ) {

            identifiers.push( [ u, this.uniforms[ u ] ] );

        }

        program.uniforms = cacheUniformLocations( _gl, program, identifiers );

        // cache attributes locations

        identifiers = [];

        for ( var a in this.attributes ) {

            identifiers.push( a );

        }

        program.attributes = cacheAttributeLocations( _gl, program, identifiers );

        program.id = renderer.programs_counter ++;

        programs.push({

            program: program,
            code: code,
            usedTimes: 1

        });

        Logger.renderInfo.memory.programs = programs.length;

        return {

            subId: 0,
            program: program

        };

    };

    var getShader = function ( _gl, type, string ) {

        var shader;

        if ( type === 'fragment' ) {

            shader = _gl.createShader( _gl.FRAGMENT_SHADER );

        } else if ( type === 'vertex' ) {

            shader = _gl.createShader( _gl.VERTEX_SHADER );

        }

        _gl.shaderSource( shader, string );
        _gl.compileShader( shader );

        if ( ! _gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {

            Logger.error( 'NWE.gfx.Program getShader():' + _gl.getShaderInfoLog( shader ) );
            Logger.error( 'NWE.gfx.Program getShader():' + addLineNumbers( string ) );
            return null;

        }

        return shader;

    };

    var addLineNumbers = function ( string ) {

        var chunks = string.split( '\n' );

        for ( var i = 0, il = chunks.length; i < il; i ++ ) {

            // Chrome reports shader errors on lines
            // starting counting from 1

            chunks[ i ] = ( i + 1 ) + ': ' + chunks[ i ];

        }

        return chunks.join( '\n' );

    };

    var generateDefines = function ( defines ) {

        var value, chunk,
            chunks = [];

        for ( var d in defines ) {

            value = defines[ d ];
            if ( value === false ) continue;

            chunk = '#define ' + d + ' ' + ( ( typeof value === 'function' ) ? value() : value );
            chunks.push( chunk );

        }

        return chunks.join( '\n' );

    };

    var generateUniforms = function ( uniforms ) {

        var uniform, chunk,
            chunks = [];

        for ( var u in uniforms ) {

            uniform = uniforms[ u ];

            switch ( uniform.type ) {

                case 'i':
                case 'iv':
                case 'iv1':

                    chunk = 'int ' + u;
                    break;

                case 'f':
                case 'fv':
                case 'fv1':

                    chunk = 'float ' + u;
                    break;

                case 'c':
                case 'cv':

                    chunk = 'vec3 ' + u;
                    break;

                case 'v2':
                case 'v2v':

                    chunk = 'vec2 ' + u;
                    break;

                case 'v3':
                case 'v3v':

                    chunk = 'vec3 ' + u;
                    break;

                case 'v4':
                case 'v4v':

                    chunk = 'vec4 ' + u;
                    break;

                case 'm3':
                case 'm3v':

                    chunk = 'mat3 ' + u;
                    break;

                case 'm4':
                case 'm4v':

                    chunk = 'mat4 ' + u;
                    break;

                case 't':
                case 'tv':

                    chunk = 'sampler2D ' + u;
                    break;

                default:

                    Logger.warn( 'NWE.gfx.Program generateAttributes(): unknown attribute type.' );
                    chunk = '';

            }

            if ( chunk !== '' ) {

                if ( uniform.size ) {

                    chunk += '[' + uniform.size + ']';

                }

                chunk = 'uniform ' + chunk + ';';

            }

            chunks.push( chunk );

        }

        return chunks.join( '\n' );

    };

    var generateAttributes = function ( attributes ) {

        var attribute, chunk,
            chunks = [];

        for ( var a in attributes ) {

            attribute = attributes[ a ];

            switch ( attribute.type ) {

                case 'f':

                    chunk = 'attribute float ' + a + ';';
                    break;

                case 'c':

                    chunk = 'attribute vec3 ' + a + ';';
                    break;

                case 'v2':

                    chunk = 'attribute vec2 ' + a + ';';
                    break;

                case 'v3':

                    chunk = 'attribute vec3 ' + a + ';';
                    break;

                case 'v4':

                    chunk = 'attribute vec4 ' + a + ';';
                    break;

                default:

                    Logger.warn( 'NWE.gfx.Program generateAttributes(): unknown attribute type.' );
                    chunk = '';

            }

            chunks.push( chunk );

        }

        return chunks.join( '\n' );

    };

    var generateVaryings = function ( varyings ) {

        var varying, chunk,
            chunks = [];

        for ( var v in varyings ) {

            varying = varyings[ v ];

            switch ( varying.type ) {

                case 'f':

                    chunk = 'varying float ' + v;
                    break;

                case 'c':

                    chunk = 'varying vec3 ' + v;
                    break;

                case 'v2':

                    chunk = 'varying vec2 ' + v;
                    break;

                case 'v3':

                    chunk = 'varying vec3 ' + v;
                    break;

                case 'v4':

                    chunk = 'varying vec4 ' + v;
                    break;

                case 'm3':

                    chunk = 'varying mat3 ' + v;
                    break;

                case 'm4':

                    chunk = 'varying mat4 ' + v;
                    break;

                default:

                    Logger.warn( 'NWE.gfx.Program generateAttributes(): unknown attribute type.' );
                    chunk = '';

            }

            if ( chunk !== '' && varying.size ) {

                chunk += '[' + varying.size + ']';

            }

            chunk += ';';

            chunks.push( chunk );

        }

        return chunks.join( '\n' );

    };

    var generateCode = function ( fragmentShader, vertexShader, defines, parameters ) {

        var chunks = [];

        chunks.push( fragmentShader );
        chunks.push( vertexShader );

        for ( var d in defines ) {

            chunks.push( d );
            chunks.push( defines[ d ] );

        }

        for ( var p in parameters ) {

            chunks.push( p );
            chunks.push( parameters[ p ] );

        }

        return chunks.join();

    };

    var cacheUniformLocations = function ( _gl, program, identifiers ) {

        var uniforms = [];

        for ( var i = 0, il = identifiers.length; i < il; i ++ ) {

            var id = identifiers[ i ][ 0 ];
            var uniform = new RawUniform( _gl, program, id );

            uniform.globalLevel = identifiers[ i ][ 1 ].global;
            uniform.needsUpdate = true;

            uniforms.push([ id, uniform ]);

        }

        return uniforms;

    };

    var cacheAttributeLocations = function ( _gl, program, identifiers ) {

        var attributes = [];

        for ( var i = 0, il = identifiers.length; i < il; i ++ ) {

            var id = identifiers[ i ];

            attributes.push([ id, _gl.getAttribLocation( program, id ) ]);

        }

        return attributes;

    };

    if ( typeof Program === 'function' ) {
        var t = {}, p = {};
        for ( var i in Program ) t[i] = Program[i];
        for ( var i in Program.prototype ) try { p[i] = Program.prototype[i] } catch(e) {};
        scope.Program = Program.bind( scope );
    } else {
        scope.Program = Program;
    }
    scope.Program.prototype = Program.prototype;
    for ( var i in t ) scope.Program[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Program.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Program ) {
        for ( var i = 0, il = scope.__Program.length; i < il; i ++ ) scope.__Program[ i ]( Program );
        delete scope.__Program;
    }

}) ( NWE.gfx );


// src/graphics/renderers/WebGLCapabilities.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var CheckDeviceCapabilities = function ( renderer ) {

        var capabilities = {};

        var _gl;

        if ( ! renderer ) {

            var _canvas = document.createElement( 'canvas' );
            _gl = _canvas.getContext( 'webgl' );

        } else {

            _gl = renderer.getContext();

        }

        // GPU capabilities

        var extensions = [];

        extensions['indexUint'] = _gl.getExtension( 'OES_element_index_uint' );
        extensions['textureFloat'] = _gl.getExtension( 'OES_texture_float' );
        extensions['textureFloatLinear'] = _gl.getExtension( 'OES_texture_float_linear' );
        extensions['standardDerivatives'] = _gl.getExtension( 'OES_standard_derivatives' );
        extensions['textureFilterAnisotropic'] = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
        extensions['compressedTextureS3TC'] = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );

        //

        if ( ! extensions['indexUint'] ) {

            Logger.log( 'NWE.gfx.CheckDeviceCapabilities: Int32 indexes not supported.' );

        }

        if ( ! extensions['textureFloat'] ) {

            Logger.log( 'NWE.gfx.CheckDeviceCapabilities: Float textures not supported.' );

        }

        if ( ! extensions['standardDerivatives'] ) {

            Logger.log( 'NWE.gfx.CheckDeviceCapabilities: Standard derivatives not supported.' );

        }

        if ( ! extensions['textureFilterAnisotropic'] ) {

            Logger.log( 'NWE.gfx.CheckDeviceCapabilities: Anisotropic texture filtering not supported.' );

        }

        if ( ! extensions['compressedTextureS3TC'] ) {

            Logger.log( 'NWE.gfx.CheckDeviceCapabilities: S3TC compressed textures not supported.' );

        }

        var _maxTextures =          _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
        var _maxVertexTextures =    _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
        var _maxTextureSize =       _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
        var _maxCubemapSize =       _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );
        var _maxAnisotropy =        extensions['textureFilterAnisotropic'] ? _gl.getParameter( extensions['textureFilterAnisotropic'].MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

        var _supportsVertexTextures =   ( _maxVertexTextures > 0 );
        var _supportsBoneTextures =     _supportsVertexTextures && extensions['textureFloat'];
        var _supportsIndexUINT =        !!extensions['indexUint'];

        var _compressedTextureFormats = extensions['compressedTextureS3TC'] ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];

        //

        var _vertexShaderPrecisionHighpFloat =      _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
        var _vertexShaderPrecisionMediumpFloat =    _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
        var _vertexShaderPrecisionLowpFloat =       _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

        var _fragmentShaderPrecisionHighpFloat =    _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
        var _fragmentShaderPrecisionMediumpFloat =  _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
        var _fragmentShaderPrecisionLowpFloat =     _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

        var _vertexShaderPrecisionHighpInt =        _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );
        var _vertexShaderPrecisionMediumpInt =      _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );
        var _vertexShaderPrecisionLowpInt =         _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );

        var _fragmentShaderPrecisionHighpInt =      _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );
        var _fragmentShaderPrecisionMediumpInt =    _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );
        var _fragmentShaderPrecisionLowpInt =       _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );

        // clamp precision to maximum available

        var highpAvailable =   _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
        var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

        var _precision = 'highp';

        if ( _precision === 'highp' && ! highpAvailable ) {

            if ( mediumpAvailable ) {

                _precision = 'mediump';
                Logger.warn( 'NWE.gfx.CheckDeviceCapabilities: highp not supported, using mediump' );

            } else {

                _precision = 'lowp';
                Logger.warn( 'NWE.gfx.CheckDeviceCapabilities: highp and mediump not supported, using lowp' );

            }

        }

        if ( _precision === 'mediump' && ! mediumpAvailable ) {

            _precision = 'lowp';
            Logger.warn( 'NWE.gfx.CheckDeviceCapabilities: mediump not supported, using lowp' );

        }

        //

        capabilities.getMaxTextures = function () {

            return _maxTextures;

        };

        capabilities.getMaxVertexTextures = function () {

            return _maxVertexTextures;

        };

        capabilities.getMaxAnisotropy = function () {

            return _maxAnisotropy;

        };

        //

        capabilities.getPrecision = function () {

            return _precision;

        };

        capabilities.getExtension = function ( name ) {

            if ( ! extensions[ name ] ) {

                Logger.warn( 'NWE.CheckDeviceCapabilities.getExtension(): No webGL extension named ' + name + ' found.' );
                return false;

            }

            return extensions[ name ];

        };

        //

        capabilities.supportsIndexUINT = function () {

            return _supportsIndexUINT;

        }

        capabilities.supportsBoneTextures = function () {

            return _supportsBoneTextures;

        };

        capabilities.supportsVertexTextures = function () {

            return _supportsVertexTextures;

        };

        capabilities.pixelRatio = window.devicePixelRatio;

        return capabilities;

    };

    if ( typeof CheckDeviceCapabilities === 'function' ) {
        var t = {}, p = {};
        for ( var i in CheckDeviceCapabilities ) t[i] = CheckDeviceCapabilities[i];
        for ( var i in CheckDeviceCapabilities.prototype ) try { p[i] = CheckDeviceCapabilities.prototype[i] } catch(e) {};
        scope.CheckDeviceCapabilities = CheckDeviceCapabilities.bind( scope );
    } else {
        scope.CheckDeviceCapabilities = CheckDeviceCapabilities;
    }
    scope.CheckDeviceCapabilities.prototype = CheckDeviceCapabilities.prototype;
    for ( var i in t ) scope.CheckDeviceCapabilities[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.CheckDeviceCapabilities.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__CheckDeviceCapabilities ) {
        for ( var i = 0, il = scope.__CheckDeviceCapabilities.length; i < il; i ++ ) scope.__CheckDeviceCapabilities[ i ]( CheckDeviceCapabilities );
        delete scope.__CheckDeviceCapabilities;
    }

}) ( NWE.gfx );


// src/graphics/renderers/DeviceCapabilities.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var CheckDeviceCapabilities = NWE.gfx.CheckDeviceCapabilities;
    if ( !CheckDeviceCapabilities ) { NWE.gfx.__CheckDeviceCapabilities = (NWE.gfx.__CheckDeviceCapabilities || []); NWE.gfx.__CheckDeviceCapabilities.push( function ( obj ) { CheckDeviceCapabilities = obj; } ); }


    var DeviceCapabilities = CheckDeviceCapabilities();

    scope.DeviceCapabilities = DeviceCapabilities;
    if ( scope.__DeviceCapabilities ) {
        for ( var i = 0, il = scope.__DeviceCapabilities.length; i < il; i ++ ) scope.__DeviceCapabilities[ i ]( DeviceCapabilities );
        delete scope.__DeviceCapabilities;
    }

}) ( NWE.gfx );


// src/graphics/renderers/shaders/ShaderLib.js

( function ( scope ) {




    var ShaderLib = {};

    scope.ShaderLib = ShaderLib;
    if ( scope.__ShaderLib ) {
        for ( var i = 0, il = scope.__ShaderLib.length; i < il; i ++ ) scope.__ShaderLib[ i ]( ShaderLib );
        delete scope.__ShaderLib;
    }

}) ( NWE.gfx );


// src/graphics/renderers/shaders/Basic.js

( function ( scope ) {

    /**
     * @author ohmed
     * basic shader [no light support]
     */

    var Basic = function () {

        this.defines = {

        };

        this.attributes = {

            'position':  { type: 'v3' },
            'uv':        { type: 'v2' },
            'color':     { type: 'v3' }

        };

        this.uniforms = {

            'diffuse':      { type: 'c', value: null, global: -1 },
            'opacity':      { type: 'f', value: 1.0, global: -1 },

            'map':          { type: 't', value: null, global: -1 },
            'offsetRepeat': { type: 'v4', value: null, global: -1 },

            'lightMap':     { type: 't', value: null, global: -1 },

            'combine':      { type: 'i', value: 0, global: -1 },

            'fogDensity':   { type: 'f', value: 0.00025, global: 2 },
            'fogNear':      { type: 'f', value: 1, global: 2 },
            'fogFar':       { type: 'f', value: 2000, global: 2 },
            'fogColor':     { type: 'c', value: null, global: 2 },

            'modelMatrix':      { type: 'm4', value: null, global: -1 },
            'modelViewMatrix':  { type: 'm4', value: null, global: -1 },
            'projectionMatrix': { type: 'm4', value: null, global: -1 },
            'viewMatrix':       { type: 'm4', value: null, global: -1 },
            'normalMatrix':     { type: 'm3', value: null, global: -1 },
            'cameraPosition':   { type: 'v3', value: null, global: -1 }

        };

        this.varyings = {

            'vUv':      { type: 'v2' },
            'vColor':   { type: 'v3' }

        };

        this.vertexShader = {

            main: [

                'void main () {',

                '    #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )',
                '        vUv = uv * offsetRepeat.zw + offsetRepeat.xy;',
                '    #endif',

                '    #ifdef USE_COLOR',
                '        vColor = color;',
                '    #endif',

                '    vec4 mvPosition;',
                '    mvPosition = modelViewMatrix * vec4( position, 1.0 );',
                '    gl_Position = projectionMatrix * mvPosition;',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            main: [

                'void main () {',

                '    gl_FragColor = vec4( diffuse, opacity );',

                '    #ifdef USE_MAP',
                '        vec4 texelColor = texture2D( map, vUv );',
                '        gl_FragColor = gl_FragColor * texelColor;',
                '    #endif',

                '    #ifdef USE_COLOR',
                '        gl_FragColor = gl_FragColor * vec4( vColor, opacity );',
                '    #endif',

                '    #ifdef USE_FOG',

                '        float depth = gl_FragCoord.z / gl_FragCoord.w;',

                '        #ifdef FOG_EXP2',

                '            const float LOG2 = 1.442695;',
                '            float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
                '            fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

                '        #else',

                '            float fogFactor = smoothstep( fogNear, fogFar, depth );',

                '        #endif',

                '        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

                '    #endif',

                '}'

            ].join('\n')

        };

    };

    if ( typeof Basic === 'function' ) {
        var t = {}, p = {};
        for ( var i in Basic ) t[i] = Basic[i];
        for ( var i in Basic.prototype ) try { p[i] = Basic.prototype[i] } catch(e) {};
        scope.Basic = Basic.bind( scope );
    } else {
        scope.Basic = Basic;
    }
    scope.Basic.prototype = Basic.prototype;
    for ( var i in t ) scope.Basic[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Basic.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Basic ) {
        for ( var i = 0, il = scope.__Basic.length; i < il; i ++ ) scope.__Basic[ i ]( Basic );
        delete scope.__Basic;
    }

}) ( NWE.gfx.ShaderLib );


// src/graphics/renderers/shaders/Lambert.js

( function ( scope ) {

    /**
     * @author ohmed
     * lambert shader
     */

    var Vec4 = NWE.Vec4;
    if ( !Vec4 ) { NWE.__Vec4 = (NWE.__Vec4 || []); NWE.__Vec4.push( function ( obj ) { Vec4 = obj; } ); }


    var Lambert = function () {

        this.defines = {

            'USE_SHADOWMAP': '1',
            'MAX_SHADOWS':   '1'

        };

        this.attributes = {

            'position':  { type: 'v3' },
            'normal':    { type: 'v3' },
            'uv':        { type: 'v2' },
            'color':     { type: 'c' } // tmp

        };

        this.uniforms = {

            'diffuse':      { type: 'c', value: null , global: -1 },
            'opacity':      { type: 'f', value: 1.0, global: -1 },

            'ambientLightColor':    { type: 'c', value: null, global: 2 },
            'ambient':              { type: 'c', value: null, global: -1 },

            'map':          { type: 't', value: null, global: -1 },
            'offsetRepeat': { type: 'v4', value: new Vec4( 0, 0, 1, 1 ), global: -1 }, // tmp

            'lightMap':     { type: 't', value: null },

            'combine':      { type: 'i', value: 0 },

            'fogDensity':   { type: 'f', value: 0.00025, global: 2 },
            'fogNear':      { type: 'f', value: 1, global: 2 },
            'fogFar':       { type: 'f', value: 2000, global: 2 },
            'fogColor':     { type: 'c', value: null, global: 2 },

            'modelMatrix':      { type: 'm4', value: null, global: -1 },
            'modelViewMatrix':  { type: 'm4', value: null, global: -1 },
            'projectionMatrix': { type: 'm4', value: null, global: -1 },
            'viewMatrix':       { type: 'm4', value: null, global: -1 },
            'normalMatrix':     { type: 'm3', value: null, global: -1 },
            'cameraPosition':   { type: 'v3', value: null, global: -1 },

            'shadowMatrix':     { type: 'm4v', value: [], size: 5, global: -1 },

            'shadowMap':        { type: 'tv', value: [], size: 5, global: -1 },
            'shadowMapSize':    { type: 'v2v', value: [], size: 5, global: -1 },

            'shadowDarkness':   { type: 'fv1', value: [], size: 5, global: -1 },
            'shadowBias':       { type: 'fv1', value: [], size: 5, global: -1 }

        };

        this.varyings = {

            'vUv':              { type: 'v2' },
            'vNormal':          { type: 'v3' },
            'vColor':           { type: 'v3' },
            'vShadowCoord':     { type: 'v4', size: 5 }

        };

        this.vertexShader = {

            main: [

                'void main () {',

                '    #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_SHADOWMAP )',
                '        vUv = uv + offsetRepeat.xy;',
                '    #endif',

                '    #ifdef USE_COLOR',
                '        vColor = color;',
                '    #endif',

                '    vNormal = normal;',

                '    vec4 mvPosition;',
                '    mvPosition = modelViewMatrix * vec4( position, 1.0 );',
                '    gl_Position = projectionMatrix * mvPosition;',

                '    #ifdef USE_SHADOWMAP',

                '        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',

                '        for ( int i = 0; i < MAX_SHADOWS; i ++ ) {',

                '            vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;',

                '        }',

                '    #endif',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            unpackDepth: [

                'float unpackDepth ( const in vec4 rgba_depth ) {',

                '    const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );',
                '    float depth = dot( rgba_depth, bit_shift );',
                '    return depth;',

                '}'

            ].join('\n'),

            inputToLinear: [
                
                'vec3 inputToLinear ( in vec3 a ) {',

                '    #ifdef GAMMA_INPUT',

                '        return pow( a, vec3( float( GAMMA_FACTOR ) ) );',

                '     #else',

                '        return a;',

                '    #endif',

                '}'

            ].join('\n'),

            main: [

                'void main () {',

                '    vec3 sunDirrection = vec3( 0.5, 0.5, 0.5 );',

                '    gl_FragColor = vec4( diffuse, opacity );',

                '    #ifdef USE_MAP',
                '        vec4 texelColor = texture2D( map, vUv );',
                '        gl_FragColor = gl_FragColor * texelColor;',
                '    #endif',

                '    #ifdef USE_COLOR',
                '        gl_FragColor = gl_FragColor * vec4( vColor, opacity );',
                '    #endif',

                // todo: light support.

                '    vec3 light = vec3( min( 1.0, max( 0.0, dot( vNormal, normalize(sunDirrection) ) ) ) ) * ambientLightColor * ambient + ambientLightColor * ambient * 0.5;',
                '    gl_FragColor = vec4( gl_FragColor.rgb * light, gl_FragColor.a );',

                '    #ifdef USE_FOG',

                '        float depth = gl_FragCoord.z / gl_FragCoord.w;',

                '        #ifdef FOG_EXP2',

                '            const float LOG2 = 1.442695;',
                '            float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
                '            fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

                '        #else',

                '            float fogFactor = smoothstep( fogNear, fogFar, depth );',

                '        #endif',

                '        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

                '    #endif',

                // shadow

                '    vec3 outgoingLight = gl_FragColor.rgb;',

                '    #ifdef USE_SHADOWMAP',

                '        float fDepth;',
                '        vec3 shadowColor = vec3( 1.0 );',

                '        for ( int i = 0; i < MAX_SHADOWS; i ++ ) {',

                '            vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;',

                '            // if ( something && something ) breaks ATI OpenGL shader compiler',
                '            // if ( all( something, something ) ) using this instead',

                '            bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );',
                '            bool inFrustum = all( inFrustumVec );',

                '            // don\'t shadow pixels outside of light frustum',
                '            // use just first frustum (for cascades)',
                '            // don\'t shadow pixels behind far plane of light frustum',

                '            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );',

                '            bool frustumTest = all( frustumTestVec );',

                '            if ( frustumTest ) {',

                '                shadowCoord.z += shadowBias[ i ];',

                '                vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );',
                '                float fDepth = unpackDepth( rgbaDepth );',

                '                if ( fDepth < shadowCoord.z / 1.0 ) {',

                '                    // spot with multiple shadows is darker',

                '                    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );',

                '                    // spot with multiple shadows has the same color as single shadow spot',
                '                    // shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );',

                '                }',

                '            }',

                '        }',

                '        // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014',
                '        shadowColor = inputToLinear( shadowColor );',

                '        outgoingLight = outgoingLight * shadowColor;',

                '    #endif',

                '    gl_FragColor = vec4( outgoingLight, 1.0 );',

                '}'

            ].join('\n')

        };

    };

    if ( typeof Lambert === 'function' ) {
        var t = {}, p = {};
        for ( var i in Lambert ) t[i] = Lambert[i];
        for ( var i in Lambert.prototype ) try { p[i] = Lambert.prototype[i] } catch(e) {};
        scope.Lambert = Lambert.bind( scope );
    } else {
        scope.Lambert = Lambert;
    }
    scope.Lambert.prototype = Lambert.prototype;
    for ( var i in t ) scope.Lambert[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Lambert.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Lambert ) {
        for ( var i = 0, il = scope.__Lambert.length; i < il; i ++ ) scope.__Lambert[ i ]( Lambert );
        delete scope.__Lambert;
    }

}) ( NWE.gfx.ShaderLib );


// src/graphics/renderers/shaders/DepthRGBA.js

( function ( scope ) {

    /**
     * @author ohmed
     * depth encoding into RGBA texture
     *
     * based on SpiderGL shadow map example
     * http://spidergl.org/example.php?id=6
     *
     * originally from
     * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
     *
     * see also
     * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
     */


    // DepthRGBA shader

    var DepthRGBA = function () {

        this.defines = {

        };

        this.attributes = {

            'position':  { type: 'v3' },
            'uv':        { type: 'v2' }

        };

        this.uniforms = {

            'objectTexture':    { type: 't', value: null, global: -1 },

            'modelMatrix':      { type: 'm4', value: null, global: -1 },
            'modelViewMatrix':  { type: 'm4', value: null, global: -1 },
            'projectionMatrix': { type: 'm4', value: null, global: -1 },
            'viewMatrix':       { type: 'm4', value: null, global: -1 },
            'normalMatrix':     { type: 'm3', value: null, global: -1 },
            'cameraPosition':   { type: 'v3', value: null, global: -1 }

        };

        this.varyings = {

            'vUv': { type: 'v2' }

        };

        this.vertexShader = {

            main: [

                'void main () {',

                '   vUv = uv;',

                '   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

                '}'

            ].join('\n'),

        };

        this.fragmentShader = {

            pack_depth: [

                'vec4 pack_depth ( const in float depth ) {',

                '    const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );',
                '    const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );',
                '    vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );',
                // '     vec4 res = fract( depth * bit_shift );',
                '    res -= res.xxyz * bit_mask;',
                '    return res;',

                '}'

            ].join('\n'),

            main: [

                'void main () {',

                '    vec4 pixel = texture2D( objectTexture, vUv );',

                '    if ( pixel.a < 0.5 ) discard;',

                '    gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );',

                '}'

            ].join('\n')

        };

    };

    if ( typeof DepthRGBA === 'function' ) {
        var t = {}, p = {};
        for ( var i in DepthRGBA ) t[i] = DepthRGBA[i];
        for ( var i in DepthRGBA.prototype ) try { p[i] = DepthRGBA.prototype[i] } catch(e) {};
        scope.DepthRGBA = DepthRGBA.bind( scope );
    } else {
        scope.DepthRGBA = DepthRGBA;
    }
    scope.DepthRGBA.prototype = DepthRGBA.prototype;
    for ( var i in t ) scope.DepthRGBA[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DepthRGBA.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DepthRGBA ) {
        for ( var i = 0, il = scope.__DepthRGBA.length; i < il; i ++ ) scope.__DepthRGBA[ i ]( DepthRGBA );
        delete scope.__DepthRGBA;
    }

}) ( NWE.gfx.ShaderLib );


// src/graphics/renderers/shaders/BasicParticle.js

( function ( scope ) {

    /**
     * @author ohmed
     * basic particle shader [no light support]
     */

    var BasicParticle = function () {

        this.defines = {

        };

        this.attributes = {

            'position':  { type: 'v3' },
            'color':     { type: 'v3' }

        };

        this.uniforms = {

            'opacity':      { type: 'f', value: 1 },
            'size':         { type: 'f', value: 1, global: -1 },
            'scale':        { type: 'f', value: 500, global: -1 },
            'psColor':      { type: 'c', value: null, global: -1 },

            'fogDensity':   { type: 'f', value: 0.00025, global: 2 },
            'fogNear':      { type: 'f', value: 1, global: 2 },
            'fogFar':       { type: 'f', value: 2000, global: 2 },
            'fogColor':     { type: 'c', value: null, global: 2 },

            'modelViewMatrix':  { type: 'm4', value: null, global: 2 },
            'projectionMatrix': { type: 'm4', value: null, global: 2 }

        };

        this.varyings = {

            'vColor':   { type: 'v3' }

        };

        this.vertexShader = {

            main: [

                'void main () {',

                '   vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',

                '   #ifdef USE_SIZEATTENUATION',
                '       gl_PointSize = size * ( scale / length( mvPosition.xyz ) );',
                '   #else',
                '       gl_PointSize = size;',
                '   #endif',

                '   gl_Position = projectionMatrix * mvPosition;',

                '   #ifdef USE_COLOR',
                '       vColor = color;',
                '   #endif',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            main: [

                'void main () {',

                '    gl_FragColor = vec4( 1.0 );',

                '    #ifdef USE_COLOR',
                '        gl_FragColor = gl_FragColor * vec4( vColor, opacity );',
                '    #endif',

                '   #ifdef USE_FOG',

                '       float depth = gl_FragCoord.z / gl_FragCoord.w;',

                '       #ifdef FOG_EXP2',

                '          const float LOG2 = 1.442695;',
                '          float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
                '          fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

                '       #else',

                '           float fogFactor = smoothstep( fogNear, fogFar, depth );',

                '       #endif',

                '       gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

                '   #endif',

                '}'

            ].join('\n')

        };

    };

    if ( typeof BasicParticle === 'function' ) {
        var t = {}, p = {};
        for ( var i in BasicParticle ) t[i] = BasicParticle[i];
        for ( var i in BasicParticle.prototype ) try { p[i] = BasicParticle.prototype[i] } catch(e) {};
        scope.BasicParticle = BasicParticle.bind( scope );
    } else {
        scope.BasicParticle = BasicParticle;
    }
    scope.BasicParticle.prototype = BasicParticle.prototype;
    for ( var i in t ) scope.BasicParticle[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.BasicParticle.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__BasicParticle ) {
        for ( var i = 0, il = scope.__BasicParticle.length; i < il; i ++ ) scope.__BasicParticle[ i ]( BasicParticle );
        delete scope.__BasicParticle;
    }

}) ( NWE.gfx.ShaderLib );


// src/graphics/materials/Material.js

( function ( scope ) {

    /**
     * @ohmed
     */



    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }

    var ShaderLib = NWE.gfx.ShaderLib;
    if ( !ShaderLib ) { NWE.gfx.__ShaderLib = (NWE.gfx.__ShaderLib || []); NWE.gfx.__ShaderLib.push( function ( obj ) { ShaderLib = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var Material = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        this.uuid = Math.generateUUID();
        internal[ this.uuid ] = objInternal;

        this.id = NWE.gfx.MaterialIdCount ++;

        this.name = params.name || '';

        this.side = Const.FrontSide;

        this.opacity = 1;
        this.transparent = false;

        this.blending = Const.NormalBlending;

        this.blendSrc = Const.SrcAlphaFactor;
        this.blendDst = Const.OneMinusSrcAlphaFactor;
        this.blendEquation = Const.AddEquation;

        this.depthTest = true;
        this.depthWrite = true;

        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;

        this.alphaTest = 0;

        this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

        this.visible = true;

        this.needsUpdate = true;

        this.programId = false;

        if ( ShaderLib[ this.shaderID ] ) {

            var shaderData = new ShaderLib[ this.shaderID ]();

            this.defines = shaderData.defines;
            this.uniforms = shaderData.uniforms;
            this.attributes = shaderData.attributes;
            this.varyings = shaderData.varyings;
            this.fragmentShader = shaderData.fragmentShader;
            this.vertexShader = shaderData.vertexShader;

        } else {

            this.defines = {};
            this.uniforms = {};
            this.attributes = {};
            this.varyings = {};
            this.fragmentShader = 'void main () {}';
            this.vertexShader = 'void main () {}';

        }

        this.instanceof = 'Material';

    };

    Material.prototype = {

        constructor: Material,

        setValues: function ( values ) {

            if ( values === undefined ) return;

            for ( var key in values ) {

                var newValue = values[ key ];

                if ( newValue === undefined ) {

                    Logger.warn( 'NWE.gfx.Material.setValues(): \'' + key + '\' parameter is undefined.' );
                    continue;

                }

                if ( key in this ) {

                    var currentValue = this[ key ];

                    if ( currentValue instanceof Color ) {

                        currentValue.set( newValue );

                    } else if ( currentValue instanceof Vec3 && newValue instanceof Vec3 ) {

                        currentValue.copy( newValue );

                    } else if ( key == 'overdraw') {

                        // ensure overdraw is backwards-compatable with legacy boolean type
                        this[ key ] = Number( newValue );

                    } else {

                        this[ key ] = newValue;

                    }

                }

            }

        },

        clone: function ( material ) {

            if ( material === undefined ) material = new Material();

            material.name = this.name;

            material.side = this.side;

            material.opacity = this.opacity;
            material.transparent = this.transparent;

            material.blending = this.blending;

            material.blendSrc = this.blendSrc;
            material.blendDst = this.blendDst;
            material.blendEquation = this.blendEquation;

            material.depthTest = this.depthTest;
            material.depthWrite = this.depthWrite;

            material.polygonOffset = this.polygonOffset;
            material.polygonOffsetFactor = this.polygonOffsetFactor;
            material.polygonOffsetUnits = this.polygonOffsetUnits;

            material.alphaTest = this.alphaTest;

            material.overdraw = this.overdraw;

            material.visible = this.visible;

            // clone shader params

            var shaderData = new ShaderLib[ material.shaderID ]();

            material.defines = shaderData.defines;
            material.uniforms = shaderData.uniforms;
            material.attributes = shaderData.attributes;
            material.varyings = shaderData.varyings;
            material.fragmentShader = shaderData.fragmentShader;
            material.vertexShader = shaderData.vertexShader;

            for ( var key in material.defines ) {

                material.defines[ key ] = this.defines[ key ];

            }

            for ( var key in material.uniforms ) {

                var uniform = material.uniforms[ key ];
                var source = this.uniforms[ key ];

                if ( uniform.type === 'f' || uniform.type === 'i' ) {

                    uniform.value = source.value;

                } else if ( uniform.type === 'c' || uniform.type === 'v2' || uniform.type === 'v3' || uniform.type === 'v4' || uniform.type === 'm3' || uniform.type === 'm4' || uniform.type === 't' ) {

                    uniform.value = ( source.value ) ? source.value.clone() : null;

                }

                uniform.global = source.global;
                uniform.needsUpdate = true;

            }

            // todo: same as uniform clone for attribures, varyings

            //

            return material;

        },

        dispose: function () {

            this.dispatchEvent( { type: 'dispose' } );

            for ( var i in this ) {

                delete this[i];

            }

        }

    };

    EventDispatcher.prototype.apply( Material.prototype );

    NWE.gfx.MaterialIdCount = 0;


    Material.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Material.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Material.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Material.setInternal = function ( name, value ) { internal[ name ] = value; };
    Material.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Material === 'function' ) {
        var t = {}, p = {};
        for ( var i in Material ) t[i] = Material[i];
        for ( var i in Material.prototype ) try { p[i] = Material.prototype[i] } catch(e) {};
        scope.Material = Material.bind( scope );
    } else {
        scope.Material = Material;
    }
    internal['constructor'] = Material;
    scope.Material.prototype = Material.prototype;
    for ( var i in t ) scope.Material[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Material.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Material ) {
        for ( var i = 0, il = scope.__Material.length; i < il; i ++ ) scope.__Material[ i ]( Material );
        delete scope.__Material;
    }

}) ( NWE.gfx );


// src/graphics/materials/LineBasicMaterial.js

( function ( scope ) {

    /**
     * @ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var LineBasicMaterial = function ( params, objInternal ) {

        this.shaderID = 'Basic';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.color = new Color( 0xffffff );

        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';

        this.vertexColors = false;

        this.fog = true;

        this.setValues( params );

        this.instanceof = 'LineBasicMaterial';

    };

    LineBasicMaterial.prototype = Object.create( Material.prototype );

    LineBasicMaterial.prototype.clone = function () {

        var material = new LineBasicMaterial();

        Material.prototype.clone.call( this, material );

        material.color.copy( this.color );

        material.linewidth = this.linewidth;
        material.linecap = this.linecap;
        material.linejoin = this.linejoin;

        material.vertexColors = this.vertexColors;

        material.fog = this.fog;

        return material;

    };

    LineBasicMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    LineBasicMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    LineBasicMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    LineBasicMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    LineBasicMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof LineBasicMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in LineBasicMaterial ) t[i] = LineBasicMaterial[i];
        for ( var i in LineBasicMaterial.prototype ) try { p[i] = LineBasicMaterial.prototype[i] } catch(e) {};
        scope.LineBasicMaterial = LineBasicMaterial.bind( scope );
    } else {
        scope.LineBasicMaterial = LineBasicMaterial;
    }
    internal['constructor'] = LineBasicMaterial;
    scope.LineBasicMaterial.prototype = LineBasicMaterial.prototype;
    for ( var i in t ) scope.LineBasicMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.LineBasicMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__LineBasicMaterial ) {
        for ( var i = 0, il = scope.__LineBasicMaterial.length; i < il; i ++ ) scope.__LineBasicMaterial[ i ]( LineBasicMaterial );
        delete scope.__LineBasicMaterial;
    }

}) ( NWE.gfx );


// src/graphics/materials/LineDashedMaterial.js

( function ( scope ) {

    /**
     * @ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var LineDashedMaterial = NWE.gfx.LineDashedMaterial;
    if ( !LineDashedMaterial ) { NWE.gfx.__LineDashedMaterial = (NWE.gfx.__LineDashedMaterial || []); NWE.gfx.__LineDashedMaterial.push( function ( obj ) { LineDashedMaterial = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var LineDashedMaterial = function ( params, objInternal ) {

        this.shaderID = 'Dashed';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.color = new Color( 0xffffff );

        this.linewidth = 1;

        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;

        this.vertexColors = false;

        this.fog = true;

        this.setValues( params );

        this.instanceof = 'LineDashedMaterial';

    };

    LineDashedMaterial.prototype = Object.create( Material.prototype );

    LineDashedMaterial.prototype.clone = function () {

        var material = new LineDashedMaterial();

        Material.prototype.clone.call( this, material );

        material.color.copy( this.color );

        material.linewidth = this.linewidth;

        material.scale = this.scale;
        material.dashSize = this.dashSize;
        material.gapSize = this.gapSize;

        material.vertexColors = this.vertexColors;

        material.fog = this.fog;

        return material;

    };

    LineDashedMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    LineDashedMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    LineDashedMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    LineDashedMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    LineDashedMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof LineDashedMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in LineDashedMaterial ) t[i] = LineDashedMaterial[i];
        for ( var i in LineDashedMaterial.prototype ) try { p[i] = LineDashedMaterial.prototype[i] } catch(e) {};
        scope.LineDashedMaterial = LineDashedMaterial.bind( scope );
    } else {
        scope.LineDashedMaterial = LineDashedMaterial;
    }
    internal['constructor'] = LineDashedMaterial;
    scope.LineDashedMaterial.prototype = LineDashedMaterial.prototype;
    for ( var i in t ) scope.LineDashedMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.LineDashedMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__LineDashedMaterial ) {
        for ( var i = 0, il = scope.__LineDashedMaterial.length; i < il; i ++ ) scope.__LineDashedMaterial[ i ]( LineDashedMaterial );
        delete scope.__LineDashedMaterial;
    }

}) ( NWE.gfx );


// src/graphics/materials/MeshBasicMaterial.js

( function ( scope ) {

    /**
     * @ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Vec4 = NWE.Vec4;
    if ( !Vec4 ) { NWE.__Vec4 = (NWE.__Vec4 || []); NWE.__Vec4.push( function ( obj ) { Vec4 = obj; } ); }


    var MeshBasicMaterial = function ( params, objInternal ) {

        this.shaderID = 'Basic';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.color = new Color( 0xffffff ); // emissive

        this.map = null;

        this.lightMap = null;

        this.combine = Const.MultiplyOperation;

        this.fog = true;

        this.shading = Const.SmoothShading;

        this.vertexColors = Const.NoColors;

        this.setValues( params );

        this.uniforms['offsetRepeat'].value = new Vec4( 0, 0, 1, 1 );

        this.instanceof = 'MeshBasicMaterial';

    };

    MeshBasicMaterial.prototype = Object.create( Material.prototype );

    MeshBasicMaterial.prototype.clone = function () {

        var material = new MeshBasicMaterial();

        Material.prototype.clone.call( this, material );

        material.color.copy( this.color );

        material.map = this.map;

        material.lightMap = this.lightMap;

        material.combine = this.combine;

        material.fog = this.fog;

        material.shading = this.shading;

        material.vertexColors = this.vertexColors;

        return material;

    };

    MeshBasicMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    MeshBasicMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    MeshBasicMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    MeshBasicMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    MeshBasicMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof MeshBasicMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in MeshBasicMaterial ) t[i] = MeshBasicMaterial[i];
        for ( var i in MeshBasicMaterial.prototype ) try { p[i] = MeshBasicMaterial.prototype[i] } catch(e) {};
        scope.MeshBasicMaterial = MeshBasicMaterial.bind( scope );
    } else {
        scope.MeshBasicMaterial = MeshBasicMaterial;
    }
    internal['constructor'] = MeshBasicMaterial;
    scope.MeshBasicMaterial.prototype = MeshBasicMaterial.prototype;
    for ( var i in t ) scope.MeshBasicMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.MeshBasicMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__MeshBasicMaterial ) {
        for ( var i = 0, il = scope.__MeshBasicMaterial.length; i < il; i ++ ) scope.__MeshBasicMaterial[ i ]( MeshBasicMaterial );
        delete scope.__MeshBasicMaterial;
    }

}) ( NWE.gfx );


// src/graphics/materials/MeshLambertMaterial.js

( function ( scope ) {

    /**
     * @ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Vec4 = NWE.Vec4;
    if ( !Vec4 ) { NWE.__Vec4 = (NWE.__Vec4 || []); NWE.__Vec4.push( function ( obj ) { Vec4 = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var MeshLambertMaterial = function ( params, objInternal ) {

        this.shaderID = 'Lambert';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.color = new Color( 0xffffff ); // diffuse
        this.ambient = new Color( 0xffffff );
        this.emissive = new Color( 0x000000 );

        this.map = null;

        this.lightMap = null;

        this.combine = Const.MultiplyOperation;

        this.fog = true;

        this.shading = Const.SmoothShading;

        this.vertexColors = Const.NoColors;

        this.setValues( params );

        this.uniforms['offsetRepeat'].value = new Vec4();

        this.instanceof = 'MeshLambertMaterial';

    };

    MeshLambertMaterial.prototype = Object.create( Material.prototype );

    MeshLambertMaterial.prototype.clone = function () {

        var material = new MeshLambertMaterial();

        Material.prototype.clone.call( this, material );

        material.color.copy( this.color );
        material.ambient.copy( this.ambient );
        material.emissive.copy( this.emissive );

        material.map = this.map;

        material.lightMap = this.lightMap;

        material.combine = this.combine;

        material.fog = this.fog;

        material.shading = this.shading;

        material.vertexColors = this.vertexColors;

        return material;

    };

    MeshLambertMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    MeshLambertMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    MeshLambertMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    MeshLambertMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    MeshLambertMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof MeshLambertMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in MeshLambertMaterial ) t[i] = MeshLambertMaterial[i];
        for ( var i in MeshLambertMaterial.prototype ) try { p[i] = MeshLambertMaterial.prototype[i] } catch(e) {};
        scope.MeshLambertMaterial = MeshLambertMaterial.bind( scope );
    } else {
        scope.MeshLambertMaterial = MeshLambertMaterial;
    }
    internal['constructor'] = MeshLambertMaterial;
    scope.MeshLambertMaterial.prototype = MeshLambertMaterial.prototype;
    for ( var i in t ) scope.MeshLambertMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.MeshLambertMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__MeshLambertMaterial ) {
        for ( var i = 0, il = scope.__MeshLambertMaterial.length; i < il; i ++ ) scope.__MeshLambertMaterial[ i ]( MeshLambertMaterial );
        delete scope.__MeshLambertMaterial;
    }

}) ( NWE.gfx );


// src/graphics/materials/MeshDepthMaterial.js

( function ( scope ) {

    /**
     * @ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }


    var MeshDepthMaterial = function ( params, objInternal ) {

        this.shaderID = 'Depth';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.setValues( params );

        this.instanceof = 'MeshDepthMaterial';

    };

    MeshDepthMaterial.prototype = Object.create( Material.prototype );

    MeshDepthMaterial.prototype.clone = function () {

        var material = new MeshDepthMaterial();

        Material.prototype.clone.call( this, material );

        return material;

    };

    MeshDepthMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    MeshDepthMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    MeshDepthMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    MeshDepthMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    MeshDepthMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof MeshDepthMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in MeshDepthMaterial ) t[i] = MeshDepthMaterial[i];
        for ( var i in MeshDepthMaterial.prototype ) try { p[i] = MeshDepthMaterial.prototype[i] } catch(e) {};
        scope.MeshDepthMaterial = MeshDepthMaterial.bind( scope );
    } else {
        scope.MeshDepthMaterial = MeshDepthMaterial;
    }
    internal['constructor'] = MeshDepthMaterial;
    scope.MeshDepthMaterial.prototype = MeshDepthMaterial.prototype;
    for ( var i in t ) scope.MeshDepthMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.MeshDepthMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__MeshDepthMaterial ) {
        for ( var i = 0, il = scope.__MeshDepthMaterial.length; i < il; i ++ ) scope.__MeshDepthMaterial[ i ]( MeshDepthMaterial );
        delete scope.__MeshDepthMaterial;
    }

}) ( NWE.gfx );


// src/graphics/materials/MeshNormalMaterial.js

( function ( scope ) {

    /**
     * @ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var MeshNormalMaterial = function ( params, objInternal ) {

        this.shaderID = 'Normal';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.shading = Const.FlatShading;

        this.wireframe = false;
        this.wireframeLinewidth = 1;

        this.setValues( params );

        this.instanceof = 'MeshNormalMaterial';

    };

    MeshNormalMaterial.prototype = Object.create( Material.prototype );

    MeshNormalMaterial.prototype.clone = function () {

        var material = new MeshNormalMaterial();

        Material.prototype.clone.call( this, material );

        material.shading = this.shading;

        material.wireframe = this.wireframe;
        material.wireframeLinewidth = this.wireframeLinewidth;

        return material;

    };

    MeshNormalMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    MeshNormalMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    MeshNormalMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    MeshNormalMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    MeshNormalMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof MeshNormalMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in MeshNormalMaterial ) t[i] = MeshNormalMaterial[i];
        for ( var i in MeshNormalMaterial.prototype ) try { p[i] = MeshNormalMaterial.prototype[i] } catch(e) {};
        scope.MeshNormalMaterial = MeshNormalMaterial.bind( scope );
    } else {
        scope.MeshNormalMaterial = MeshNormalMaterial;
    }
    internal['constructor'] = MeshNormalMaterial;
    scope.MeshNormalMaterial.prototype = MeshNormalMaterial.prototype;
    for ( var i in t ) scope.MeshNormalMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.MeshNormalMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__MeshNormalMaterial ) {
        for ( var i = 0, il = scope.__MeshNormalMaterial.length; i < il; i ++ ) scope.__MeshNormalMaterial[ i ]( MeshNormalMaterial );
        delete scope.__MeshNormalMaterial;
    }

}) ( NWE.gfx );


// src/graphics/materials/ShaderMaterial.js

( function ( scope ) {

    /**
     * @ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var UniformUtils = NWE.gfx.UniformUtils;
    if ( !UniformUtils ) { NWE.gfx.__UniformUtils = (NWE.gfx.__UniformUtils || []); NWE.gfx.__UniformUtils.push( function ( obj ) { UniformUtils = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var ShaderMaterial = function ( params, objInternal ) {

        this.shaderID = 'Custom';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.shading = Const.SmoothShading;

        this.fog = false; // set to use scene fog

        this.vertexColors = Const.NoColors; // set to use "color" attribute stream

        this.setValues( params );

        this.instanceof = 'ShaderMaterial';

    };

    ShaderMaterial.prototype = Object.create( Material.prototype );

    ShaderMaterial.prototype.clone = function () {

        var material = new ShaderMaterial();

        Material.prototype.clone.call( this, material );

        material.fragmentShader = this.fragmentShader;
        material.vertexShader = this.vertexShader;

        material.uniforms = UniformUtils.clone( this.uniforms );
        material.attributes = this.attributes; // clone! not set.
        material.defines = this.defines; // clone! not set.
        material.varyings = this.varyings; // clone! not set.

        material.shading = this.shading;

        material.fog = this.fog;

        material.vertexColors = this.vertexColors;

        return material;

    };

    ShaderMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    ShaderMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    ShaderMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    ShaderMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    ShaderMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof ShaderMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in ShaderMaterial ) t[i] = ShaderMaterial[i];
        for ( var i in ShaderMaterial.prototype ) try { p[i] = ShaderMaterial.prototype[i] } catch(e) {};
        scope.ShaderMaterial = ShaderMaterial.bind( scope );
    } else {
        scope.ShaderMaterial = ShaderMaterial;
    }
    internal['constructor'] = ShaderMaterial;
    scope.ShaderMaterial.prototype = ShaderMaterial.prototype;
    for ( var i in t ) scope.ShaderMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.ShaderMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__ShaderMaterial ) {
        for ( var i = 0, il = scope.__ShaderMaterial.length; i < il; i ++ ) scope.__ShaderMaterial[ i ]( ShaderMaterial );
        delete scope.__ShaderMaterial;
    }

}) ( NWE.gfx );


// src/graphics/materials/SpriteMaterial.js

( function ( scope ) {

    /**
     * @ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }


    var SpriteMaterial = function ( params, objInternal ) {

        this.shaderID = 'Sprite';

        params = params || {};

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, objInternal );
        internal[ this.uuid ] = objInternal;

        // defaults

        this.color = new Color( 0xffffff );
        this.map = null;

        this.rotation = 0;

        this.fog = false;

        this.uvOffset = params.uvScale || new Vec2( 0, 0 );
        this.uvScale  = params.uvOffset || new Vec2( 1, 1 );

        // set parameters

        this.setValues( params );

        //

        this.uniforms['scale'].value = params.scale;
        this.uniforms['map'].value = params.map;
        this.uniforms['uvScale'].value = params.uvScale;
        this.uniforms['uvOffset'].value = params.uvOffset;

        this.instanceof = 'SpriteMaterial';

    };

    SpriteMaterial.prototype = Object.create( Material.prototype );

    SpriteMaterial.prototype.clone = function () {

        var material = new SpriteMaterial();

        Material.prototype.clone.call( this, material );

        material.color.copy( this.color );
        material.map = this.map;

        material.rotation = this.rotation;

        material.uvOffset.copy( this.uvOffset );
        material.uvScale.copy( this.uvScale );

        material.fog = this.fog;

        return material;

    };

    SpriteMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    SpriteMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    SpriteMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    SpriteMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    SpriteMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof SpriteMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in SpriteMaterial ) t[i] = SpriteMaterial[i];
        for ( var i in SpriteMaterial.prototype ) try { p[i] = SpriteMaterial.prototype[i] } catch(e) {};
        scope.SpriteMaterial = SpriteMaterial.bind( scope );
    } else {
        scope.SpriteMaterial = SpriteMaterial;
    }
    internal['constructor'] = SpriteMaterial;
    scope.SpriteMaterial.prototype = SpriteMaterial.prototype;
    for ( var i in t ) scope.SpriteMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.SpriteMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__SpriteMaterial ) {
        for ( var i = 0, il = scope.__SpriteMaterial.length; i < il; i ++ ) scope.__SpriteMaterial[ i ]( SpriteMaterial );
        delete scope.__SpriteMaterial;
    }

}) ( NWE.gfx );


// src/graphics/materials/PointCloudMaterial.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * params = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  size: <float>,
     *  sizeAttenuation: <bool>,
     *
     *  blending: THREE.NormalBlending,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  vertexColors: <bool>,
     *
     *  fog: <bool>
     * }
     */



    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var PointCloudMaterial = function ( params, objInternal ) {

        this.shaderID = 'BasicParticle';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.color = new Color( 0xffffff );

        this.map = null;

        this.size = 1;
        this.sizeAttenuation = ( params.sizeAttenuation === undefined ) ? true : params.sizeAttenuation;

        this.vertexColors = Const.NoColors;

        this.fog = true;

        this.setValues( params );

        this.uniforms['size'].value = params.size || this.uniforms['size'].value;
        this.uniforms['scale'].value = params.scale || this.uniforms['scale'].value;

        this.defines['USE_SIZEATTENUATION'] = this.sizeAttenuation;

        this.instanceof = 'PointCloudMaterial';

    };

    PointCloudMaterial.prototype = Object.create( Material.prototype );
    PointCloudMaterial.prototype.constructor = PointCloudMaterial;

    PointCloudMaterial.prototype.clone = function () {

        var material = new PointCloudMaterial();

        Material.prototype.clone.call( this, material );

        material.color.copy( this.color );

        material.map = this.map;

        material.size = this.size;
        material.sizeAttenuation = this.sizeAttenuation;

        material.vertexColors = this.vertexColors;

        material.fog = this.fog;

        return material;

    };

    PointCloudMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    PointCloudMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    PointCloudMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    PointCloudMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    PointCloudMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof PointCloudMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in PointCloudMaterial ) t[i] = PointCloudMaterial[i];
        for ( var i in PointCloudMaterial.prototype ) try { p[i] = PointCloudMaterial.prototype[i] } catch(e) {};
        scope.PointCloudMaterial = PointCloudMaterial.bind( scope );
    } else {
        scope.PointCloudMaterial = PointCloudMaterial;
    }
    internal['constructor'] = PointCloudMaterial;
    scope.PointCloudMaterial.prototype = PointCloudMaterial.prototype;
    for ( var i in t ) scope.PointCloudMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.PointCloudMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__PointCloudMaterial ) {
        for ( var i = 0, il = scope.__PointCloudMaterial.length; i < il; i ++ ) scope.__PointCloudMaterial[ i ]( PointCloudMaterial );
        delete scope.__PointCloudMaterial;
    }

}) ( NWE.gfx );


// src/graphics/textures/Texture.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     */



    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }

    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, objInternal ) {

        objInternal = objInternal || {};
        this.uuid = Math.generateUUID();
        internal[ this.uuid ] = objInternal;

        this.id = NWE.gfx.TextureIdCount ++;

        this.name = '';

        this.image = image;
        this.mipmaps = [];

        this.mapping = mapping !== undefined ? mapping : null;

        this.wrapS = wrapS !== undefined ? wrapS : Const.ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : Const.ClampToEdgeWrapping;

        this.magFilter = magFilter !== undefined ? magFilter : Const.LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : Const.LinearMipMapLinearFilter;

        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

        this.format = format !== undefined ? format : Const.RGBAFormat;
        this.type = type !== undefined ? type : Const.UnsignedByteType;

        this.offset = new Vec2( 0, 0 );
        this.repeat = new Vec2( 1, 1 );

        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

        this.needsUpdate = true;
        this.onUpdate = null;

        this.instanceof = 'Texture';

    };

    Texture.prototype = {

        constructor: Texture,

        clone: function ( texture ) {

            if ( texture === undefined ) texture = new Texture();

            texture.image = this.image;
            texture.mipmaps = this.mipmaps.slice(0);

            texture.mapping = this.mapping;

            texture.wrapS = this.wrapS;
            texture.wrapT = this.wrapT;

            texture.magFilter = this.magFilter;
            texture.minFilter = this.minFilter;

            texture.anisotropy = this.anisotropy;

            texture.format = this.format;
            texture.type = this.type;

            texture.offset.copy( this.offset );
            texture.repeat.copy( this.repeat );

            texture.generateMipmaps = this.generateMipmaps;
            texture.premultiplyAlpha = this.premultiplyAlpha;
            texture.flipY = this.flipY;
            texture.unpackAlignment = this.unpackAlignment;

            texture.needsUpdate = true;

            return texture;

        },

        dispose: function () {

            this.dispatchEvent( { type: 'dispose' } );

        }

    };

    EventDispatcher.prototype.apply( Texture.prototype );

    NWE.gfx.TextureIdCount = 0;

    Texture.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Texture.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Texture.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Texture.setInternal = function ( name, value ) { internal[ name ] = value; };
    Texture.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Texture === 'function' ) {
        var t = {}, p = {};
        for ( var i in Texture ) t[i] = Texture[i];
        for ( var i in Texture.prototype ) try { p[i] = Texture.prototype[i] } catch(e) {};
        scope.Texture = Texture.bind( scope );
    } else {
        scope.Texture = Texture;
    }
    internal['constructor'] = Texture;
    scope.Texture.prototype = Texture.prototype;
    for ( var i in t ) scope.Texture[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Texture.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Texture ) {
        for ( var i = 0, il = scope.__Texture.length; i < il; i ++ ) scope.__Texture[ i ]( Texture );
        delete scope.__Texture;
    }

}) ( NWE.gfx );


// src/graphics/textures/CompressedTexture.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */



    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }


    var CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, objInternal ) {

        objInternal = objInternal || {};
        Texture.getInternal('constructor').call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, objInternal );
        internal[ this.uuid ] = objInternal;

        this.image = { width: width, height: height };
        this.mipmaps = mipmaps || [];

        this.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file

        this.instanceof = 'CompressedTexture';

    };

    CompressedTexture.prototype = Object.create( Texture.prototype );

    CompressedTexture.prototype.clone = function () {

        var texture = new CompressedTexture();

        Texture.prototype.clone.call( this, texture );

        return texture;

    };

    CompressedTexture.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    CompressedTexture.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    CompressedTexture.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    CompressedTexture.setInternal = function ( name, value ) { internal[ name ] = value; };
    CompressedTexture.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof CompressedTexture === 'function' ) {
        var t = {}, p = {};
        for ( var i in CompressedTexture ) t[i] = CompressedTexture[i];
        for ( var i in CompressedTexture.prototype ) try { p[i] = CompressedTexture.prototype[i] } catch(e) {};
        scope.CompressedTexture = CompressedTexture.bind( scope );
    } else {
        scope.CompressedTexture = CompressedTexture;
    }
    internal['constructor'] = CompressedTexture;
    scope.CompressedTexture.prototype = CompressedTexture.prototype;
    for ( var i in t ) scope.CompressedTexture[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.CompressedTexture.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__CompressedTexture ) {
        for ( var i = 0, il = scope.__CompressedTexture.length; i < il; i ++ ) scope.__CompressedTexture[ i ]( CompressedTexture );
        delete scope.__CompressedTexture;
    }

}) ( NWE.gfx );


// src/graphics/textures/DataTexture.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, objInternal ) {

        width = width || 0;
        height = height || 0;

        data = data || new Uint8Array( 4 * width * height );

        wrapS = wrapS || Const.ClampToEdgeWrapping;
        wrapT = wrapT || Const.ClampToEdgeWrapping;
        magFilter = magFilter || Const.NearestFilter;
        minFilter = minFilter || Const.NearestFilter;

        objInternal = objInternal || {};
        Texture.getInternal('constructor').call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, objInternal );
        internal[ this.uuid ] = objInternal;

        this.generateMipmaps = false;

        this.image = { data: data, width: width, height: height };

        this.instanceof = 'DataTexture';

    };

    DataTexture.prototype = Object.create( Texture.prototype );

    DataTexture.prototype.setSize = function ( width, height ) {

        this.image.width = width;
        this.image.height = height;

        this.image.data = new Uint8ClampedArray( 4 * width * height );

    };

    DataTexture.prototype.setDataBlock = function ( left, top, width, height, data ) {

        var k = 0;
        var offset;

        data = data || [];

        for ( var i = left, il = left + width; i < il; i ++ ) {

            for ( var j = top, jl = top + height; j < jl; j ++ ) {

                offset = 4 * ( i * this.image.width + j );

                data[ offset + 0 ] = data[ k + 0 ] || 0;
                data[ offset + 1 ] = data[ k + 1 ] || 0;
                data[ offset + 2 ] = data[ k + 2 ] || 0;
                data[ offset + 3 ] = data[ k + 3 ] || 0;

                k += 4;

            }

        }

    };

    DataTexture.prototype.clone = function () {

        var texture = new DataTexture();

        Texture.prototype.clone.call( this, texture );

        return texture;

    };

    DataTexture.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    DataTexture.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    DataTexture.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    DataTexture.setInternal = function ( name, value ) { internal[ name ] = value; };
    DataTexture.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof DataTexture === 'function' ) {
        var t = {}, p = {};
        for ( var i in DataTexture ) t[i] = DataTexture[i];
        for ( var i in DataTexture.prototype ) try { p[i] = DataTexture.prototype[i] } catch(e) {};
        scope.DataTexture = DataTexture.bind( scope );
    } else {
        scope.DataTexture = DataTexture;
    }
    internal['constructor'] = DataTexture;
    scope.DataTexture.prototype = DataTexture.prototype;
    for ( var i in t ) scope.DataTexture[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DataTexture.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DataTexture ) {
        for ( var i = 0, il = scope.__DataTexture.length; i < il; i ++ ) scope.__DataTexture[ i ]( DataTexture );
        delete scope.__DataTexture;
    }

}) ( NWE.gfx );


// src/graphics/objects/Line.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */



    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }

    var BufferGeometry = NWE.gfx.BufferGeometry;
    if ( !BufferGeometry ) { NWE.gfx.__BufferGeometry = (NWE.gfx.__BufferGeometry || []); NWE.gfx.__BufferGeometry.push( function ( obj ) { BufferGeometry = obj; } ); }

    var LineBasicMaterial = NWE.gfx.LineBasicMaterial;
    if ( !LineBasicMaterial ) { NWE.gfx.__LineBasicMaterial = (NWE.gfx.__LineBasicMaterial || []); NWE.gfx.__LineBasicMaterial.push( function ( obj ) { LineBasicMaterial = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var Line = function ( geometry, material, type, objInternal ) {

        objInternal = objInternal || {};
        Object3D.getInternal('constructor').call( this, {}, objInternal );
        internal[ this.uuid ] = objInternal;

        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

        this.type = ( type !== undefined ) ? type : Const.LineStrip;

        this.instanceof = 'Line';

    };

    Const.LineStrip = 0;
    Const.LinePieces = 1;

    Line.prototype = Object.create( Object3D.prototype );

    Line.prototype.clone = function ( object ) {

        if ( object === undefined ) object = new Line( this.geometry, this.material, this.type );

        Object3D.prototype.clone.call( this, object );

        return object;

    };

    Line.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Line.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Line.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Line.setInternal = function ( name, value ) { internal[ name ] = value; };
    Line.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Line === 'function' ) {
        var t = {}, p = {};
        for ( var i in Line ) t[i] = Line[i];
        for ( var i in Line.prototype ) try { p[i] = Line.prototype[i] } catch(e) {};
        scope.Line = Line.bind( scope );
    } else {
        scope.Line = Line;
    }
    internal['constructor'] = Line;
    scope.Line.prototype = Line.prototype;
    for ( var i in t ) scope.Line[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Line.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Line ) {
        for ( var i = 0, il = scope.__Line.length; i < il; i ++ ) scope.__Line[ i ]( Line );
        delete scope.__Line;
    }

}) ( NWE.gfx );


// src/graphics/objects/Mesh.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author jonobr1 / http://jonobr1.com/
     */



    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }

    var BufferGeometry = NWE.gfx.BufferGeometry;
    if ( !BufferGeometry ) { NWE.gfx.__BufferGeometry = (NWE.gfx.__BufferGeometry || []); NWE.gfx.__BufferGeometry.push( function ( obj ) { BufferGeometry = obj; } ); }

    var MeshBasicMaterial = NWE.gfx.MeshBasicMaterial;
    if ( !MeshBasicMaterial ) { NWE.gfx.__MeshBasicMaterial = (NWE.gfx.__MeshBasicMaterial || []); NWE.gfx.__MeshBasicMaterial.push( function ( obj ) { MeshBasicMaterial = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }


    var Mesh = function ( geometry, material, objInternal ) {

        objInternal = objInternal || {};
        Object3D.getInternal('constructor').call( this, {}, objInternal );
        internal[ this.uuid ] = objInternal;

        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

        this.instanceof = 'Mesh';

    };

    Mesh.prototype = Object.create( Object3D.prototype );

    Mesh.prototype.clone = function ( object ) {

        if ( object === undefined ) object = new Mesh( this.geometry, this.material );

        Object3D.prototype.clone.call( this, object );

        return object;

    };

    Mesh.prototype.dispose = function () {

        for ( var i in this ) {

            delete this[i];

        }

    };

    EventDispatcher.prototype.apply( Mesh.prototype );

    Mesh.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Mesh.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Mesh.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Mesh.setInternal = function ( name, value ) { internal[ name ] = value; };
    Mesh.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Mesh === 'function' ) {
        var t = {}, p = {};
        for ( var i in Mesh ) t[i] = Mesh[i];
        for ( var i in Mesh.prototype ) try { p[i] = Mesh.prototype[i] } catch(e) {};
        scope.Mesh = Mesh.bind( scope );
    } else {
        scope.Mesh = Mesh;
    }
    internal['constructor'] = Mesh;
    scope.Mesh.prototype = Mesh.prototype;
    for ( var i in t ) scope.Mesh[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Mesh.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Mesh ) {
        for ( var i = 0, il = scope.__Mesh.length; i < il; i ++ ) scope.__Mesh[ i ]( Mesh );
        delete scope.__Mesh;
    }

}) ( NWE.gfx );


// src/graphics/objects/LOD.js

( function ( scope ) {

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author ohmed
     */



    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var LOD = function ( objInternal ) {

        objInternal = objInternal || {};
        Object3D.getInternal('constructor').call( this, {}, objInternal );
        internal[ this.uuid ] = objInternal;

        this.objects = [];

        this.autoUpdate = true;

        //

        this.instanceof = 'LOD';

    };

    LOD.prototype = Object.create( Object3D.prototype );

    LOD.prototype.addLevel = function ( object, distance ) {

        if ( distance === undefined ) distance = 0;

        distance = window.Math.abs( distance );

        for ( var l = 0; l < this.objects.length; l ++ ) {

            if ( distance < this.objects[ l ].distance ) {

                break;

            }

        }

        this.objects.splice( l, 0, { distance: distance, object: object } );
        this.add( object );

    };

    LOD.prototype.getObjectForDistance = function ( distance ) {

        for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

            if ( distance < this.objects[ i ].distance ) {

                break;

            }

        }

        return this.objects[ i - 1 ].object;

    };

    LOD.prototype.update = function () {

        var v1 = new Vec3();
        var v2 = new Vec3();

        return function ( camera ) {

            if ( this.objects.length > 1 ) {

                v1.getPositionFromMatrix( camera.matrixWorld );
                v2.getPositionFromMatrix( this.matrixWorld );

                var distance = v1.distanceTo( v2 );

                this.objects[ 0 ].object.visible = true;

                for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

                    if ( distance >= this.objects[ i ].distance ) {

                        this.objects[ i - 1 ].object.visible = false;
                        this.objects[ i     ].object.visible = true;

                    } else {

                        break;

                    }

                }

                for ( ; i < l; i ++ ) {

                    this.objects[ i ].object.visible = false;

                }

            }

        };

    }();

    LOD.prototype.clone = function () {

        // TODO

    };

    LOD.prototype.dispose = function () {

        // TODO

    };

    LOD.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    LOD.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    LOD.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    LOD.setInternal = function ( name, value ) { internal[ name ] = value; };
    LOD.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof LOD === 'function' ) {
        var t = {}, p = {};
        for ( var i in LOD ) t[i] = LOD[i];
        for ( var i in LOD.prototype ) try { p[i] = LOD.prototype[i] } catch(e) {};
        scope.LOD = LOD.bind( scope );
    } else {
        scope.LOD = LOD;
    }
    internal['constructor'] = LOD;
    scope.LOD.prototype = LOD.prototype;
    for ( var i in t ) scope.LOD[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.LOD.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__LOD ) {
        for ( var i = 0, il = scope.__LOD.length; i < il; i ++ ) scope.__LOD[ i ]( LOD );
        delete scope.__LOD;
    }

}) ( NWE.gfx );


// src/graphics/objects/Sprite.js

( function ( scope ) {

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */



    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }

    var SpriteMaterial = NWE.gfx.SpriteMaterial;
    if ( !SpriteMaterial ) { NWE.gfx.__SpriteMaterial = (NWE.gfx.__SpriteMaterial || []); NWE.gfx.__SpriteMaterial.push( function ( obj ) { SpriteMaterial = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var Sprite = function ( material, objInternal ) {

        objInternal = objInternal || {};
        Object3D.getInternal('constructor').call( this, {}, objInternal );
        internal[ this.uuid ] = objInternal;

        this.relativePosition = new Vec3();
        this.offset = new Vec3();

        this.material = ( material !== undefined ) ? material : new SpriteMaterial();

        this.rotation = 0;

        this.instanceof = 'Sprite';

    };

    Sprite.prototype = Object.create( Object3D.prototype );

    /*
     * Custom update matrix
     */

    Sprite.prototype.updateMatrix = function () {

        this.matrix.compose( this.position, this.quaternion, this.scale );

        this.matrixWorldNeedsUpdate = true;

    };

    Sprite.prototype.clone = function ( object ) {

        if ( object === undefined ) object = Sprite( this.material );

        Object3D.prototype.clone.call( this, object );

        return object;

    };

    Sprite.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Sprite.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Sprite.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Sprite.setInternal = function ( name, value ) { internal[ name ] = value; };
    Sprite.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Sprite === 'function' ) {
        var t = {}, p = {};
        for ( var i in Sprite ) t[i] = Sprite[i];
        for ( var i in Sprite.prototype ) try { p[i] = Sprite.prototype[i] } catch(e) {};
        scope.Sprite = Sprite.bind( scope );
    } else {
        scope.Sprite = Sprite;
    }
    internal['constructor'] = Sprite;
    scope.Sprite.prototype = Sprite.prototype;
    for ( var i in t ) scope.Sprite[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Sprite.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Sprite ) {
        for ( var i = 0, il = scope.__Sprite.length; i < il; i ++ ) scope.__Sprite[ i ]( Sprite );
        delete scope.__Sprite;
    }

}) ( NWE.gfx );


// src/graphics/objects/PointCloud.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */



    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }

    var BufferGeometry = NWE.gfx.BufferGeometry;
    if ( !BufferGeometry ) { NWE.gfx.__BufferGeometry = (NWE.gfx.__BufferGeometry || []); NWE.gfx.__BufferGeometry.push( function ( obj ) { BufferGeometry = obj; } ); }

    var PointCloudMaterial = NWE.gfx.PointCloudMaterial;
    if ( !PointCloudMaterial ) { NWE.gfx.__PointCloudMaterial = (NWE.gfx.__PointCloudMaterial || []); NWE.gfx.__PointCloudMaterial.push( function ( obj ) { PointCloudMaterial = obj; } ); }


    var PointCloud = function ( geometry, material, objInternal ) {

        objInternal = objInternal || {};
        Object3D.getInternal('constructor').call( this, {}, objInternal );
        internal[ this.uuid ] = objInternal;

        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new PointCloudMaterial( { color: Math.random() * 0xffffff } );

        this.instanceof = 'PointCloud';

    };

    PointCloud.prototype = Object.create( Object3D.prototype );
    PointCloud.prototype.constructor = PointCloud;

    PointCloud.prototype.clone = function ( object ) {

        if ( object === undefined ) object = new PointCloud( this.geometry, this.material );

        Object3D.prototype.clone.call( this, object );

        return object;

    };

    PointCloud.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    PointCloud.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    PointCloud.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    PointCloud.setInternal = function ( name, value ) { internal[ name ] = value; };
    PointCloud.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof PointCloud === 'function' ) {
        var t = {}, p = {};
        for ( var i in PointCloud ) t[i] = PointCloud[i];
        for ( var i in PointCloud.prototype ) try { p[i] = PointCloud.prototype[i] } catch(e) {};
        scope.PointCloud = PointCloud.bind( scope );
    } else {
        scope.PointCloud = PointCloud;
    }
    internal['constructor'] = PointCloud;
    scope.PointCloud.prototype = PointCloud.prototype;
    for ( var i in t ) scope.PointCloud[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.PointCloud.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__PointCloud ) {
        for ( var i = 0, il = scope.__PointCloud.length; i < il; i ++ ) scope.__PointCloud[ i ]( PointCloud );
        delete scope.__PointCloud;
    }

}) ( NWE.gfx );


// src/graphics/lights/Light.js

( function ( scope ) {

    /*
     * @author ohmed
    */



    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }


    var Light = function ( color, objInternal ) {

        objInternal = objInternal || {};
        Object3D.getInternal('constructor').call( this, {}, objInternal );
        internal[ this.uuid ] = objInternal;

        this.color = new Color( color );

        this.instanceof = 'Light';

    };

    Light.prototype = Object.create( Object3D.prototype );

    Light.prototype.clone = function ( light ) {

        if ( light === undefined ) light = new Light();

        Object3D.prototype.clone.call( this, light );

        light.color.copy( this.color );

        return light;

    };

    EventDispatcher.prototype.apply( Light.prototype );

    Light.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Light.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Light.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Light.setInternal = function ( name, value ) { internal[ name ] = value; };
    Light.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Light === 'function' ) {
        var t = {}, p = {};
        for ( var i in Light ) t[i] = Light[i];
        for ( var i in Light.prototype ) try { p[i] = Light.prototype[i] } catch(e) {};
        scope.Light = Light.bind( scope );
    } else {
        scope.Light = Light;
    }
    internal['constructor'] = Light;
    scope.Light.prototype = Light.prototype;
    for ( var i in t ) scope.Light[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Light.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Light ) {
        for ( var i = 0, il = scope.__Light.length; i < il; i ++ ) scope.__Light[ i ]( Light );
        delete scope.__Light;
    }

}) ( NWE.gfx );


// src/graphics/lights/AmbientLight.js

( function ( scope ) {

    /*
     * @author ohmed
    */



    var Light = NWE.gfx.Light;
    if ( !Light ) { NWE.gfx.__Light = (NWE.gfx.__Light || []); NWE.gfx.__Light.push( function ( obj ) { Light = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }


    var AmbientLight = function ( color, objInternal ) {

        objInternal = objInternal || {};
        Light.getInternal('constructor').call( this, color, objInternal );
        internal[ this.uuid ] = objInternal;

        this.instanceof = 'AmbientLight';

    };

    AmbientLight.prototype = Object.create( Light.prototype );

    AmbientLight.prototype.clone = function () {

        var light = new AmbientLight();

        Light.prototype.clone.call( this, light );

        return light;

    };

    EventDispatcher.prototype.apply( AmbientLight.prototype );

    AmbientLight.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    AmbientLight.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    AmbientLight.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    AmbientLight.setInternal = function ( name, value ) { internal[ name ] = value; };
    AmbientLight.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof AmbientLight === 'function' ) {
        var t = {}, p = {};
        for ( var i in AmbientLight ) t[i] = AmbientLight[i];
        for ( var i in AmbientLight.prototype ) try { p[i] = AmbientLight.prototype[i] } catch(e) {};
        scope.AmbientLight = AmbientLight.bind( scope );
    } else {
        scope.AmbientLight = AmbientLight;
    }
    internal['constructor'] = AmbientLight;
    scope.AmbientLight.prototype = AmbientLight.prototype;
    for ( var i in t ) scope.AmbientLight[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.AmbientLight.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__AmbientLight ) {
        for ( var i = 0, il = scope.__AmbientLight.length; i < il; i ++ ) scope.__AmbientLight[ i ]( AmbientLight );
        delete scope.__AmbientLight;
    }

}) ( NWE.gfx );


// src/graphics/lights/DirectionalLight.js

( function ( scope ) {

    /*
     * @author ohmed
    */



    var Light = NWE.gfx.Light;
    if ( !Light ) { NWE.gfx.__Light = (NWE.gfx.__Light || []); NWE.gfx.__Light.push( function ( obj ) { Light = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }


    var DirectionalLight = function ( color, intensity, objInternal ) {

        objInternal = objInternal || {};
        Light.getInternal('constructor').call( this, color, objInternal );
        internal[ this.uuid ] = objInternal;

        this.intensity = ( intensity !== undefined ) ? intensity : 1;

        this.position.set( 0, 1, 0 );
        this.target = new Object3D();

        //

        this.castShadow = false;
        this.onlyShadow = false;

        //

        this.shadowCameraNear = 50;
        this.shadowCameraFar = 5000;

        this.shadowCameraLeft = - 500;
        this.shadowCameraRight = 500;
        this.shadowCameraTop = 500;
        this.shadowCameraBottom = - 500;

        this.shadowCameraVisible = false;

        this.shadowBias = 0;
        this.shadowDarkness = 0.5;

        this.shadowMapWidth = 512;
        this.shadowMapHeight = 512;

        //

        this.shadowMap = null;
        this.shadowMapSize = null;
        this.shadowCamera = null;
        this.shadowMatrix = null;

        //

        this.instanceof = 'DirectionalLight';

    };

    DirectionalLight.prototype = Object.create( Light.prototype );

    DirectionalLight.prototype.clone = function () {

        var light = new DirectionalLight();

        Light.prototype.clone.call( this, light );

        light.target = this.target.clone();

        return light;

    };

    EventDispatcher.prototype.apply( DirectionalLight.prototype );

    DirectionalLight.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    DirectionalLight.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    DirectionalLight.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    DirectionalLight.setInternal = function ( name, value ) { internal[ name ] = value; };
    DirectionalLight.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof DirectionalLight === 'function' ) {
        var t = {}, p = {};
        for ( var i in DirectionalLight ) t[i] = DirectionalLight[i];
        for ( var i in DirectionalLight.prototype ) try { p[i] = DirectionalLight.prototype[i] } catch(e) {};
        scope.DirectionalLight = DirectionalLight.bind( scope );
    } else {
        scope.DirectionalLight = DirectionalLight;
    }
    internal['constructor'] = DirectionalLight;
    scope.DirectionalLight.prototype = DirectionalLight.prototype;
    for ( var i in t ) scope.DirectionalLight[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DirectionalLight.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DirectionalLight ) {
        for ( var i = 0, il = scope.__DirectionalLight.length; i < il; i ++ ) scope.__DirectionalLight[ i ]( DirectionalLight );
        delete scope.__DirectionalLight;
    }

}) ( NWE.gfx );


// src/graphics/renderers/Viewport.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var Viewport = function ( renderer, canvas ) {

        var _gl = renderer.getContext();

        this.devicePixelRatio = ( window.devicePixelRatio !== undefined ) ? window.devicePixelRatio: 1;

        this.X = 0;
        this.Y = 0;

        this.width = 0;
        this.height = 0;

        this.setSize = function ( width, height, updateStyle ) {

            canvas.width  = width * this.devicePixelRatio;
            canvas.height = height * this.devicePixelRatio;

            if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {

                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';

            }

            this.setViewport( 0, 0, canvas.width, canvas.height );

        };

        this.setViewport = function ( x, y, width, height ) {

            this.X = ( x !== undefined ) ? x : 0;
            this.Y = ( y !== undefined ) ? y : 0;

            this.width = ( width !== undefined ) ? width : _canvas.width;
            this.height = ( height !== undefined ) ? height : _canvas.height;

            _gl.viewport( this.X, this.Y, this.width, this.height );

        };

        this.setScissor = function ( x, y, width, height ) {

            _gl.scissor( x, y, width, height );

        };

        this.enableScissorTest = function ( enable ) {

            if ( enable ) {

                _gl.enable( _gl.SCISSOR_TEST );

            } else {

                _gl.disable( _gl.SCISSOR_TEST );

            }

        };

    };

    if ( typeof Viewport === 'function' ) {
        var t = {}, p = {};
        for ( var i in Viewport ) t[i] = Viewport[i];
        for ( var i in Viewport.prototype ) try { p[i] = Viewport.prototype[i] } catch(e) {};
        scope.Viewport = Viewport.bind( scope );
    } else {
        scope.Viewport = Viewport;
    }
    scope.Viewport.prototype = Viewport.prototype;
    for ( var i in t ) scope.Viewport[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Viewport.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Viewport ) {
        for ( var i = 0, il = scope.__Viewport.length; i < il; i ++ ) scope.__Viewport[ i ]( Viewport );
        delete scope.__Viewport;
    }

}) ( NWE.gfx );


// src/graphics/renderers/WebGLRenderer.js

( function ( scope ) {


    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var BufferGeometry = NWE.gfx.BufferGeometry;
    if ( !BufferGeometry ) { NWE.gfx.__BufferGeometry = (NWE.gfx.__BufferGeometry || []); NWE.gfx.__BufferGeometry.push( function ( obj ) { BufferGeometry = obj; } ); }

    var LayoutBufferGeometry = NWE.gfx.LayoutBufferGeometry;
    if ( !LayoutBufferGeometry ) { NWE.gfx.__LayoutBufferGeometry = (NWE.gfx.__LayoutBufferGeometry || []); NWE.gfx.__LayoutBufferGeometry.push( function ( obj ) { LayoutBufferGeometry = obj; } ); }


    var Mesh = NWE.gfx.Mesh;
    if ( !Mesh ) { NWE.gfx.__Mesh = (NWE.gfx.__Mesh || []); NWE.gfx.__Mesh.push( function ( obj ) { Mesh = obj; } ); }

    var Sprite = NWE.gfx.Sprite;
    if ( !Sprite ) { NWE.gfx.__Sprite = (NWE.gfx.__Sprite || []); NWE.gfx.__Sprite.push( function ( obj ) { Sprite = obj; } ); }

    var Line = NWE.gfx.Line;
    if ( !Line ) { NWE.gfx.__Line = (NWE.gfx.__Line || []); NWE.gfx.__Line.push( function ( obj ) { Line = obj; } ); }


    var Scene = NWE.gfx.Scene;
    if ( !Scene ) { NWE.gfx.__Scene = (NWE.gfx.__Scene || []); NWE.gfx.__Scene.push( function ( obj ) { Scene = obj; } ); }

    var Camera = NWE.gfx.Camera;
    if ( !Camera ) { NWE.gfx.__Camera = (NWE.gfx.__Camera || []); NWE.gfx.__Camera.push( function ( obj ) { Camera = obj; } ); }

    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }


    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }

    var CompressedTexture = NWE.gfx.CompressedTexture;
    if ( !CompressedTexture ) { NWE.gfx.__CompressedTexture = (NWE.gfx.__CompressedTexture || []); NWE.gfx.__CompressedTexture.push( function ( obj ) { CompressedTexture = obj; } ); }

    var DataTexture = NWE.gfx.DataTexture;
    if ( !DataTexture ) { NWE.gfx.__DataTexture = (NWE.gfx.__DataTexture || []); NWE.gfx.__DataTexture.push( function ( obj ) { DataTexture = obj; } ); }


    var MeshBasicMaterial = NWE.gfx.MeshBasicMaterial;
    if ( !MeshBasicMaterial ) { NWE.gfx.__MeshBasicMaterial = (NWE.gfx.__MeshBasicMaterial || []); NWE.gfx.__MeshBasicMaterial.push( function ( obj ) { MeshBasicMaterial = obj; } ); }

    var MeshLambertMaterial = NWE.gfx.MeshLambertMaterial;
    if ( !MeshLambertMaterial ) { NWE.gfx.__MeshLambertMaterial = (NWE.gfx.__MeshLambertMaterial || []); NWE.gfx.__MeshLambertMaterial.push( function ( obj ) { MeshLambertMaterial = obj; } ); }

    var MeshDepthMaterial = NWE.gfx.MeshDepthMaterial;
    if ( !MeshDepthMaterial ) { NWE.gfx.__MeshDepthMaterial = (NWE.gfx.__MeshDepthMaterial || []); NWE.gfx.__MeshDepthMaterial.push( function ( obj ) { MeshDepthMaterial = obj; } ); }

    var MeshNormalMaterial = NWE.gfx.MeshNormalMaterial;
    if ( !MeshNormalMaterial ) { NWE.gfx.__MeshNormalMaterial = (NWE.gfx.__MeshNormalMaterial || []); NWE.gfx.__MeshNormalMaterial.push( function ( obj ) { MeshNormalMaterial = obj; } ); }

    var LineBasicMaterial = NWE.gfx.LineBasicMaterial;
    if ( !LineBasicMaterial ) { NWE.gfx.__LineBasicMaterial = (NWE.gfx.__LineBasicMaterial || []); NWE.gfx.__LineBasicMaterial.push( function ( obj ) { LineBasicMaterial = obj; } ); }

    var LineDashedMaterial = NWE.gfx.LineDashedMaterial;
    if ( !LineDashedMaterial ) { NWE.gfx.__LineDashedMaterial = (NWE.gfx.__LineDashedMaterial || []); NWE.gfx.__LineDashedMaterial.push( function ( obj ) { LineDashedMaterial = obj; } ); }

    var ShaderMaterial = NWE.gfx.ShaderMaterial;
    if ( !ShaderMaterial ) { NWE.gfx.__ShaderMaterial = (NWE.gfx.__ShaderMaterial || []); NWE.gfx.__ShaderMaterial.push( function ( obj ) { ShaderMaterial = obj; } ); }

    var ShaderLib = NWE.gfx.ShaderLib;
    if ( !ShaderLib ) { NWE.gfx.__ShaderLib = (NWE.gfx.__ShaderLib || []); NWE.gfx.__ShaderLib.push( function ( obj ) { ShaderLib = obj; } ); }

    var UniformUtils = NWE.gfx.UniformUtils;
    if ( !UniformUtils ) { NWE.gfx.__UniformUtils = (NWE.gfx.__UniformUtils || []); NWE.gfx.__UniformUtils.push( function ( obj ) { UniformUtils = obj; } ); }

    var Light = NWE.gfx.Light;
    if ( !Light ) { NWE.gfx.__Light = (NWE.gfx.__Light || []); NWE.gfx.__Light.push( function ( obj ) { Light = obj; } ); }


    var SpritePlugin = NWE.gfx.SpritePlugin;
    if ( !SpritePlugin ) { NWE.gfx.__SpritePlugin = (NWE.gfx.__SpritePlugin || []); NWE.gfx.__SpritePlugin.push( function ( obj ) { SpritePlugin = obj; } ); }


    var renderersList = NWE.gfx.renderersList;
    if ( !renderersList ) { NWE.gfx.__renderersList = (NWE.gfx.__renderersList || []); NWE.gfx.__renderersList.push( function ( obj ) { renderersList = obj; } ); }


    var Program = NWE.gfx.Program;
    if ( !Program ) { NWE.gfx.__Program = (NWE.gfx.__Program || []); NWE.gfx.__Program.push( function ( obj ) { Program = obj; } ); }

    var RawUniform = NWE.gfx.RawUniform;
    if ( !RawUniform ) { NWE.gfx.__RawUniform = (NWE.gfx.__RawUniform || []); NWE.gfx.__RawUniform.push( function ( obj ) { RawUniform = obj; } ); }


    var CheckDeviceCapabilities = NWE.gfx.CheckDeviceCapabilities;
    if ( !CheckDeviceCapabilities ) { NWE.gfx.__CheckDeviceCapabilities = (NWE.gfx.__CheckDeviceCapabilities || []); NWE.gfx.__CheckDeviceCapabilities.push( function ( obj ) { CheckDeviceCapabilities = obj; } ); }

    var Viewport = NWE.gfx.Viewport;
    if ( !Viewport ) { NWE.gfx.__Viewport = (NWE.gfx.__Viewport || []); NWE.gfx.__Viewport.push( function ( obj ) { Viewport = obj; } ); }


    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Frustum = NWE.Frustum;
    if ( !Frustum ) { NWE.__Frustum = (NWE.__Frustum || []); NWE.__Frustum.push( function ( obj ) { Frustum = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var Matrix3 = NWE.Matrix3;
    if ( !Matrix3 ) { NWE.__Matrix3 = (NWE.__Matrix3 || []); NWE.__Matrix3.push( function ( obj ) { Matrix3 = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var renderersList = {};

    var WebGLRenderer = function ( parameters ) {

    /***
    *** define all renderer variables
    **/

    // in params

    parameters = parameters || {};

    var self = this;

    self.RENDERER_BUILD_VERSION = 342;

    Logger.log( 'NWE.gfx.WebGLRenderer version ' + self.RENDERER_BUILD_VERSION );

    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),

        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

    // global

    self.domElement = _canvas;

    // local

    var _clearColor = new Color( 0x000000 ),
        _clearAlpha = 0,

        _gl,

        _device;

    // clearing

    var autoClear = true,
        autoClearColor = true,
        autoClearDepth = true,
        autoClearStencil = true;

    // scene graph

    var sortObjects = true,
        autoUpdateObjects = true;

    var _lights = {

            ambient: new Color( 0x000000 ),
            directional: [],
            point: [],
            spot: [],
            list: []

        },

        _lightsNeedsUpdate = true;

    // custom render plugins

    var renderPluginsPre = [],
        renderPluginsPost = [];

    // internal variables

    // state cache

    var _emptyProgram = { id: -1 },
        _currentProgram = _emptyProgram,
        _currentFramebuffer = null,
        _currentMaterialId = -1,
        _currentGeometryGroupHash = null,
        _currentCameraId = -1,
        _currentSceneId = -1,

        _usedTextureUnits = 0,


        // GL state cache

        _oldDoubleSided = -1,
        _oldFlipSided = -1,

        _oldBlending = -1,

        _oldBlendEquation = -1,
        _oldBlendSrc = -1,
        _oldBlendDst = -1,

        _oldDepthTest = -1,
        _oldDepthWrite = -1,

        _oldPolygonOffset = null,
        _oldPolygonOffsetFactor = null,
        _oldPolygonOffsetUnits = null,

        _oldLineWidth = null,

        _currentWidth = 0,
        _currentHeight = 0,

        _newAttributes = new Uint8Array( 16 ),
        _enabledAttributes = new Uint8Array( 16 ),

        // frustum

        _frustum = new Frustum(),

        // camera matrices cache

        _projScreenMatrix = new Matrix4(),
        _projScreenMatrixPS = new Matrix4(),

        _vector3 = new Vec3(),

        _direction = new Vec3(),

        isComposerRender,

        _webglObjects = [],
        _webglSprites = [],
        _webglLights = [],

        rendererId = Math.generateUUID();

    renderersList[ rendererId ] = self;


    /***
    *** renderer API
    **/

    this.getContext = function () {

        return _gl;

    };

    this.getDevice = function () {

        return _device;

    };

    this.setScissor = function ( x, y, width, height ) {

        _gl.scissor(
            x * _device.pixelRatio,
            y * _device.pixelRatio,
            width * _device.pixelRatio,
            height * _device.pixelRatio
        );

    };

    this.enableScissorTest = function ( enable ) {

        enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

    };

    // Clearing

    this.setClearColor = function ( color, alpha ) {

        _clearColor.set( color );
        _clearAlpha = alpha !== undefined ? alpha : 1;

        _gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    this.getClearColor = function () {

        return _clearColor;

    };

    this.getClearAlpha = function () {

        return _clearAlpha;

    };

    this.getWebGLObjects = function () {

        return _webglObjects;

    };

    this.getLights = function () {

        return _webglLights;

    };

    this.clearTarget = function ( renderTarget, color, depth, stencil ) {

        clearTarget( renderTarget, color, depth, stencil );

    };

    this.setRenderTarget = setRenderTarget;

    this.clear = function ( color, depth, stencil ) {

        clear( color, depth, stencil );

    };

    // Plugins

    this.addPostPlugin = function ( plugin ) {

        plugin.prepare( this );
        renderPluginsPost.push( plugin );

    };

    this.addPrePlugin = function ( plugin ) {

        plugin.prepare( this );
        renderPluginsPre.push( plugin );

    };

    //

    this.renderBufferDirect = renderBufferDirect;

    // GL state setting

    this.setTexture = setTexture;
    this.setBlending = setBlending;
    this.setDepthTest = setDepthTest;
    this.setDepthWrite = setDepthWrite;

    this.programs = [],
    this.programs_counter = 0,

    // renderer

    this.render = function ( scene, camera, renderTarget, forceClear, isComposerRender ) {

        render( scene, camera, renderTarget, forceClear, isComposerRender );

    };



    /***
    *** renderer helper functions
    **/

    function filterFallback ( f ) {

        if ( f === Const.NearestFilter || f === Const.NearestMipMapNearestFilter || f === Const.NearestMipMapLinearFilter ) {

            return _gl.NEAREST;

        }

        return _gl.LINEAR;

    };

    function paramNWEToGL ( param ) {

        switch ( param ) {

            case Const.RepeatWrapping:
                return _gl.REPEAT;

            case Const.ClampToEdgeWrapping:
                return _gl.CLAMP_TO_EDGE;

            case Const.MirroredRepeatWrapping:
                return _gl.MIRRORED_REPEAT;

            //

            case Const.NearestFilter:
                return _gl.NEAREST;

            case Const.NearestMipMapNearestFilter:
                return _gl.NEAREST_MIPMAP_NEAREST;

            case Const.NearestMipMapLinearFilter:
                return _gl.NEAREST_MIPMAP_LINEAR;

            case Const.LinearFilter:
                return _gl.LINEAR;

            case Const.LinearMipMapNearestFilter:
                return _gl.LINEAR_MIPMAP_NEAREST;

            case Const.LinearMipMapLinearFilter:
                return _gl.LINEAR_MIPMAP_LINEAR;

            //

            case Const.UnsignedByteType:
                return _gl.UNSIGNED_BYTE;

            case Const.UnsignedShort4444Type:
                return _gl.UNSIGNED_SHORT_4_4_4_4;

            case Const.UnsignedShort5551Type:
                return _gl.UNSIGNED_SHORT_5_5_5_1;

            case Const.UnsignedShort565Type:
                return _gl.UNSIGNED_SHORT_5_6_5;

            //

            case Const.ByteType:
                return _gl.BYTE;

            case Const.ShortType:
                return _gl.SHORT;

            case Const.UnsignedShortType:
                return _gl.UNSIGNED_SHORT;

            case Const.IntType:
                return _gl.INT;

            case Const.UnsignedIntType:
                return _gl.UNSIGNED_INT;

            case Const.FloatType:
                return _gl.FLOAT;

            //

            case Const.AlphaFormat:
                return _gl.ALPHA;

            case Const.RGBFormat:
                return _gl.RGB;

            case Const.RGBAFormat:
                return _gl.RGBA;

            case Const.LuminanceFormat:
                return _gl.LUMINANCE;

            case Const.LuminanceAlphaFormat:
                return _gl.LUMINANCE_ALPHA;

            //

            case Const.AddEquation:
                return _gl.FUNC_ADD;

            case Const.SubtractEquation:
                return _gl.FUNC_SUBTRACT;

            case Const.ReverseSubtractEquation:
                return _gl.FUNC_REVERSE_SUBTRACT;

            //

            case Const.ZeroFactor:
                return _gl.ZERO;

            case Const.OneFactor:
                return _gl.ONE;

            case Const.SrcColorFactor:
                return _gl.SRC_COLOR;

            case Const.OneMinusSrcColorFactor :
                return _gl.ONE_MINUS_SRC_COLOR;

            case Const.SrcAlphaFactor:
                return _gl.SRC_ALPHA;

            case Const.OneMinusSrcAlphaFactor:
                return _gl.ONE_MINUS_SRC_ALPHA;

            case Const.DstAlphaFactor:
                return _gl.DST_ALPHA;

            case Const.OneMinusDstAlphaFactor:
                return _gl.ONE_MINUS_DST_ALPHA;

            //

            case Const.DstColorFactor:
                return _gl.DST_COLOR;

            case Const.OneMinusDstColorFactor:
                return _gl.ONE_MINUS_DST_COLOR;

            case Const.SrcAlphaSaturateFactor:
                return _gl.SRC_ALPHA_SATURATE;

        }

        //

        var _glExtS3TC = _device.getExtension('compressedTextureS3TC');

        if ( _glExtS3TC !== undefined ) {

            switch ( param ) {

                case Const.RGB_S3TC_DXT1_Format:
                    return _glExtS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Const.RGBA_S3TC_DXT1_Format:
                    return _glExtS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Const.RGBA_S3TC_DXT3_Format:
                    return _glExtS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Const.RGBA_S3TC_DXT5_Format:
                    return _glExtS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;

            }

        }

        return 0;

    };



    /***
    *** renderer sorting
    **/

    function SortByProgram ( arr ) {

        var i, il,
            tmp, j;

        for ( i = 1, il = arr.length; i < il; i ++ ) {

            tmp = arr[ i ];
            j = i;

            while ( j > 0 && arr[ j - 1 ].material.programId > tmp.material.programId ) {

              arr[ j ] = arr[ j - 1 ];
              --j;

            }

            arr[ j ] = tmp;

        }

        return arr;

    };

    function SortPainterStable ( arr ) {

        var i, il,
            tmp, j;

        for ( i = 1, il = arr.length; i < il; i ++ ) {

            tmp = arr[i];
            j = i;

            if ( arr[j - 1].z !== tmp.z ) {

                while ( arr[j - 1].z > tmp.z ) {

                  arr[j] = arr[j - 1];
                  --j;

                }

            } else {

                while ( arr[j - 1].id > tmp.id ) {

                  arr[j] = arr[j - 1];
                  --j;

                }

            }

            arr[j] = tmp;

        }

        return arr;

    };



    /***
    *** renderer attributes
    **/

    function findAttribute ( attributes, id ) {

        for ( var i = 0, il = attributes.length; i < il; i ++ ) {

            if ( attributes[i] && attributes[i][0] === id ) {

                return attributes[i][1];

            }

        }

        return false;

    };

    function initAttributes () {

        for ( var i = 0, l = _newAttributes.length; i < l; i ++ ) {

            _newAttributes[i] = 0;

        }

    };

    function enableAttribute ( attribute ) {

        _newAttributes[ attribute ] = 1;

        if ( _enabledAttributes[ attribute ] === 0 ) {

            _gl.enableVertexAttribArray( attribute );
            _enabledAttributes[ attribute ] = 1;

        }

    };

    function disableUnusedAttributes () {

        for ( var i = 0, l = _enabledAttributes.length; i < l; i ++ ) {

            if ( _enabledAttributes[i] !== _newAttributes[i] ) {

                _gl.disableVertexAttribArray( i );
                _enabledAttributes[i] = 0;

            }

        }

    };

    function setupVertexAttributes ( material, program, geometry, startIndex ) {

        var programAttributes = program.attributes;
        var geometryAttributes = geometry.getInternal( 'attributesList' );

        var attributeItem, attributeType, attributePointer, attributeSize;
        var isLayout = ( geometry.type === 'Layout' );

        if ( isLayout ) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.buffer );

        }

        for ( var j = 0, jl = programAttributes.length; j < jl; j ++ ) {

            attributeName = programAttributes[j][0];
            attributePointer = programAttributes[j][1];

            attributeItem = findAttribute( geometryAttributes, attributeName );
            
            if ( attributePointer >= 0 ) {

                if ( attributeItem ) {

                    attributeSize = attributeItem.itemSize;
                    attributeType = paramNWEToGL( attributeItem.type );

                    if ( isLayout ) {

                        enableAttribute( attributePointer );
                        _gl.vertexAttribPointer(attributePointer, attributeSize, attributeType, false, geometry.vertexByteSize, startIndex * geometry.vertexByteSize + attributeItem.offsetBytes );

                    } else {
                    
                        _gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
                        enableAttribute( attributePointer );
                        _gl.vertexAttribPointer( attributePointer, attributeSize, attributeType, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32

                    }

                } else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

                    if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

                        _gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

                    } else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

                        _gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

                    }

                }

            }

        }

        disableUnusedAttributes();

    };



    /***
    *** renderer GL states
    **/

    function setFaceCulling ( cullFace, frontFaceDirection ) {

        if ( cullFace === Const.CullFaceNone ) {

            _gl.disable( _gl.CULL_FACE );

        } else {

            if ( frontFaceDirection === Const.FrontFaceDirectionCW ) {

                _gl.frontFace( _gl.CW );

            } else {

                _gl.frontFace( _gl.CCW );

            }

            if ( cullFace === Const.CullFaceBack ) {

                _gl.cullFace( _gl.BACK );

            } else if ( cullFace === Const.CullFaceFront ) {

                _gl.cullFace( _gl.FRONT );

            } else {

                _gl.cullFace( _gl.FRONT_AND_BACK );

            }

            _gl.enable( _gl.CULL_FACE );

        }

    };

    function setBlending ( blending, blendEquation, blendSrc, blendDst ) {

        if ( blending !== _oldBlending ) {

            if ( blending === Const.NoBlending ) {

                _gl.disable( _gl.BLEND );

            } else if ( blending === Const.AdditiveBlending ) {

                _gl.enable( _gl.BLEND );
                _gl.blendEquation( _gl.FUNC_ADD );
                _gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

            } else if ( blending === Const.SubtractiveBlending ) {

                // TODO: Find blendFuncSeparate() combination
                _gl.enable( _gl.BLEND );
                _gl.blendEquation( _gl.FUNC_ADD );
                _gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

            } else if ( blending === Const.MultiplyBlending ) {

                // TODO: Find blendFuncSeparate() combination
                _gl.enable( _gl.BLEND );
                _gl.blendEquation( _gl.FUNC_ADD );
                _gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

            } else if ( blending === Const.CustomBlending ) {

                _gl.enable( _gl.BLEND );

            } else {

                _gl.enable( _gl.BLEND );
                _gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
                _gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

            }

            _oldBlending = blending;

        }

        if ( blending === Const.CustomBlending ) {

            if ( blendEquation !== _oldBlendEquation ) {

                _gl.blendEquation( paramNWEToGL( blendEquation ) );

                _oldBlendEquation = blendEquation;

            }

            if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

                _gl.blendFunc( paramNWEToGL( blendSrc ), paramNWEToGL( blendDst ) );

                _oldBlendSrc = blendSrc;
                _oldBlendDst = blendDst;

            }

        } else {

            _oldBlendEquation = null;
            _oldBlendSrc = null;
            _oldBlendDst = null;

        }

    };

    function setLineWidth ( width ) {

        if ( width !== _oldLineWidth ) {

            _gl.lineWidth( width );

            _oldLineWidth = width;

        }

    };

    function setPolygonOffset ( polygonoffset, factor, units ) {

        if ( _oldPolygonOffset !== polygonoffset ) {

            if ( polygonoffset ) {

                _gl.enable( _gl.POLYGON_OFFSET_FILL );

            } else {

                _gl.disable( _gl.POLYGON_OFFSET_FILL );

            }

            _oldPolygonOffset = polygonoffset;

        }

        if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

            _gl.polygonOffset( factor, units );

            _oldPolygonOffsetFactor = factor;
            _oldPolygonOffsetUnits = units;

        }

    };



    /***
    *** renderer cleat
    **/

    function clear ( color, depth, stencil ) {

        var bits = 0;

        if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
        if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
        if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

        _gl.clear( bits );

    };

    function clearTarget ( renderTarget, color, depth, stencil ) {

        setRenderTarget( renderTarget );
        clear( color, depth, stencil );

    };



    /***
    *** renderer events
    **/

    function onGeometryDispose ( event ) {

        var geometry = event.target;

        geometry.removeEventListener( 'dispose', onGeometryDispose );

        deallocateGeometry( geometry );

    };

    function onTextureDispose ( event ) {

        var texture = event.target;

        texture.removeEventListener( 'dispose', onTextureDispose );

        deallocateTexture( texture );

        Logger.renderInfo.memory.textures --;

    };

    function onRenderTargetDispose ( event ) {

        var renderTarget = event.target;

        renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

        deallocateRenderTarget( renderTarget );

        Logger.renderInfo.memory.textures --;

    };

    function onMaterialDispose ( event ) {

        var material = event.target;

        material.removeEventListener( 'dispose', onMaterialDispose );

        deallocateMaterial( material );

    };



    /***
    *** renderer materials
    **/

    function initMaterial ( material, fog, object ) {

        material.addEventListener( 'dispose', onMaterialDispose );

        var u, a, identifiers, i, parameters;

        parameters = {

            map: !!material.map,
            lightMap: !!material.lightMap,
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,

            vertexColors: material.vertexColors,

            fog: fog,
            fogExp: ( fog && fog.instanceof === 'FogExp2' ),

            useVertexTexture: _device.supportsBoneTextures() && object && object.useVertexTexture,

            alphaTest: material.alphaTest,
            doubleSided: ( material.side === Const.DoubleSide ),
            flipSided: ( material.side === Const.BackSide )

        };

        var program = new Program( material, parameters );
        var data = program.build( self );

        material.program = data.program;
        material.programId = ( material.programId === undefined || material.programId === null ) ? data.program.id + data.subId / 100 : material.programId;

        material.setInternal( 'uniformsList', [] );

        for ( var i in material.uniforms ) {

            material.getInternal( 'uniformsList' ).push([ i, material.uniforms[ i ] ]);

        }

        material.setInternal( 'attributesList', [] );

        for ( var i in material.attributes ) {

            material.getInternal( 'attributesList' ).push([ i, material.attributes[ i ] ]);

        }

    };

    function setMaterialFaces ( material ) {

        var doubleSided = material.side === Const.DoubleSide;
        var flipSided = material.side === Const.BackSide;

        if ( _oldDoubleSided !== doubleSided ) {

            if ( doubleSided ) {

                _gl.disable( _gl.CULL_FACE );

            } else {

                _gl.enable( _gl.CULL_FACE );

            }

            _oldDoubleSided = doubleSided;

        }

        if ( _oldFlipSided !== flipSided ) {

            if ( flipSided ) {

                _gl.frontFace( _gl.CW );

            } else {

                _gl.frontFace( _gl.CCW );

            }

            _oldFlipSided = flipSided;

        }

    };

    function setDepthTest ( depthTest ) {

        if ( _oldDepthTest !== depthTest ) {

            if ( depthTest ) {

                _gl.enable( _gl.DEPTH_TEST );

            } else {

                _gl.disable( _gl.DEPTH_TEST );

            }

            _oldDepthTest = depthTest;

        }

    };

    function setDepthWrite ( depthWrite ) {

        if ( _oldDepthWrite !== depthWrite ) {

            _gl.depthMask( depthWrite );
            _oldDepthWrite = depthWrite;

        }

    };

    function materialNeedsSmoothNormals ( material ) {

        return material && material.shading !== undefined && material.shading === Const.SmoothShading;

    };

    function setupMatrices ( object, camera ) {

        object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
        object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

    };



    /***
    *** renderer texture
    **/

    var getCompressedTextureFormats = ( function () {

        var array;

        return function () {

            if ( array !== undefined ) {

                return array;

            }

            array = [];

            if ( _device.getExtension('WEBGL_compressed_texture_pvrtc') || _device.getExtension('compressedTextureS3TC') ) {

                var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

                for ( var i = 0; i < formats.length; i ++ ){

                    array.push( formats[ i ] );

                }

            }
            
            return array;

        };

    } )();

    function getTextureUnit () {

        var textureUnit = _usedTextureUnits;

        if ( textureUnit >= _device.getMaxTextures() ) {

            Logger.warn( 'NWE.gfx.WebGLRenderer.getTextureUnit(): trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

        }

        _usedTextureUnits += 1;

        return textureUnit;

    };

    function isPowerOfTwo ( value ) {

        return ( value & ( value - 1 ) ) === 0;

    };

    function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

        if ( isImagePowerOfTwo ) {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramNWEToGL( texture.wrapS ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramNWEToGL( texture.wrapT ) );

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramNWEToGL( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramNWEToGL( texture.minFilter ) );

        } else {

            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
            _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

            _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
            _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

        }

        if ( _device.getMaxAnisotropy() && texture.type !== Const.FloatType ) {

            if ( texture.anisotropy > 1 || texture.getInternal( 'oldAnisotropy' ) ) {

                _gl.texParameterf( textureType, _device.getExtension('textureFilterAnisotropic').TEXTURE_MAX_ANISOTROPY_EXT, window.Math.min( texture.anisotropy, _device.getMaxAnisotropy() ) );
                texture.setInternal( 'oldAnisotropy', texture.anisotropy );

            }

        }

    };

    function setDataTexture ( texture, isImagePowerOfTwo ) {

        var glFormat = paramNWEToGL( texture.format );
        var glType = paramNWEToGL( texture.type );

        var mipmap;
        var mipmaps = texture.mipmaps;

        if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

            for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

                mipmap = mipmaps[ i ];
                _gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

            }

            texture.generateMipmaps = false;

        } else {

            _gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, texture.image.width, texture.image.height, 0, glFormat, glType, texture.image.data );

        }

    };

    function setCompressedTexture ( texture, isPowerOfTwo ) {

        var glFormat = paramNWEToGL( texture.format );
        var glType = paramNWEToGL( texture.type );

        var mipmap;
        var mipmaps = texture.mipmaps;

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

            mipmap = mipmaps[ i ];

            if ( texture.format !== Const.RGBAFormat && texture.format !== Const.RGBFormat ) {

                if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

                    _gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                } else {

                    Logger.warn( 'Attempt to load unsupported compressed texture format' );

                }

            } else {

                _gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
            
            }

        }

    };

    function setBasicTexture ( texture, isPowerOfTwo ) {

        var glFormat = paramNWEToGL( texture.format );
        var glType = paramNWEToGL( texture.type );

        var mipmap;
        var mipmaps = texture.mipmaps;

        if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

            for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

                mipmap = mipmaps[ i ];
                _gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

            }

            texture.generateMipmaps = false;

        } else {

            _gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

        }

    };


    function setTexture ( texture, slot ) {

        if ( texture.needsUpdate ) {

            if ( ! texture.getInternal( 'webglInit' ) ) {

                texture.setInternal( 'webglInit', true );

                texture.addEventListener( 'dispose', onTextureDispose );

                texture.setInternal( 'webglTexture', _gl.createTexture() );

                Logger.renderInfo.memory.textures ++;

            }

            _gl.activeTexture( _gl.TEXTURE0 + slot );
            _gl.bindTexture( _gl.TEXTURE_2D, texture.getInternal( 'webglTexture' ) );

            _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
            _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
            _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

            var image = texture.image,
            isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

            setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

            if ( texture.instanceof === 'DataTexture' ) {

                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels

                setDataTexture( texture, isImagePowerOfTwo );

            } else if ( texture.instanceof === 'CompressedTexture' ) {

                setCompressedTexture( texture, isPowerOfTwo );

            } else {

                // regular Texture (image, video, canvas)

                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels

                setBasicTexture( texture, isPowerOfTwo );

            }

            if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

            texture.needsUpdate = false;

            if ( texture.onUpdate ) texture.onUpdate();

        } else {

            _gl.activeTexture( _gl.TEXTURE0 + slot );
            _gl.bindTexture( _gl.TEXTURE_2D, texture.getInternal( 'webglTexture' ) );

        }

    };

    function clampToMaxSize ( image, maxSize ) {

        if ( image.width <= maxSize && image.height <= maxSize ) {

            return image;

        }

        // Warning: Scaling through the canvas will only work with images that use
        // premultiplied alpha.

        var maxDimension, newWidth, newHeight,
            canvas, ctx;

        maxDimension = window.Math.max( image.width, image.height );
        newWidth = window.Math.floor( image.width * maxSize / maxDimension );
        newHeight = window.Math.floor( image.height * maxSize / maxDimension );

        canvas = document.createElement( 'canvas' );
        canvas.width = newWidth;
        canvas.height = newHeight;

        ctx = canvas.getContext( "2d" );
        ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

        return canvas;

    };



    /***
    *** renderer Buffer add
    **/

    function addBuffer ( objlist, buffer, object ) {

        var id = object.id;

        objlist.push({

            id: id,
            buffer: buffer,
            object: object,
            opaque: null,
            transparent: null,
            z: 0

        });

    };



    /***
    *** renderer Buffer deallocation
    **/

    function deallocateGeometry ( geometry ) {

        geometry.setInternal( 'webglInit', undefined );

        if ( geometry.instanceof === 'DirrectBuffers' ) {

            if ( geometry.buffer !== undefined ) _gl.deleteBuffer( geometry.buffer );

            var attributes = geometry.attributes;

            for ( var key in attributes ) {

                if ( attributes[ key ].buffer !== undefined ) {

                    _gl.deleteBuffer( attributes[ key ].buffer );
        
                }

            }

            Logger.renderInfo.memory.geometries --;

        }

    };

    function deallocateTexture ( texture ) {

        // 2D texture

        if ( ! texture.getInternal( 'webglInit' ) ) return;

        texture.setInternal( 'webglInit', false );
        _gl.deleteTexture( texture.getInternal( 'webglTexture' ) );

    };

    function deallocateMaterial ( material ) {

        var program = material.program;

        if ( program === undefined ) return;

        material.program = undefined;

        // only deallocate GL program if this was the last use of shared program
        // assumed there is only single copy of any program in the _programs list
        // (that's how it's constructed)

        var i, il, programInfo;
        var deleteProgram = false;

        for ( i = 0, il = self.programs.length; i < il; i ++ ) {

            programInfo = self.programs[ i ];

            if ( programInfo.program === program ) {

                programInfo.usedTimes --;

                if ( programInfo.usedTimes === 0 ) {

                    deleteProgram = true;

                }

                break;

            }

        }

        if ( deleteProgram === true ) {

            // avoid using array.splice, this is costlier than creating new array from scratch

            var newPrograms = [];

            for ( i = 0, il = self.programs.length; i < il; i ++ ) {

                programInfo = self.programs[ i ];

                if ( programInfo.program !== program ) {

                    newPrograms.push( programInfo );

                }

            }

            self.programs = newPrograms;

            _gl.deleteProgram( program );

            Logger.renderInfo.memory.programs --;

        }

    };



    /***
    *** renderer Buffer initialization
    **/

    function initDirectBuffers ( geometry ) {

        // bind buffers

        if ( geometry.type === 'Layout' ) {

            var type = _gl.ARRAY_BUFFER;

            geometry.buffer = _gl.createBuffer();

            _gl.bindBuffer( type, geometry.buffer );
            _gl.bufferData( type, geometry.array, _gl.STATIC_DRAW );

            if ( geometry.attributes[ 'index' ] ) {

                var attribute = geometry.attributes[ 'index' ];

                type = _gl.ELEMENT_ARRAY_BUFFER;

                attribute.buffer = _gl.createBuffer();

                _gl.bindBuffer( type, attribute.buffer );
                _gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );

            }

        } else {

            for ( var i = 0, il = geometry.getInternal( 'attributesList' ).length; i < il; i ++ ) {

                var name = geometry.getInternal( 'attributesList' )[i][0];
                var bufferType = ( name === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;

                var attribute = geometry.getInternal( 'attributesList' )[i][1];
                attribute.buffer = _gl.createBuffer();

                _gl.bindBuffer( bufferType, attribute.buffer );
                _gl.bufferData( bufferType, attribute.array, _gl.STATIC_DRAW );

            }

        }

    };



    /***
    *** renderer Buffer setting
    **/

    function setDirectBuffers ( geometry, hint, dispose ) {

        var attributes = geometry.getInternal( 'attributesList' );

        var attributeName, attributeItem;

        if ( geometry.type === 'Layout' ) {
            
            if ( geometry.needsUpdate ) {

                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.buffer);
                _gl.bufferData(_gl.ARRAY_BUFFER, geometry.array, hint);

                attributeItem = findAttribute( attributes, 'index' );

                if ( attributeItem ) {

                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer);
                    _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint);

                }

                geometry.needsUpdate = false;

            }

            if ( dispose && geometry.array ) {

                geometry.array = null;
                
                for ( var i = 0, il = attributes.length; i < il; i ++ ) {

                    attributeItem = attributes[i][1];

                    attributeItem.array = null;

                    if ( attributeItem.dynamic ) {

                        Logger.warn( 'NWE.gfx.WebGLRenderer.setDirectBuffers(): to set a offsetBytes dynamic, set the property on the geometry' );

                    }

                }

            }

        } else {

            for ( var i = 0, il = attributes.length; i < il; i ++ ) {

                attributeName = attributes[i][0]
                attributeItem = attributes[i][1];

                if ( attributeItem.needsUpdate ) {

                    if ( attributeName === 'index' ) {

                        _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );
                        _gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );

                    } else {

                        _gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
                        _gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );

                    }

                    attributeItem.needsUpdate = false;

                    if ( dispose && ! attributeItem.dynamic ) {

                        attributeItem.array = null;

                    }

                }

            }

        }

    };



    /***
    *** renderer Buffer helpers
    **/

    function getBufferMaterial ( object, geometryGroup ) {

        return object.material;

    };

    function bufferGuessNormalType ( material ) {

        // only MeshBasicMaterial and MeshDepthMaterial don't need normals

        if ( material.instanceof === 'MeshBasicMaterial' || material.instanceof === 'MeshDepthMaterial' ) {

            return false;

        }

        if ( materialNeedsSmoothNormals( material ) ) {

            return Const.SmoothShading;

        } else {

            return Const.FlatShading;

        }

    };

    function bufferGuessVertexColorType ( material ) {

        if ( material.vertexColors ) {

            return material.vertexColors;

        }

        return false;

    };

    function bufferGuessUVType ( material ) {

        // material must use some texture to require uvs

        if ( material.map ||
             material.lightMap ||
             material.bumpMap ||
             material.normalMap ||
             material.specularMap ||
             material instanceof ShaderMaterial ) {

            return true;

        }

        return false;

    };


    /***
    *** renderer Buffer rendering
    **/

    function renderBufferDirect ( camera, fog, material, geometry, object ) {

        if ( object.visible === false ) return;

        var linewidth, a, attribute;
        var attributeItem, attributeType, attributePointer, attributeSize;

        var program = setProgram( camera, fog, material, object );

        var programAttributes = program.attributes;
        var geometryAttributes = geometry.getInternal( 'attributesList' );

        var updateBuffers = false,
            wireframeBit = material.wireframe ? 1 : 0,
            geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

        if ( geometryHash !== _currentGeometryGroupHash ) {

            _currentGeometryGroupHash = geometryHash;
            updateBuffers = true;

        }

        if ( updateBuffers ) {

            initAttributes();

        }

        // render mesh

        if ( object.instanceof === 'Mesh' ) {

            var index = findAttribute( geometryAttributes, 'index' );

            var offsets = geometry.offsets;

            // if there is more than 1 chunk
            // must set attribute pointers to use new offsets for each chunk
            // even if geometry and materials didn't change

            if ( offsets.length > 1 ) updateBuffers = true;

            for ( var i = 0, il = offsets.length; i < il; i ++ ) {

                var startIndex = offsets[ i ].index;

                if ( updateBuffers ) {

                    setupVertexAttributes( material, program, geometry, startIndex );

                    // indices

                    _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

                }

                // render indexed triangles

                if ( index.type === Const.Uint32 ) {

                    _gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_INT, offsets[ i ].start * 4 ); // 4 bytes per Uint32

                } else {

                    _gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16

                }

                if ( !isComposerRender ) {

                    Logger.renderInfo.render.calls ++;
                    Logger.renderInfo.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
                    Logger.renderInfo.render.faces += offsets[ i ].count / 3;

                }

            }

        } else if ( object.instanceof === 'Line' ) {

            if ( updateBuffers ) {

                setupVertexAttributes( material, program, geometry, 0 );

            }

            // render lines

            var mode = ( object.type === Const.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

            setLineWidth( material.linewidth );

            var position = findAttribute( geometryAttributes, 'position' );

            _gl.drawArrays( mode, 0, position.numItems / 3 );

            if ( !isComposerRender ) {

                Logger.renderInfo.render.calls ++;
                Logger.renderInfo.render.points += position.numItems;

            }

        } else if ( object.instanceof === 'PointCloud' ) {

            // render particles

            var mode = _gl.POINTS;

            var index = geometry.attributes.index;

            if ( index ) {

                // indexed points

            } else {

                // non-indexed points

                if ( updateBuffers ) {

                    setupVertexAttributes( material, program, geometry, 0 );

                }

                var position = findAttribute( geometryAttributes, 'position' );
                var offsets = geometry.offsets;
                var startIndex;

                for ( var i = 0, il = offsets.length; i < il; i ++ ) {

                    startIndex = offsets[ i ].index;

                    _gl.drawArrays( mode, 0, offsets[ i ].count );

                    Logger.renderInfo.render.calls ++;
                    Logger.renderInfo.render.points += offsets[ i ].count;

                }

            }

        }

    };



    /***
    *** renderer Buffer unroll
    **/

    function unrollBufferMaterial ( globject ) {

        var object = globject.object;
        var buffer = globject.buffer;

        var geometry = object.geometry;
        var material = object.material;

        if ( material ) {

            if ( material.transparent ) {

                globject.transparent = material;
                globject.opaque = null;

            } else {

                globject.opaque = material;
                globject.transparent = null;

            }

        }

    };


    /***
    *** renderer lights support
    **/

    function setupLights ( lights ) {

        var zlights = _lights;
        var r = 0, g = 0, b = 0;
        var color, intensity, distance;

        var dirCount = 0;
        var dirOffset;
        var dirLength = 0;

        for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

            light = lights[ l ];

            color = light.color;
            intensity = light.intensity;
            distance = light.distance;

            if ( light.instanceof === 'AmbientLight' ) {

                if ( ! light.visible ) continue;

                r += color.r;
                g += color.g;
                b += color.b;

            } else if ( light.instanceof === 'DirectionalLight' ) {

                dirCount += 1;

                if ( ! light.visible ) continue;

                _direction.setFromMatrixPosition( light.matrixWorld );
                _vector3.setFromMatrixPosition( light.target.matrixWorld );
                _direction.sub( _vector3 );
                _direction.normalize();

                // dirOffset = dirLength * 3;

                // dirPositions[ dirOffset ]     = _direction.x;
                // dirPositions[ dirOffset + 1 ] = _direction.y;
                // dirPositions[ dirOffset + 2 ] = _direction.z;

                // setColorLinear( dirColors, dirOffset, color, intensity );

                dirLength += 1;

            } else {

                // todo

            }

        }

        zlights.ambient.setRGB( r, g, b );

    };



    /***
    *** renderer object control
    **/

    function addObject ( object ) {

        if ( object.getInternal( 'webglInit' ) === undefined ) {

            object.setInternal( 'webglInit', true );

            object._modelViewMatrix = new Matrix4();
            object._normalMatrix = new Matrix3();

        }

        object.addEventListener( 'remove', removeObject );

        if ( object.instanceof === 'Mesh' || object.instanceof === 'Line' || object.instanceof === 'PointCloud' ) {

            var geometry = object.geometry;

            if ( geometry && geometry.getInternal( 'webglInit' ) === undefined ) {

                geometry.setInternal( 'webglInit', true );
                geometry.addEventListener( 'dispose', onGeometryDispose );

                if ( geometry.instanceof === 'DirrectBuffers' ) {

                    initDirectBuffers( geometry );

                } else if ( object.instanceof === 'Line' ) {

                    // ?

                }

            }

        }

        if ( object.getInternal( 'webglActive' ) === undefined ) {

            if ( object.instanceof === 'Mesh' || object.instanceof === 'Line' || object.instanceof === 'PointCloud' ) {

                _webglObjects.push( object );

            } else if ( object.instanceof === 'Sprite' ) {

                _webglSprites.push( object );

            } else if ( object instanceof Light ) {

                _webglLights.push( object );

            }

            object.setInternal( 'webglActive', true );

        }

    };

    function updateObject ( object ) {

        var geometry = object.geometry;

        if ( geometry && geometry.instanceof === 'DirrectBuffers' ) {

            setDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );

        }

        // todo?

    };

    function removeObject () {

        var object = this;

        object.status[rendererId] = 'remove';

        var target;

        if ( object.instanceof === 'Mesh' ) target = _webglObjects;
        if ( object.instanceof === 'Sprite' ) target = _webglSprites;

        removeInstances( target, object );
            
        object.removeInternal( 'webglActive' );

    };

    function initObject ( object ) {

        if ( object instanceof Object3D ) {

            if ( ! object.status[rendererId] ) {

                addObject( object );
                object.status[rendererId] = 'added';

            }

        }

    };

    function projectObjects ( scene, camera ) {

        getObjectsList( scene, scene );

        for ( var i = 0, l = _webglObjects.length; i < l; i ++ ) {

            var object = _webglObjects[i];

            if ( object.visible === false || ( object.frustumCulled === true && _frustum.intersectsObject( object ) === false ) ) {

                object.render = false;

            } else {

                setupMatrices( object, camera );

                updateObject( object );

                // unrollBufferMaterial( webglObject );

                object.render = true;

                // if ( self.sortObjects === true ) {

                //     if ( object.renderDepth !== null ) {

                //         webglObject.z = object.renderDepth;

                //     } else {

                //         _vector3.setFromMatrixPosition( object.matrixWorld );
                //         _vector3.applyProjection( _projScreenMatrix );

                //         webglObject.z = _vector3.z;

                //     }

                // }

            }

        }

    };

    function getObjectsList ( scene, object ) {

        if ( object.visible === false ) return;

        if ( object.instanceof === 'Scene' ) {

            // skip

        } else {

            initObject( object );

        }

        for ( var i = 0, l = object.children.length; i < l; i ++ ) {

            getObjectsList( scene, object.children[ i ] );

        }

    };



    /***
    *** renderer Instances remove
    **/

    function removeInstances ( objlist, object ) {

        for ( var o = objlist.length - 1; o >= 0; o -- ) {

            if ( objlist[ o ].uuid === object.uuid ) {

                objlist.splice( o, 1 );

            }

        }

    };



    /***
    *** renderer uniforms load
    **/

    function findUniform ( uniforms, id ) {

        for ( var i = 0, il = uniforms.length; i < il; i ++ ) {

            if ( uniforms[ i ] && uniforms[ i ][ 0 ] === id ) {

                return uniforms[ i ][ 1 ]

            }

        }

        return false;

    };

    function setUniform ( uniforms, id, value ) {

        var uniform = findUniform( uniforms, id );

        if ( ! uniform ) {

            // Logger.warn( 'NWE.gfx.WebGLRenderer.setUniform():  Uniform ' + id + ' not found.' );
            return;

        }

        uniform.value = value;

    };

    // Uniforms (load to GPU)

    function loadUniformsMatrices ( uniforms, object ) {

        var modelViewMatrix = findUniform( uniforms, 'modelViewMatrix' );
        var normalMatrix = findUniform( uniforms, 'normalMatrix' );

        if ( modelViewMatrix /*&& modelViewMatrix.needsUpdate*/ ) { // check this out

            _gl.uniformMatrix4fv( modelViewMatrix.location, false, object._modelViewMatrix.elements );
            modelViewMatrix.needsUpdate = false;

        }

        if ( normalMatrix /*&& normalMatrix.needsUpdate*/ ) {

            _gl.uniformMatrix3fv( normalMatrix.location, false, object._normalMatrix.elements );
            normalMatrix.needsUpdate = false;

        }

    };

    function loadUniformsGeneric ( program, uniforms ) {

        var uniform,
            value, type, location, needsUpdate, globalUsage,
            texture, textureUnit,
            i, il, j, jl,
            offset, rawUniform;

        for ( j = 0, jl = uniforms.length; j < jl; j ++ ) {

            rawUniform = findUniform( program.uniforms, uniforms[ j ][ 0 ] );

            location = rawUniform.location;
            needsUpdate = rawUniform.needsUpdate;
            globalUsage = rawUniform.globalLevel;

            if ( ! location ) continue;

            uniform = uniforms[ j ][ 1 ];

            needsUpdate = needsUpdate || uniform.needsUpdate;

            type = uniform.type;
            value = uniform.value;

            if ( value === undefined || value === null ) continue;

            if ( globalUsage > 0 && ! needsUpdate ) {

                if ( type === 't' ) getTextureUnit();
                
                continue;

            }

            if ( ! uniform.needsUpdate && ! rawUniform.needsUpdate && globalUsage !== -1 ) continue;

            rawUniform.needsUpdate = false;
            uniform.needsUpdate = false;

            switch ( type ) {

                case 'i': // single integer
                    _gl.uniform1i( location, value );
                    break;

                case 'f': // single float
                    _gl.uniform1f( location, value );
                    break;

                case 'v2': // single NWE.Vec2
                    _gl.uniform2f( location, value.x, value.y );
                    break;

                case 'v3': // single NWE.Vec3
                    _gl.uniform3f( location, value.x, value.y, value.z );
                    break;

                case 'v4': // single NWE.Vec4
                    _gl.uniform4f( location, value.x, value.y, value.z, value.w );
                    break;

                case 'c': // single NWE.Color
                    _gl.uniform3f( location, value.r, value.g, value.b );
                    break;

                case 'iv1': // flat array of integers (JS or typed array)
                    _gl.uniform1iv( location, value );
                    break;

                case 'iv': // flat array of integers with 3 x N size (JS or typed array)
                    _gl.uniform3iv( location, value );
                    break;

                case 'fv1': // flat array of floats (JS or typed array)
                    _gl.uniform1fv( location, value );
                    break;

                case 'fv': // flat array of floats with 3 x N size (JS or typed array)
                    _gl.uniform3fv( location, value );
                    break;

                case 'v2v': // array of NWE.Vec2

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 2 * value.length );

                    }

                    for ( i = 0, il = value.length; i < il; i ++ ) {

                        offset = i * 2;

                        uniform._array[ offset ]     = value[ i ].x;
                        uniform._array[ offset + 1 ] = value[ i ].y;

                    }

                    _gl.uniform2fv( location, uniform._array );

                    break;

                case 'v3v': // array of NWE.Vec3

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 3 * value.length );

                    }

                    for ( i = 0, il = value.length; i < il; i ++ ) {

                        offset = i * 3;

                        uniform._array[ offset ]     = value[ i ].x;
                        uniform._array[ offset + 1 ] = value[ i ].y;
                        uniform._array[ offset + 2 ] = value[ i ].z;

                    }

                    _gl.uniform3fv( location, uniform._array );

                    break;

                case 'v4v': // array of NWE.Vec4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 4 * value.length );

                    }

                    for ( i = 0, il = value.length; i < il; i ++ ) {

                        offset = i * 4;

                        uniform._array[ offset ]     = value[ i ].x;
                        uniform._array[ offset + 1 ] = value[ i ].y;
                        uniform._array[ offset + 2 ] = value[ i ].z;
                        uniform._array[ offset + 3 ] = value[ i ].w;

                    }

                    _gl.uniform4fv( location, uniform._array );

                    break;

                case 'm4': // single NWE.Matrix4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 16 );

                    }

                    value.flattenToArray( uniform._array );
                    _gl.uniformMatrix4fv( location, false, uniform._array );

                    break;

                case 'm4v': // array of NWE.Matrix4

                    if ( uniform._array === undefined ) {

                        uniform._array = new Float32Array( 16 * value.length );

                    }

                    for ( i = 0, il = value.length; i < il; i ++ ) {

                        if ( ! value[ i ] ) continue;

                        value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

                    }

                    _gl.uniformMatrix4fv( location, false, uniform._array );

                    break;

                case 't': // single NWE.gfx.Texture (2d)

                    texture = value;
                    textureUnit = getTextureUnit();

                    _gl.uniform1i( location, textureUnit );

                    if ( ! texture ) continue;

                    setTexture( texture, textureUnit );

                    break;

                case 'tv': // array of NWE.gfx.Texture (2d)

                    if ( uniform._array === undefined ) {

                        uniform._array = [];

                    }

                    for ( i = 0, il = uniform.value.length; i < il; i ++ ) {

                        uniform._array[ i ] = getTextureUnit();

                    }

                    _gl.uniform1iv( location, uniform._array );

                    for ( i = 0, il = uniform.value.length; i < il; i ++ ) {

                        texture = uniform.value[ i ];
                        textureUnit = uniform._array[ i ];

                        if ( !texture ) continue;

                        setTexture( texture, textureUnit );

                    }

                    break;

                default:

                    Logger.warn( 'NWE.gfx.WebGLRenderer.loadUniformsGeneric(): Unknown uniform type: ' + type );

            }

        }

    };



    /***
    *** renderer uniforms refresh
    **/

    function refreshUniformsLights ( uniforms ) {

        // ambient light update

        setUniform( uniforms, 'ambientLightColor', _lights.ambient );

        // todo: rest

    };

    function refreshUniformsCommon ( uniforms, material ) {

        if ( material.opacity ) {

            setUniform( uniforms, 'opacity', material.opacity );

        }

        if ( material.color ) {

            setUniform( uniforms, 'diffuse', material.color );

        }

        if ( material.ambient ) {

            setUniform( uniforms, 'ambient', material.ambient );

        }

        if ( material.map ) {

            setUniform( uniforms, 'map', material.map );

        }

        if ( material.lightMap ) {

            setUniform( uniforms, 'lightMap', material.lightMap );

        }

        if ( material.bumpMap ) {

            setUniform( uniforms, 'bumpMap', material.bumpMap );
            setUniform( uniforms, 'bumpScale', material.bumpScale );

        }

        if ( material.normalMap ) {

            setUniform( uniforms, 'normalMap', material.normalMap );
            setUniform( uniforms, 'normalScale', material.normalScale );

        }

        var uvScaleMap;

        if ( material.map ) {

            uvScaleMap = material.map;

        } else if ( material.normalMap ) {

            uvScaleMap = material.normalMap;

        } else if ( material.bumpMap ) {

            uvScaleMap = material.bumpMap;

        }

        if ( uvScaleMap !== undefined ) {

            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;

            findUniform( uniforms, 'offsetRepeat' ).value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

    };

    function refreshUniformsLine ( uniforms, material ) {

        setUniform( uniforms, 'diffuse', material.color );
        setUniform( uniforms, 'opacity', material.opacity );

    };

    function refreshUniformsDash ( uniforms, material ) {

        setUniform( uniforms, 'dashSize', material.dashSize );
        setUniform( uniforms, 'totalSize', material.dashSize + material.gapSize );
        setUniform( uniforms, 'scale', material.scale );

    };

    function refreshUniformsFog ( uniforms, fog ) {

        setUniform( uniforms, 'fogColor', fog.color );

        if ( fog.instanceof === 'Fog' ) {

            setUniform( uniforms, 'fogNear', fog.near );
            setUniform( uniforms, 'fogFar', fog.far );

        } else if ( fog.instanceof === 'FogExp2' ) {

            setUniform( uniforms, 'fogDensity', fog.density );

        }

    };

    function refreshUniformsShadow ( uniforms ) {

        var shadowMatrix = findUniform( uniforms, 'shadowMatrix' ).value;

        if ( shadowMatrix ) {

            var j = 0;

            for ( var i = 0, il = _webglLights.length; i < il; i ++ ) {

                var light = _webglLights[ i ];

                if ( ! light.castShadow ) continue;

                if ( light.instanceof === 'SpotLight' || ( light.instanceof == 'DirectionalLight' ) ) {

                    findUniform( uniforms, 'shadowMap' ).value[ j ] = light.shadowMap;
                    findUniform( uniforms, 'shadowMapSize' ).value[ j ] = light.shadowMapSize;

                    findUniform( uniforms, 'shadowMatrix' ).value[ j ] = light.shadowMatrix;

                    findUniform( uniforms, 'shadowDarkness' ).value[ j ] = light.shadowDarkness;
                    findUniform( uniforms, 'shadowBias' ).value[ j ] = light.shadowBias;

                    j ++;

                }

            }

        }

    };

    function refreshUniformsLambert ( uniforms, material ) {

        //

    };



    /***
    *** renderer programs
    **/

    function setProgram ( camera, fog, material, object ) {

        _usedTextureUnits = 0;

        var scene = object.scene;

        if ( material.needsUpdate ) {

            if ( material.program ) deallocateMaterial( material );

            initMaterial( material, fog, object );
            material.needsUpdate = false;

        }

        var refreshMaterial = false;
        var refreshLights = false;
            
        var program = material.program,
            p_uniforms = program.uniforms,
            m_uniforms = material.getInternal( 'uniformsList' );

        if ( program.id !== _currentProgram.id ) {

            _gl.useProgram( program );
            _currentProgram = program;

            refreshMaterial = true;

            for ( var i = 0, il = p_uniforms.length; i < il; i ++ ) {

                if ( p_uniforms[ i ][ 1 ].globalLevel === 2 ) {

                    continue;

                }

                p_uniforms[ i ][ 1 ].needsUpdate = true;

            }

            refreshLights = true;

        }

        if ( material.id !== _currentMaterialId ) {

            _currentMaterialId = material.id;
            refreshMaterial = true;

        }

        if ( refreshMaterial || camera.id !== _currentCameraId || camera.needsUpdate ) {

            var projectionMatrix = findUniform( p_uniforms, 'projectionMatrix' );

            _gl.uniformMatrix4fv( projectionMatrix.location, false, camera.projectionMatrix.elements );
            projectionMatrix.needsUpdate = false;
            camera.needsUpdate = false;

            _currentCameraId = camera.id;

        }

        if ( refreshMaterial ) {

            // refresh uniforms common to several materials

            if ( fog ) {

                refreshUniformsFog( m_uniforms, fog );

            }

            if ( material.instanceof === 'MeshBasicMaterial' ||
                 material.instanceof === 'MeshLambertMaterial' ) {

                refreshUniformsCommon( m_uniforms, material );

            }

            if ( material.lights || true ) { // tmp

                if ( _lightsNeedsUpdate ) {

                    // needs refactor
                    refreshLights = true;
                    setupLights( _webglLights );
                    _lightsNeedsUpdate = false;

                }

            }

            // update global light sys

            if ( refreshLights ) {

                refreshUniformsLights( m_uniforms );

            }

            // refresh single material specific uniforms

            if ( material.instanceof === 'LineBasicMaterial' ) {

                refreshUniformsLine( m_uniforms, material );

            } else if ( material.instanceof === 'LineDashedMaterial' ) {

                refreshUniformsLine( m_uniforms, material );
                refreshUniformsDash( m_uniforms, material );

            } else if ( material.instanceof === 'MeshLambertMaterial' ) {

                refreshUniformsLambert( m_uniforms, material );

            } else if ( material.instanceof === 'MeshDepthMaterial' ) {

                m_uniforms.mNear.value = camera.near;
                m_uniforms.mFar.value = camera.far;
                m_uniforms.opacity.value = material.opacity;

            } else if ( material.instanceof === 'MeshNormalMaterial' ) {

                m_uniforms.opacity.value = material.opacity;

            }

            //

            if ( object.receiveShadow ) {

                refreshUniformsShadow( m_uniforms );

            }

            // load common uniforms

            loadUniformsGeneric( program, material.getInternal( 'uniformsList' ) );

            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)

            if ( material.instanceof === 'ShaderMaterial' ) {

                var cameraPositionUniform = findUniform( p_uniforms, 'cameraPosition' );

                if ( cameraPositionUniform !== null && cameraPositionUniform.needsUpdate ) {

                    _vector3.getPositionFromMatrix( camera.matrixWorld );
                    _gl.uniform3f( cameraPositionUniform.location, _vector3.x, _vector3.y, _vector3.z );
                    cameraPositionUniform.needsUpdate = false;

                }

            }

            if ( material.instanceof === 'MeshLambertMaterial' || material.instanceof === 'ShaderMaterial' ) {

                var viewMatrixUniform = findUniform( p_uniforms, 'viewMatrix' );

                if ( viewMatrixUniform !== null && viewMatrixUniform.needsUpdate ) {

                    _gl.uniformMatrix4fv( viewMatrixUniform.location, false, camera.matrixWorldInverse.elements );
                    viewMatrixUniform.needsUpdate = false;

                }

            }

        }

        loadUniformsMatrices( p_uniforms, object );

        var modelMatrixUniform = findUniform( p_uniforms, 'modelMatrix' );

        if ( modelMatrixUniform !== null && modelMatrixUniform.needsUpdate ) {

            _gl.uniformMatrix4fv( modelMatrixUniform.location, false, object.matrixWorld.elements );
            // modelMatrixUniform.needsUpdate = false; // tmp

        }

        return program;

    };



    /***
    *** renderer rendering
    **/

    function render ( scene, camera, renderTarget, forceClear, _isComposerRender ) {

        if ( camera.instanceof !== 'PerspectiveCamera' && camera.instanceof !== 'OrthographicCamera' && camera.instanceof !== 'Camera' ) {

            Logger.error( 'NWE.gfx.WebGLRenderer.render(): camera is not an instance of NWE.gfx.Camera.' );
            return;

        }

        // if composer frame rendering

        isComposerRender = _isComposerRender;

        var i, il,

            fog = scene.fog;

        // reset caching for this frame

        _currentSceneId = scene.id;

        _currentMaterialId = -1;

        // update scene graph

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

        // update camera matrices and frustum

        if ( camera.parent === undefined ) camera.updateMatrixWorld();

        camera.matrixWorldInverse.getInverse( camera.matrixWorld );

        _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
        _frustum.setFromMatrix( _projScreenMatrix );

        // custom render plugins (pre pass)

        if ( ! isComposerRender ) {

            renderPlugins( renderPluginsPre, scene, camera );

        }

        //

        if ( ! isComposerRender ) {

            Logger.renderInfo.render.calls = 0;
            Logger.renderInfo.render.vertices = 0;
            Logger.renderInfo.render.faces = 0;
            Logger.renderInfo.render.points = 0;

        }

        // update WebGL objects

        projectObjects( scene, camera );

        if ( sortObjects ) {

            SortByProgram( _webglObjects );

        }

        setRenderTarget( renderTarget );

        if ( autoClear || forceClear ) {

            clear( autoClearColor, autoClearDepth, autoClearStencil );

        }

        if ( scene.overrideMaterial ) {

            var material = scene.overrideMaterial;

            setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
            setDepthTest( material.depthTest );
            setDepthWrite( material.depthWrite );
            setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

            renderObjects( camera, fog, true, material );

        } else {

            var material = null;

            // opaque pass (front-to-back order)

            setBlending( Const.NoBlending );

            renderObjects( camera, fog, false, material );

        }

        // custom render plugins (post pass)

        if ( ! isComposerRender ) {

            renderPlugins( renderPluginsPost, scene, camera );

        }

        // Generate mipmap if we're using any kind of mipmap filtering

        if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== Const.NearestFilter && renderTarget.minFilter !== Const.LinearFilter ) {

            updateRenderTargetMipmap( renderTarget );

        }

        // Ensure depth buffer writing is enabled so it can be cleared on next render

        setDepthTest( true );
        setDepthWrite( true );

        // _gl.finish();

    };

    function renderPlugins ( plugins, scene, camera ) {

        if ( ! plugins.length ) return;

        for ( var i = 0, il = plugins.length; i < il; i ++ ) {

            // reset state for plugin (to start from clean slate)

            _currentProgram = _emptyProgram;

            _oldBlending = -1;
            _oldDepthTest = -1;
            _oldDepthWrite = -1;
            _oldDoubleSided = -1;
            _oldFlipSided = -1;
            _currentGeometryGroupHash = -1;
            _currentMaterialId = -1;
            _currentCameraId = -1;

            _lightsNeedsUpdate = true;

            plugins[ i ].render( scene, camera, _currentWidth, _currentHeight, _webglObjects, _webglSprites );

            // reset state after plugin (anything could have changed)

            _currentProgram = _emptyProgram;

            _oldBlending = -1;
            _oldDepthTest = -1;
            _oldDepthWrite = -1;
            _oldDoubleSided = -1;
            _oldFlipSided = -1;
            _currentGeometryGroupHash = -1;
            _currentMaterialId = -1;
            _currentCameraId = -1;

            _lightsNeedsUpdate = true;

        }

    };

    function renderObjects ( camera, fog, useBlending, overrideMaterial ) {

        var webglObject, object, buffer, material, start, end, delta;

        start = 0;
        end = _webglObjects.length;
        delta = 1;

        for ( var i = start; i !== end; i += delta ) {

            webglObject = _webglObjects[ i ];

            if ( webglObject.render && webglObject.scenesOwners[ _currentSceneId ] ) {

                object = webglObject;
                buffer = webglObject.geometry;

                if ( overrideMaterial ) {

                    material = overrideMaterial;

                } else {

                    material = webglObject.material;

                    if ( ! material ) continue;

                    if ( material.transparent ) setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst ); // redo

                    setDepthTest( material.depthTest );
                    setDepthWrite( material.depthWrite );
                    setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

                }

                setMaterialFaces( material );

                if ( buffer.instanceof === 'DirrectBuffers' ) {

                    renderBufferDirect( camera, fog, material, buffer, object );

                }

            }

        }

    };



    /***
    *** renderer render target
    **/

    function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.getInternal( 'webglTexture' ), 0 );

    };

    function setupRenderBuffer ( renderbuffer, renderTarget  ) {

        _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

        if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

        /*
        For some reason this is not working. Defaulting to RGBA4.
        } else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
        */
        } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

        } else {

            _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

        }

    };

    function setRenderTarget ( renderTarget ) {

        if ( renderTarget && ! renderTarget.getInternal( 'webglFramebuffer' ) ) {

            if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
            if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

            renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

            renderTarget.setInternal( 'webglTexture', _gl.createTexture() );

            Logger.renderInfo.memory.textures ++;

            // Setup texture, create render and frame buffers

            var isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),
                glFormat = paramNWEToGL( renderTarget.format ),
                glType = paramNWEToGL( renderTarget.type );

            renderTarget.setInternal( 'webglFramebuffer', _gl.createFramebuffer() );

            if ( renderTarget.shareDepthFrom ) {

                renderTarget.setInternal( 'webglRenderbuffer', renderTarget.shareDepthFrom.getInternal( 'webglRenderbuffer' ) );

            } else {

                renderTarget.setInternal( 'webglRenderbuffer', _gl.createRenderbuffer() );

            }

            _gl.bindTexture( _gl.TEXTURE_2D, renderTarget.getInternal( 'webglTexture' ) );
            setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

            _gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

            setupFrameBuffer( renderTarget.getInternal( 'webglFramebuffer' ), renderTarget, _gl.TEXTURE_2D );

            if ( renderTarget.shareDepthFrom ) {

                if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

                    _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.getInternal( 'webglRenderbuffer' ) );

                } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

                    _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.getInternal( 'webglRenderbuffer' ) );

                }

            } else {

                setupRenderBuffer( renderTarget.getInternal( 'webglRenderbuffer' ), renderTarget );

            }

            if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

            // Release everything

            _gl.bindTexture( _gl.TEXTURE_2D, null );

            _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
            _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

        }

        var framebuffer, width, height, vx, vy;

        if ( renderTarget ) {

            framebuffer = renderTarget.getInternal( 'webglFramebuffer' );

            width = renderTarget.width;
            height = renderTarget.height;

            vx = 0;
            vy = 0;

        } else {

            framebuffer = null;

            width = self.viewport.width;
            height = self.viewport.height;

            vx = self.viewport.X;
            vy = self.viewport.Y;

        }

        if ( framebuffer !== _currentFramebuffer ) {

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
            _gl.viewport( vx, vy, width, height );

            _currentFramebuffer = framebuffer;

        }

        _currentWidth = width;
        _currentHeight = height;

    };

    function updateRenderTargetMipmap ( renderTarget ) {

        _gl.bindTexture( _gl.TEXTURE_2D, renderTarget.getInternal( 'webglTexture' ) );
        _gl.generateMipmap( _gl.TEXTURE_2D );
        _gl.bindTexture( _gl.TEXTURE_2D, null );

    };



    /***
    *** init renderer
    **/

    function setDefaultGLState () {

        _gl.clearColor( 0, 0, 0, 1 );
        _gl.clearDepth( 1 );
        _gl.clearStencil( 0 );

        _gl.enable( _gl.DEPTH_TEST );
        _gl.depthFunc( _gl.LEQUAL );

        _gl.frontFace( _gl.CCW );
        _gl.cullFace( _gl.BACK );
        _gl.enable( _gl.CULL_FACE );

        _gl.enable( _gl.BLEND );
        _gl.blendEquation( _gl.FUNC_ADD );
        _gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

        _gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    };

    function initGL () {

        try {

            var attributes = {
                alpha: _alpha,
                premultipliedAlpha: _premultipliedAlpha,
                antialias: _antialias,
                stencil: _stencil,
                preserveDrawingBuffer: _preserveDrawingBuffer
            };

            _gl = _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

            if ( _gl === null ) {

                throw 'Error creating WebGL context.';

            } else {

                _device = CheckDeviceCapabilities( self );
                self.device = _device;

            }

        } catch ( error ) {

            Logger.error( 'NWE.gfx.WebGLRenderer initing error: ' + error );

        }

        if ( _gl.getShaderPrecisionFormat === undefined ) {

            _gl.getShaderPrecisionFormat = function () {

                return {
                    "rangeMin"  : 1,
                    "rangeMax"  : 1,
                    "precision" : 1
                };

            }
        }

    };

    // Initialize

    initGL();

    setDefaultGLState();

    // Create viewport

    self.viewport = new Viewport ( self, _canvas );

    self.instanceOf = 'WebGLRenderer';

    }



    if ( typeof renderersList === 'function' ) {
        var t = {}, p = {};
        for ( var i in renderersList ) t[i] = renderersList[i];
        for ( var i in renderersList.prototype ) try { p[i] = renderersList.prototype[i] } catch(e) {};
        scope.renderersList = renderersList.bind( scope );
    } else {
        scope.renderersList = renderersList;
    }
    scope.renderersList.prototype = renderersList.prototype;
    for ( var i in t ) scope.renderersList[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.renderersList.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__renderersList ) {
        for ( var i = 0, il = scope.__renderersList.length; i < il; i ++ ) scope.__renderersList[ i ]( renderersList );
        delete scope.__renderersList;
    }

    if ( typeof WebGLRenderer === 'function' ) {
        var t = {}, p = {};
        for ( var i in WebGLRenderer ) t[i] = WebGLRenderer[i];
        for ( var i in WebGLRenderer.prototype ) try { p[i] = WebGLRenderer.prototype[i] } catch(e) {};
        scope.WebGLRenderer = WebGLRenderer.bind( scope );
    } else {
        scope.WebGLRenderer = WebGLRenderer;
    }
    scope.WebGLRenderer.prototype = WebGLRenderer.prototype;
    for ( var i in t ) scope.WebGLRenderer[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.WebGLRenderer.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__WebGLRenderer ) {
        for ( var i = 0, il = scope.__WebGLRenderer.length; i < il; i ++ ) scope.__WebGLRenderer[ i ]( WebGLRenderer );
        delete scope.__WebGLRenderer;
    }

}) ( NWE.gfx );


// src/graphics/renderers/WebGLRenderTarget.js

( function ( scope ) {

    /**
     * @author szimek / https://github.com/szimek/
     * @author alteredq / http://alteredqualia.com/
     */



    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var WebGLRenderTarget = function ( width, height, params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        this.uuid = Math.generateUUID();
        internal[ this.uuid ] = objInternal;

        this.width = width;
        this.height = height;

        this.wrapS = ( params.wrapS !== undefined ) ? params.wrapS : Const.ClampToEdgeWrapping;
        this.wrapT = ( params.wrapT !== undefined ) ? params.wrapT : Const.ClampToEdgeWrapping;

        this.magFilter = ( params.magFilter !== undefined ) ? params.magFilter : Const.LinearFilter;
        this.minFilter = ( params.minFilter !== undefined ) ? params.minFilter : Const.LinearMipMapLinearFilter;

        this.anisotropy = ( params.anisotropy !== undefined ) ? params.anisotropy : 1;

        this.offset = new Vec2( 0, 0 );
        this.repeat = new Vec2( 1, 1 );

        this.format = ( params.format !== undefined ) ? params.format : Const.RGBAFormat;
        this.type = ( params.type !== undefined ) ? params.type : Const.UnsignedByteType;

        this.depthBuffer = ( params.depthBuffer !== undefined ) ? params.depthBuffer : true;
        this.stencilBuffer = ( params.stencilBuffer !== undefined ) ? params.stencilBuffer : true;

        this.generateMipmaps = true;

        this.shareDepthFrom = null;

        //

        this.instanceof = 'WebGLRenderTarget';

    };

    WebGLRenderTarget.prototype = {

        constructor: WebGLRenderTarget,

        clone: function () {

            var tmp = new WebGLRenderTarget( this.width, this.height );

            tmp.wrapS = this.wrapS;
            tmp.wrapT = this.wrapT;

            tmp.magFilter = this.magFilter;
            tmp.minFilter = this.minFilter;

            tmp.anisotropy = this.anisotropy;

            tmp.offset.copy( this.offset );
            tmp.repeat.copy( this.repeat );

            tmp.format = this.format;
            tmp.type = this.type;

            tmp.depthBuffer = this.depthBuffer;
            tmp.stencilBuffer = this.stencilBuffer;

            tmp.generateMipmaps = this.generateMipmaps;

            tmp.shareDepthFrom = this.shareDepthFrom;

            return tmp;

        },

        dispose: function () {

            this.dispatchEvent( { type: 'dispose' } );

        }

    };

    EventDispatcher.prototype.apply( WebGLRenderTarget.prototype );

    WebGLRenderTarget.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    WebGLRenderTarget.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    WebGLRenderTarget.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    WebGLRenderTarget.setInternal = function ( name, value ) { internal[ name ] = value; };
    WebGLRenderTarget.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof WebGLRenderTarget === 'function' ) {
        var t = {}, p = {};
        for ( var i in WebGLRenderTarget ) t[i] = WebGLRenderTarget[i];
        for ( var i in WebGLRenderTarget.prototype ) try { p[i] = WebGLRenderTarget.prototype[i] } catch(e) {};
        scope.WebGLRenderTarget = WebGLRenderTarget.bind( scope );
    } else {
        scope.WebGLRenderTarget = WebGLRenderTarget;
    }
    internal['constructor'] = WebGLRenderTarget;
    scope.WebGLRenderTarget.prototype = WebGLRenderTarget.prototype;
    for ( var i in t ) scope.WebGLRenderTarget[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.WebGLRenderTarget.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__WebGLRenderTarget ) {
        for ( var i = 0, il = scope.__WebGLRenderTarget.length; i < il; i ++ ) scope.__WebGLRenderTarget[ i ]( WebGLRenderTarget );
        delete scope.__WebGLRenderTarget;
    }

}) ( NWE.gfx );


// src/graphics/renderers/renderables/RenderableVertex.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Vec4 = NWE.Vec4;
    if ( !Vec4 ) { NWE.__Vec4 = (NWE.__Vec4 || []); NWE.__Vec4.push( function ( obj ) { Vec4 = obj; } ); }


    var RenderableVertex = function () {

        this.positionWorld = new Vec3();
        this.positionScreen = new Vec4();

        this.visible = true;

    };

    RenderableVertex.prototype.copy = function ( vertex ) {

        this.positionWorld.copy( vertex.positionWorld );
        this.positionScreen.copy( vertex.positionScreen );

    };

    if ( typeof RenderableVertex === 'function' ) {
        var t = {}, p = {};
        for ( var i in RenderableVertex ) t[i] = RenderableVertex[i];
        for ( var i in RenderableVertex.prototype ) try { p[i] = RenderableVertex.prototype[i] } catch(e) {};
        scope.RenderableVertex = RenderableVertex.bind( scope );
    } else {
        scope.RenderableVertex = RenderableVertex;
    }
    scope.RenderableVertex.prototype = RenderableVertex.prototype;
    for ( var i in t ) scope.RenderableVertex[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.RenderableVertex.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__RenderableVertex ) {
        for ( var i = 0, il = scope.__RenderableVertex.length; i < il; i ++ ) scope.__RenderableVertex[ i ]( RenderableVertex );
        delete scope.__RenderableVertex;
    }

}) ( NWE.gfx );


// src/graphics/renderers/renderables/RenderableFace.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var RenderableVertex = NWE.gfx.RenderableVertex;
    if ( !RenderableVertex ) { NWE.gfx.__RenderableVertex = (NWE.gfx.__RenderableVertex || []); NWE.gfx.__RenderableVertex.push( function ( obj ) { RenderableVertex = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Vec4 = NWE.Vec4;
    if ( !Vec4 ) { NWE.__Vec4 = (NWE.__Vec4 || []); NWE.__Vec4.push( function ( obj ) { Vec4 = obj; } ); }


    var RenderableFace = function () {

        this.id = 0;

        this.v1 = new RenderableVertex();
        this.v2 = new RenderableVertex();
        this.v3 = new RenderableVertex();

        this.centroidModel = new Vec3();

        this.normalModel = new Vec3();
        this.normalModelView = new Vec3();

        this.vertexNormalsLength = 0;
        this.vertexNormalsModel = [ new Vec3(), new Vec3(), new Vec3() ];
        this.vertexNormalsModelView = [ new Vec3(), new Vec3(), new Vec3() ];

        this.color = null;
        this.material = null;
        this.uvs = [[]];

        this.z = 0;

    };

    if ( typeof RenderableFace === 'function' ) {
        var t = {}, p = {};
        for ( var i in RenderableFace ) t[i] = RenderableFace[i];
        for ( var i in RenderableFace.prototype ) try { p[i] = RenderableFace.prototype[i] } catch(e) {};
        scope.RenderableFace = RenderableFace.bind( scope );
    } else {
        scope.RenderableFace = RenderableFace;
    }
    scope.RenderableFace.prototype = RenderableFace.prototype;
    for ( var i in t ) scope.RenderableFace[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.RenderableFace.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__RenderableFace ) {
        for ( var i = 0, il = scope.__RenderableFace.length; i < il; i ++ ) scope.__RenderableFace[ i ]( RenderableFace );
        delete scope.__RenderableFace;
    }

}) ( NWE.gfx );


// src/graphics/renderers/renderables/RenderableObject.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var RenderableObject = function () {

        this.id = 0;

        this.object = null;
        this.z = 0;

    };

    if ( typeof RenderableObject === 'function' ) {
        var t = {}, p = {};
        for ( var i in RenderableObject ) t[i] = RenderableObject[i];
        for ( var i in RenderableObject.prototype ) try { p[i] = RenderableObject.prototype[i] } catch(e) {};
        scope.RenderableObject = RenderableObject.bind( scope );
    } else {
        scope.RenderableObject = RenderableObject;
    }
    scope.RenderableObject.prototype = RenderableObject.prototype;
    for ( var i in t ) scope.RenderableObject[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.RenderableObject.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__RenderableObject ) {
        for ( var i = 0, il = scope.__RenderableObject.length; i < il; i ++ ) scope.__RenderableObject[ i ]( RenderableObject );
        delete scope.__RenderableObject;
    }

}) ( NWE.gfx );


// src/graphics/renderers/plugins/SpritePlugin.js

( function ( scope ) {

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ohmed
     */

    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }

    var ShaderLib = NWE.gfx.ShaderLib;
    if ( !ShaderLib ) { NWE.gfx.__ShaderLib = (NWE.gfx.__ShaderLib || []); NWE.gfx.__ShaderLib.push( function ( obj ) { ShaderLib = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var SpritePlugin = function () {

        var _gl, _renderer, _texture;

        var vertices, faces, vertexBuffer, elementBuffer;
        var program, attributes, uniforms;

        var STATE = 'none';

        this.prepare = function ( renderer ) {

            _gl = renderer.getContext();
            _renderer = renderer;

            STATE = 'prepared';

        };

        this.render = function ( scene, camera, viewportWidth, viewportHeight, objects, sprites ) {

            if ( STATE === 'prepared' ) init( scene );
            if ( STATE !== 'inited' ) return;

            var nSprites = sprites.length;

            if ( ! nSprites ) return;

            // setup gl

            _gl.useProgram( program );

            _gl.enableVertexAttribArray( attributes.position );
            _gl.enableVertexAttribArray( attributes.uv );

            _gl.disable( _gl.CULL_FACE );
            _gl.enable( _gl.BLEND );

            _gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
            _gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );
            _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

            _gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

            _gl.activeTexture( _gl.TEXTURE0 );
            _gl.uniform1i( uniforms.map, 0 );

            var fog = scene.fog;

            if ( fog ) {

                _gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

                if ( fog.instanceof === 'Fog' ) {

                    _gl.uniform1f( uniforms.fogNear, fog.near );
                    _gl.uniform1f( uniforms.fogFar, fog.far );

                } else if ( fog.instanceof === 'FogExp2' ) {

                    _gl.uniform1f( uniforms.fogDensity, fog.density );

                }

            }

            // update positions and sort

            var sprite, material, scale = [];

            for ( var i = 0; i < nSprites; i ++ ) {

                sprite = sprites[ i ];
                material = sprite.material;

                sprite.position.set( sprite.relativePosition.x, sprite.relativePosition.y, sprite.relativePosition.z );
                sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );

                if ( sprite.visible === false || ( sprite.parent && sprite.parent.visible === false ) ) continue;
                sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

            }

            sprites.sort( painterSortStable );

            // render all sprites

            for ( var i = 0; i < nSprites; i ++ ) {

                sprite = sprites[ i ];

                if ( sprite.visible === false || ( sprite.parent && sprite.parent.visible === false ) ) continue;

                material = sprite.material;

                _gl.uniform1f( uniforms.alphaTest, material.alphaTest );
                _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

                scale[ 0 ] = sprite.scale.x;
                scale[ 1 ] = sprite.scale.y;

                _gl.uniform3f( uniforms.offset, sprite.offset.x, sprite.offset.y, sprite.offset.z );
                _gl.uniform2f( uniforms.uvScale, material.uvScale.x, material.uvScale.y );
                _gl.uniform2f( uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y );

                _gl.uniform1f( uniforms.opacity, material.opacity );
                _gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

                _gl.uniform1f( uniforms.rotation, material.rotation );
                _gl.uniform2fv( uniforms.scale, scale );

                _renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
                _renderer.setDepthTest( material.depthTest );
                _renderer.setDepthWrite( material.depthWrite );

                if ( material.map && material.map.image && material.map.image.width ) {

                    _renderer.setTexture( material.map, 0 );

                } else {

                    _renderer.setTexture( _texture, 0 );

                }

                _gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

            }

            // restore gl

            _gl.enable( _gl.CULL_FACE );

        };

        function init ( scene ) {

            STATE = 'initing';

            vertices = new Float32Array( [
                - 0.5, - 0.5, 0, 0, 
                  0.5, - 0.5, 1, 0,
                  0.5,   0.5, 1, 1,
                - 0.5,   0.5, 0, 1
            ] );

            faces = new Uint16Array( [
                0, 1, 2,
                0, 2, 3
            ] );

            vertexBuffer  = _gl.createBuffer();
            elementBuffer = _gl.createBuffer();

            _gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
            _gl.bufferData( _gl.ARRAY_BUFFER, vertices, _gl.STATIC_DRAW );

            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
            _gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faces, _gl.STATIC_DRAW );

            program = createProgram( scene );

            attributes = {
                position:           _gl.getAttribLocation ( program, 'position' ),
                uv:                 _gl.getAttribLocation ( program, 'uv' )
            };

            uniforms = {


                uvOffset:           _gl.getUniformLocation( program, 'uvOffset' ),
                uvScale:            _gl.getUniformLocation( program, 'uvScale' ),

                offset:             _gl.getUniformLocation( program, 'offset' ),
                rotation:           _gl.getUniformLocation( program, 'rotation' ),
                scale:              _gl.getUniformLocation( program, 'scale' ),

                color:              _gl.getUniformLocation( program, 'color' ),
                map:                _gl.getUniformLocation( program, 'map' ),
                opacity:            _gl.getUniformLocation( program, 'opacity' ),

                modelViewMatrix:    _gl.getUniformLocation( program, 'modelViewMatrix' ),
                projectionMatrix:   _gl.getUniformLocation( program, 'projectionMatrix' ),

                fogDensity:         _gl.getUniformLocation( program, 'fogDensity' ),
                fogNear:            _gl.getUniformLocation( program, 'fogNear' ),
                fogFar:             _gl.getUniformLocation( program, 'fogFar' ),
                fogColor:           _gl.getUniformLocation( program, 'fogColor' ),

                alphaTest:          _gl.getUniformLocation( program, 'alphaTest' )
            };

            var canvas = document.createElement( 'canvas' );
            canvas.width = 8;
            canvas.height = 8;

            var context = canvas.getContext( '2d' );
            context.fillStyle = '#ffffff';
            context.fillRect( 0, 0, canvas.width, canvas.height );

            _texture = new Texture( canvas );
            _texture.needsUpdate = true;

            STATE = 'inited';

        };

        function createProgram ( scene ) {

            var program = _gl.createProgram();

            var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );
            var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );

            var string;
            var shader = new ShaderLib['Sprite']();

            var vertexShaderSource = [

                'precision ' + _renderer.device.getPrecision() + ' float;',

                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform float rotation;',
                'uniform vec2 scale;',
                'uniform vec2 uvOffset;',
                'uniform vec2 uvScale;',
                'uniform vec3 offset;',

                'attribute vec2 position;',
                'attribute vec2 uv;',

                'varying vec2 vUv;',

                shader.vertexShader.main

            ].join( '\n' );

            var fragmentShaderSource = [

                'precision ' + _renderer.device.getPrecision() + ' float;',

                ( scene.fog && scene.fog.instanceof === 'Fog' ) ? '#define USE_FOG' : '',
                ( scene.fog && scene.fog.instanceof === 'FogExp2' ) ? '#define FOG_EXP2' : '',

                'uniform vec3 color;',
                'uniform sampler2D map;',
                'uniform float opacity;',

                'uniform vec3 fogColor;',
                'uniform float fogDensity;',
                'uniform float fogNear;',
                'uniform float fogFar;',
                'uniform float alphaTest;',

                'varying vec2 vUv;',

                shader.fragmentShader.main

            ].join( '\n' );

            _gl.shaderSource( vertexShader, vertexShaderSource );
            _gl.compileShader( vertexShader );

            if ( ! _gl.getShaderParameter( vertexShader, _gl.COMPILE_STATUS ) ) {

                Logger.error( _gl.getShaderInfoLog( vertexShader ) );
                Logger.error( addLineNumbers( vertexShaderSource ) );
                return null;

            }

            _gl.shaderSource( fragmentShader, fragmentShaderSource );
            _gl.compileShader( fragmentShader );

            if ( ! _gl.getShaderParameter( fragmentShader, _gl.COMPILE_STATUS ) ) {

                Logger.error( _gl.getShaderInfoLog( fragmentShader ) );
                Logger.error( addLineNumbers( fragmentShaderSource ) );
                return null;

            }

            _gl.attachShader( program, vertexShader );
            _gl.attachShader( program, fragmentShader );

            _gl.linkProgram( program );

            if ( ! _gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {

                Logger.error( 'Could not initialise shader' );
                Logger.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
                Logger.error( 'gl.getError()', _gl.getError() );

            }

            if ( _gl.getProgramInfoLog( program ) !== '' ) {

                Logger.error( 'gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );

            }

            // clean up

            _gl.deleteShader( fragmentShader );
            _gl.deleteShader( vertexShader );

            return program;

        };

        function painterSortStable ( a, b ) {

            if ( a.z !== b.z ) {

                return b.z - a.z;

            } else {

                return b.id - a.id;

            }

        };

    };

    var addLineNumbers = function ( string ) {

        var chunks = string.split( '\n' );

        for ( var i = 0, il = chunks.length; i < il; i ++ ) {

            // Chrome reports shader errors on lines
            // starting counting from 1

            chunks[ i ] = ( i + 1 ) + ': ' + chunks[ i ];

        }

        return chunks.join( '\n' );

    };

    if ( typeof SpritePlugin === 'function' ) {
        var t = {}, p = {};
        for ( var i in SpritePlugin ) t[i] = SpritePlugin[i];
        for ( var i in SpritePlugin.prototype ) try { p[i] = SpritePlugin.prototype[i] } catch(e) {};
        scope.SpritePlugin = SpritePlugin.bind( scope );
    } else {
        scope.SpritePlugin = SpritePlugin;
    }
    scope.SpritePlugin.prototype = SpritePlugin.prototype;
    for ( var i in t ) scope.SpritePlugin[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.SpritePlugin.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__SpritePlugin ) {
        for ( var i = 0, il = scope.__SpritePlugin.length; i < il; i ++ ) scope.__SpritePlugin[ i ]( SpritePlugin );
        delete scope.__SpritePlugin;
    }

}) ( NWE.gfx );


// src/graphics/renderers/plugins/ShadowMapPlugin.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var WebGLRenderTarget = NWE.gfx.WebGLRenderTarget;
    if ( !WebGLRenderTarget ) { NWE.gfx.__WebGLRenderTarget = (NWE.gfx.__WebGLRenderTarget || []); NWE.gfx.__WebGLRenderTarget.push( function ( obj ) { WebGLRenderTarget = obj; } ); }

    var Projector = NWE.gfx.Projector;
    if ( !Projector ) { NWE.gfx.__Projector = (NWE.gfx.__Projector || []); NWE.gfx.__Projector.push( function ( obj ) { Projector = obj; } ); }

    var Frustum = NWE.Frustum;
    if ( !Frustum ) { NWE.__Frustum = (NWE.__Frustum || []); NWE.__Frustum.push( function ( obj ) { Frustum = obj; } ); }

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var OrthographicCamera = NWE.gfx.OrthographicCamera;
    if ( !OrthographicCamera ) { NWE.gfx.__OrthographicCamera = (NWE.gfx.__OrthographicCamera || []); NWE.gfx.__OrthographicCamera.push( function ( obj ) { OrthographicCamera = obj; } ); }

    var PerspectiveCamera = NWE.gfx.PerspectiveCamera;
    if ( !PerspectiveCamera ) { NWE.gfx.__PerspectiveCamera = (NWE.gfx.__PerspectiveCamera || []); NWE.gfx.__PerspectiveCamera.push( function ( obj ) { PerspectiveCamera = obj; } ); }

    var DepthRGBA = NWE.gfx.ShaderLib.DepthRGBA;
    if ( !DepthRGBA ) { NWE.gfx.ShaderLib.__DepthRGBA = (NWE.gfx.ShaderLib.__DepthRGBA || []); NWE.gfx.ShaderLib.__DepthRGBA.push( function ( obj ) { DepthRGBA = obj; } ); }

    var ShaderMaterial = NWE.gfx.ShaderMaterial;
    if ( !ShaderMaterial ) { NWE.gfx.__ShaderMaterial = (NWE.gfx.__ShaderMaterial || []); NWE.gfx.__ShaderMaterial.push( function ( obj ) { ShaderMaterial = obj; } ); }

    var DepthPassPlugin = NWE.gfx.DepthPassPlugin;
    if ( !DepthPassPlugin ) { NWE.gfx.__DepthPassPlugin = (NWE.gfx.__DepthPassPlugin || []); NWE.gfx.__DepthPassPlugin.push( function ( obj ) { DepthPassPlugin = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var ShadowMapPlugin = function () {

        var _gl;
        var _renderer;

        var _frustum = new Frustum();
        var _projScreenMatrix = new Matrix4();

        var _min = Vec3();
        var _max = Vec3();

        var _matrixPosition = new Vec3();

        var STATE = 'none';

        this.prepare = function ( renderer ) {

            _gl = renderer.getContext();
            _renderer = renderer;

            STATE = 'prepared';

        };

        this.render = function ( scene, camera ) {

            if ( STATE === 'prepared' ) init( scene );
            if ( STATE !== 'inited' ) return;

            if ( ! _renderer.shadowMapEnabled || ! _renderer.shadowMapAutouUpdate ) {

                return;

            }

            this.update( scene, camera );

        };

        this.update = function ( scene, camera ) {

            var lights = _renderer.getLights();
            var light;

            var shadowMap, shadowMatrix, shadowCamera;

            for ( var i = 0, il = lights.length; i < il; i ++ ) {

                light = lights[ i ];

                if ( ! light.castShadow ) {

                    continue;

                }

                if ( ! light.shadowCamera ) {

                    if ( ! setupShadowCamera( scene, light ) ) continue;

                }

                if ( ! light.shadowMap ) {

                    setupShadowMap( light );

                }

                shadowMap = light.shadowMap;
                shadowMatrix = light.shadowMatrix;
                shadowCamera = light.shadowCamera;

                shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
                _matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
                shadowCamera.lookAt( _matrixPosition );
                shadowCamera.updateMatrixWorld();

                shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

                // compute shadow matrix

                shadowMatrix.set( 0.5, 0.0, 0.0, 0.5,
                                  0.0, 0.5, 0.0, 0.5,
                                  0.0, 0.0, 0.5, 0.5,
                                  0.0, 0.0, 0.0, 1.0 );

                shadowMatrix.multiply( shadowCamera.projectionMatrix );
                shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

                // update camera matrices and frustum

                _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
                _frustum.setFromMatrix( _projScreenMatrix );

            }

        };

        function init ( scene ) {

            STATE = 'initing';

            //

            STATE = 'inited';

        };

        function setupShadowMap ( light ) {

            var depthPlugin = new DepthPassPlugin( null, light.shadowCamera, light.shadowMapWidth, light.shadowMapHeight );
            _renderer.addPrePlugin( depthPlugin );

            light.shadowMap = depthPlugin.renderTarget;
            light.shadowMapSize = new Vec2( light.shadowMapWidth, light.shadowMapHeight );

            light.shadowMatrix = new Matrix4();

        };

        function setupShadowCamera ( scene, light ) {

            if ( light.instanceof === 'SpotLight' ) {

                light.shadowCamera = new PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

            } else if ( light.instanceof === 'DirectionalLight' ) {

                light.shadowCamera = new OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

            } else {

                Logger.error( 'NWE.gfx.ShadowMapPlugin.setupShadowCamera(): Unsupported light type for shadow.' );
                return false;

            }

            scene.add( light.shadowCamera );

            if ( scene.autoUpdate === true ) {

                scene.updateMatrixWorld();

            }

            return true;

        };

    };

    ShadowMapPlugin.__projector = new Projector();

    if ( typeof ShadowMapPlugin === 'function' ) {
        var t = {}, p = {};
        for ( var i in ShadowMapPlugin ) t[i] = ShadowMapPlugin[i];
        for ( var i in ShadowMapPlugin.prototype ) try { p[i] = ShadowMapPlugin.prototype[i] } catch(e) {};
        scope.ShadowMapPlugin = ShadowMapPlugin.bind( scope );
    } else {
        scope.ShadowMapPlugin = ShadowMapPlugin;
    }
    scope.ShadowMapPlugin.prototype = ShadowMapPlugin.prototype;
    for ( var i in t ) scope.ShadowMapPlugin[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.ShadowMapPlugin.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__ShadowMapPlugin ) {
        for ( var i = 0, il = scope.__ShadowMapPlugin.length; i < il; i ++ ) scope.__ShadowMapPlugin[ i ]( ShadowMapPlugin );
        delete scope.__ShadowMapPlugin;
    }

}) ( NWE.gfx );


// src/graphics/renderers/plugins/DepthPassPlugin.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }

    var ShaderLib = NWE.gfx.ShaderLib;
    if ( !ShaderLib ) { NWE.gfx.__ShaderLib = (NWE.gfx.__ShaderLib || []); NWE.gfx.__ShaderLib.push( function ( obj ) { ShaderLib = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var Frustum = NWE.Frustum;
    if ( !Frustum ) { NWE.__Frustum = (NWE.__Frustum || []); NWE.__Frustum.push( function ( obj ) { Frustum = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var DepthRGBA = NWE.gfx.ShaderLib.DepthRGBA;
    if ( !DepthRGBA ) { NWE.gfx.ShaderLib.__DepthRGBA = (NWE.gfx.ShaderLib.__DepthRGBA || []); NWE.gfx.ShaderLib.__DepthRGBA.push( function ( obj ) { DepthRGBA = obj; } ); }

    var ShaderMaterial = NWE.gfx.ShaderMaterial;
    if ( !ShaderMaterial ) { NWE.gfx.__ShaderMaterial = (NWE.gfx.__ShaderMaterial || []); NWE.gfx.__ShaderMaterial.push( function ( obj ) { ShaderMaterial = obj; } ); }

    var WebGLRenderTarget = NWE.gfx.WebGLRenderTarget;
    if ( !WebGLRenderTarget ) { NWE.gfx.__WebGLRenderTarget = (NWE.gfx.__WebGLRenderTarget || []); NWE.gfx.__WebGLRenderTarget.push( function ( obj ) { WebGLRenderTarget = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var DepthPassPlugin = function ( renderTarget, camera, width, height ) {

        this.enabled = true;

        var _camera = camera || null;

        var _gl;
        var _renderer;

        var _frustum = new Frustum();
        var _projScreenMatrix = new Matrix4();

        var _renderList = [];

        var _webglObjects;
        var _depthMaterial;

        var STATE = 'none';

        this.prepare = function ( renderer ) {

            _gl = renderer.getContext();
            _renderer = renderer;

            //

            if ( ! renderTarget ) {

                width = width || renderer.viewport.width;
                height = height || renderer.viewport.height;

                var renderTargetParametersRGBA = { minFilter: Const.LinearFilter, magFilter: Const.LinearFilter, format: Const.RGBAFormat };
                this.renderTarget = new WebGLRenderTarget( width, height, renderTargetParametersRGBA );

            } else {

                this.renderTarget = renderTarget;

            }

            //

            STATE = 'prepared';

        };

        this.render = function ( scene, camera ) {

            if ( STATE === 'prepared' ) init();
            if ( STATE !== 'inited' ) return;

            if ( ! this.enabled ) return;

            if ( _camera ) camera = _camera;

            this.update( camera );

        };

        this.update = function ( camera ) {

            var webGLObjects = _renderer.getWebGLObjects();
            var webGLObject;

            var i, il, n;

            var program, buffer, material;
            var object;
            var renderList;

            var fog = null;

            // set GL state for depth map

            _gl.clearColor( 1, 1, 1, 1 );
            _gl.disable( _gl.BLEND );

            _renderer.setDepthTest( true );

            // update camera matrices and frustum

            camera.matrixWorldInverse.getInverse( camera.matrixWorld );

            _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
            _frustum.setFromMatrix( _projScreenMatrix );

            // render depth map

            _renderer.setRenderTarget( this.renderTarget );
            _renderer.clear();

            // set object matrices & frustum culling

            _renderList.length = 0;
            projectObject( camera, webGLObjects );

            // render regular objects

            for ( var i = 0, il = _renderList.length; i < il; i ++ ) {

                object = _renderList[ i ];

                // todo: create proper depth material for particles

                if ( object.instanceof === 'PointCloud' && ! object.customDepthMaterial ) continue;

                if ( object.customDepthMaterial ) {

                    material = object.customDepthMaterial;

                } else {

                    material = _depthMaterial;

                }

                if ( object.geometry.instanceof === 'DirrectBuffers' ) {

                    _renderer.renderBufferDirect( camera, fog, material, object.geometry, object );

                }

            }

            // restore GL state

            var clearColor = _renderer.getClearColor();
            var clearAlpha = _renderer.getClearAlpha();

            _gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
            _gl.enable( _gl.BLEND );

        };

        function init () {

            STATE = 'initing';

            var shader = new DepthRGBA();

            _depthMaterial = new ShaderMaterial( {
                defines: shader.defines,
                uniforms: shader.uniforms,
                attributes: shader.attributes,
                varyings: shader.varyings,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            } );

            //

            var canvas = document.createElement( 'canvas' );
            canvas.width = 2;
            canvas.height = 2;

            var context = canvas.getContext( '2d' );

            context.fillStyle = 'rgba(255, 255, 255, 1.0)';
            context.fillRect( 0, 0, canvas.width, canvas.height );

            _depthMaterial.uniforms.objectTexture.value = new Texture( canvas );

            //

            STATE = 'inited';

        };

        function projectObject ( camera, webGLObjects ) {

            var object;

            for ( var i = 0, l = webGLObjects.length; i < l; i ++ ) {

                object = webGLObjects[ i ];

                if ( object.visible === false || object.castShadow === false || ( object.frustumCulled === true && _frustum.intersectsObject( object ) === false ) ) {

                    continue;

                }

                object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
                _renderList.push( object );

            }

        };

    };

    if ( typeof DepthPassPlugin === 'function' ) {
        var t = {}, p = {};
        for ( var i in DepthPassPlugin ) t[i] = DepthPassPlugin[i];
        for ( var i in DepthPassPlugin.prototype ) try { p[i] = DepthPassPlugin.prototype[i] } catch(e) {};
        scope.DepthPassPlugin = DepthPassPlugin.bind( scope );
    } else {
        scope.DepthPassPlugin = DepthPassPlugin;
    }
    scope.DepthPassPlugin.prototype = DepthPassPlugin.prototype;
    for ( var i in t ) scope.DepthPassPlugin[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DepthPassPlugin.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DepthPassPlugin ) {
        for ( var i = 0, il = scope.__DepthPassPlugin.length; i < il; i ++ ) scope.__DepthPassPlugin[ i ]( DepthPassPlugin );
        delete scope.__DepthPassPlugin;
    }

}) ( NWE.gfx );


// src/graphics/extras/Compability.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    // requestAnimation fix

    var lastTime = 0;
    var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

    for ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++ x ) {

        window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
        window.cancelAnimationFrame = window[ vendors[ x ] + 'CancelAnimationFrame' ] || window[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

    }

    if ( window.requestAnimationFrame === undefined && window[ 'setTimeout' ] !== undefined ) {

        window.requestAnimationFrame = function ( callback ) {

            var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
            var id = window.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );
            lastTime = currTime + timeToCall;
            return id;

        };

    }

    if ( window.cancelAnimationFrame === undefined && window[ 'clearTimeout' ] !== undefined ) {

        window.cancelAnimationFrame = function ( id ) {

            window.clearTimeout( id )

        };

    }

}) ( window );


// src/graphics/extras/ImageUtils.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */



    var ImageLoader = NWE.ImageLoader;
    if ( !ImageLoader ) { NWE.__ImageLoader = (NWE.__ImageLoader || []); NWE.__ImageLoader.push( function ( obj ) { ImageLoader = obj; } ); }

    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }

    var CompressedTexture = NWE.gfx.CompressedTexture;
    if ( !CompressedTexture ) { NWE.gfx.__CompressedTexture = (NWE.gfx.__CompressedTexture || []); NWE.gfx.__CompressedTexture.push( function ( obj ) { CompressedTexture = obj; } ); }

    var DataTexture = NWE.gfx.DataTexture;
    if ( !DataTexture ) { NWE.gfx.__DataTexture = (NWE.gfx.__DataTexture || []); NWE.gfx.__DataTexture.push( function ( obj ) { DataTexture = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var ImageUtils = {

        crossOrigin: 'anonymous',

        loadTextureCube: function ( array, mapping, onLoad, onError ) {

            var images = [];
            images.loadCount = 0;

            var texture = new Texture();
            texture.image = images;
            if ( mapping !== undefined ) texture.mapping = mapping;

            // no flipping needed for cube textures

            texture.flipY = false;

            for ( var i = 0, il = array.length; i < il; ++ i ) {

                var cubeImage = new Image();
                images[ i ] = cubeImage;

                cubeImage.onload = function () {

                    images.loadCount += 1;

                    if ( images.loadCount === 6 ) {

                        texture.needsUpdate = true;
                        if ( onLoad ) onLoad( texture );

                    }

                };

                cubeImage.onerror = onError;

                cubeImage.crossOrigin = this.crossOrigin;
                cubeImage.src = array[ i ];

            }

            return texture;

        },

        loadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {

            var images = [];
            images.loadCount = 0;

            var texture = new CompressedTexture();
            texture.image = images;
            if ( mapping !== undefined ) texture.mapping = mapping;

            // no flipping for cube textures
            // (also flipping doesn't work for compressed textures )

            texture.flipY = false;

            // can't generate mipmaps for compressed textures
            // mips must be embedded in DDS files

            texture.generateMipmaps = false;

            var generateCubeFaceCallback = function ( rq, img ) {

                return function () {

                    var buffer = rq.response;
                    var dds = ImageUtils.parseDDS( buffer, true );

                    img.format = dds.format;

                    img.mipmaps = dds.mipmaps;
                    img.width = dds.width;
                    img.height = dds.height;

                    images.loadCount += 1;

                    if ( images.loadCount === 6 ) {

                        texture.format = dds.format;
                        texture.needsUpdate = true;
                        if ( onLoad ) onLoad( texture );

                    }

                }

            }

            // compressed cubemap textures as 6 separate DDS files

            if ( array instanceof Array ) {

                for ( var i = 0, il = array.length; i < il; ++ i ) {

                    var cubeImage = {};
                    images[ i ] = cubeImage;

                    var request = new XMLHttpRequest();

                    request.onload = generateCubeFaceCallback( request, cubeImage );
                    request.onerror = onError;

                    var url = array[ i ];

                    request.open( 'GET', url, true );
                    request.responseType = "arraybuffer";
                    request.send( null );

                }

            // compressed cubemap texture stored in a single DDS file

            } else {

                var url = array;
                var request = new XMLHttpRequest();

                request.onload = function( ) {

                    var buffer = request.response;
                    var dds = ImageUtils.parseDDS( buffer, true );

                    if ( dds.isCubemap ) {

                        var faces = dds.mipmaps.length / dds.mipmapCount;

                        for ( var f = 0; f < faces; f ++ ) {

                            images[ f ] = { mipmaps : [] };

                            for ( var i = 0; i < dds.mipmapCount; i ++ ) {

                                images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
                                images[ f ].format = dds.format;
                                images[ f ].width = dds.width;
                                images[ f ].height = dds.height;

                            }

                        }

                        texture.format = dds.format;
                        texture.needsUpdate = true;
                        if ( onLoad ) onLoad( texture );

                    }

                }

                request.onerror = onError;

                request.open( 'GET', url, true );
                request.responseType = "arraybuffer";
                request.send( null );

            }

            return texture;

        },

        getNormalMap: function ( image, depth ) {

            // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

            var cross = function ( a, b ) {

                return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

            }

            var subtract = function ( a, b ) {

                return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

            }

            var normalize = function ( a ) {

                var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
                return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

            }

            depth = depth | 1;

            var width = image.width;
            var height = image.height;

            var canvas = document.createElement( 'canvas' );
            canvas.width = width;
            canvas.height = height;

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0 );

            var data = context.getImageData( 0, 0, width, height ).data;
            var imageData = context.createImageData( width, height );
            var output = imageData.data;

            for ( var x = 0; x < width; x ++ ) {

                for ( var y = 0; y < height; y ++ ) {

                    var ly = y - 1 < 0 ? 0 : y - 1;
                    var uy = y + 1 > height - 1 ? height - 1 : y + 1;
                    var lx = x - 1 < 0 ? 0 : x - 1;
                    var ux = x + 1 > width - 1 ? width - 1 : x + 1;

                    var points = [];
                    var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
                    points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
                    points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
                    points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
                    points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
                    points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
                    points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
                    points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
                    points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

                    var normals = [];
                    var num_points = points.length;

                    for ( var i = 0; i < num_points; i ++ ) {

                        var v1 = points[ i ];
                        var v2 = points[ ( i + 1 ) % num_points ];
                        v1 = subtract( v1, origin );
                        v2 = subtract( v2, origin );
                        normals.push( normalize( cross( v1, v2 ) ) );

                    }

                    var normal = [ 0, 0, 0 ];

                    for ( var i = 0; i < normals.length; i ++ ) {

                        normal[ 0 ] += normals[ i ][ 0 ];
                        normal[ 1 ] += normals[ i ][ 1 ];
                        normal[ 2 ] += normals[ i ][ 2 ];

                    }

                    normal[ 0 ] /= normals.length;
                    normal[ 1 ] /= normals.length;
                    normal[ 2 ] /= normals.length;

                    var idx = ( y * width + x ) * 4;

                    output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
                    output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
                    output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
                    output[ idx + 3 ] = 255;

                }

            }

            context.putImageData( imageData, 0, 0 );

            return canvas;

        },

        generateTextureAtlas: function ( texturesID, atlasSize, density, getTextureImage ) {

            var atlasCanvas = document.createElement('canvas'),
                ctx,

                atlasTexute = null,
                step = atlasSize / density;

            // prepare textureIDs obj

            for ( var i = 0, il = texturesID.list.length; i < il; i ++ ) {

              if ( texturesID.list[ i ] === '' ) texturesID.list[ i ] = 'ZeroMask' + i;

              texturesID[ texturesID.list[ i ] ] = i;

            }

            delete texturesID.list;

            //

            atlasCanvas.width = atlasCanvas.height = atlasSize;
            ctx = atlasCanvas.getContext('2d');

            //

            var i = 0,
                row, cell,
                textureName, texture, image;

            for ( textureName in texturesID ) {

                row = ( density - 1 ) - Math.floor( i / density );
                cell = i % density;

                i ++;

                image = getTextureImage( textureName );
                
                if ( !image ) {

                    ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                    ctx.fillRect( step * cell, step * row, step, step );
                    continue;

                }
                
                texture = new Texture( image );

                ctx.drawImage( texture.image, step * cell, step * row, step, step );

            }

            atlasTexute = new Texture( atlasCanvas );
            atlasTexute.needsUpdate = true;

            if ( atlasCanvas.remove ) atlasCanvas.remove(); // need to look into it

            return atlasTexute;

        }

    };

    scope.ImageUtils = ImageUtils;
    if ( scope.__ImageUtils ) {
        for ( var i = 0, il = scope.__ImageUtils.length; i < il; i ++ ) scope.__ImageUtils[ i ]( ImageUtils );
        delete scope.__ImageUtils;
    }

}) ( NWE.gfx );


// src/graphics/extras/geometries/CubeGeometry.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var BufferGeometry = NWE.gfx.BufferGeometry;
    if ( !BufferGeometry ) { NWE.gfx.__BufferGeometry = (NWE.gfx.__BufferGeometry || []); NWE.gfx.__BufferGeometry.push( function ( obj ) { BufferGeometry = obj; } ); }


    var CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments, objInternal ) {

        widthSegments = widthSegments || 1;
        heightSegments = heightSegments || 1;
        depthSegments = depthSegments || 1;

        var totalTriangles = 2 * ( 2 * widthSegments * heightSegments + 2 * heightSegments * depthSegments + 2 * widthSegments * depthSegments );
        var totalVertices = 2 * ( widthSegments + 1 ) * ( heightSegments + 1 ) + 2 * ( heightSegments + 1 ) * ( depthSegments + 1 ) + 2 * ( widthSegments + 1 ) * ( depthSegments + 1 );

        objInternal = objInternal || {};
        BufferGeometry.getInternal('constructor').call( this, { name: 'Cube', vertCount: totalVertices, trisCount: totalTriangles }, objInternal );
        internal[ this.uuid ] = objInternal;

        var self = this;

        var index = this.addAttribute( 'index', 3 * totalTriangles ).array;
        var positions = this.addAttribute( 'position', 3 ).array;
        var uvs = this.addAttribute( 'uv', 2 ).array;

        this.width = width;
        this.height = height;
        this.depth = depth;

        this.widthSegments = widthSegments;
        this.heightSegments = heightSegments;
        this.depthSegments = depthSegments;

        var width_half = this.width / 2;
        var height_half = this.height / 2;
        var depth_half = this.depth / 2;

        var k = 0;
        var ind = 0;

        buildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px
        buildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx
        buildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py
        buildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny
        buildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz
        buildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz

        this.computeChunkOffsets();

        function buildPlane ( u, v, udir, vdir, width, height, depth, materialIndex ) {

            var w, ix, iy,
                gridX = self.widthSegments,
                gridY = self.heightSegments,
                width_half = width / 2,
                height_half = height / 2;

            if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

                w = 'z';

            } else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

                w = 'y';
                gridY = self.depthSegments;

            } else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

                w = 'x';
                gridX = self.depthSegments;

            }

            var gridX1 = gridX + 1,
                gridY1 = gridY + 1,
                segment_width = width / gridX,
                segment_height = height / gridY,
                normal = new Vec3(),
                vector = new Vec3();

            normal[ w ] = depth > 0 ? 1 : - 1;

            var chunkSize = ( index instanceof Uint32Array ) ? Number.MAX_VALUE : 65536;
            var a, b, c;
            var row, N;

            for ( i = 0, il = 6 * ( gridY1 - 1 ) * ( gridX1 - 1 ); i < il; i += 6 ) {

                N = i / 6;

                row = Math.floor( N / gridX );

                a = N % gridY + row * ( gridX + 1 );
                b = a + 1;
                c = b + ( gridX + 1 );

                index[ ind + i + 0 ] = k + c % chunkSize;
                index[ ind + i + 1 ] = k + b % chunkSize;
                index[ ind + i + 2 ] = k + a % chunkSize;

                a = N % gridY + 1 + ( 1 + row ) * ( gridX + 1 );
                b = a - 1;
                c = b - ( gridX + 1 );

                index[ ind + i + 3 ] = k + c % chunkSize;
                index[ ind + i + 4 ] = k + b % chunkSize;
                index[ ind + i + 5 ] = k + a % chunkSize;

            }

            ind += 6 * ( gridY1 - 1 ) * ( gridX1 - 1 );

            for ( iy = 0; iy < gridY1; iy ++ ) {

                for ( ix = 0; ix < gridX1; ix ++ ) {

                    vector[ u ] = ( ix * segment_width - width_half ) * udir;
                    vector[ v ] = ( iy * segment_height - height_half ) * vdir;
                    vector[ w ] = depth;

                    positions[ 3 * k + 0 ] = vector.x;
                    positions[ 3 * k + 1 ] = vector.y;
                    positions[ 3 * k + 2 ] = vector.z;

                    uvs[ 2 * k + 0 ] = ix * 1 / gridX;
                    uvs[ 2 * k + 1 ] = iy * 1 / gridY;

                    k ++;

                }

            }

        };

    };

    CubeGeometry.prototype = Object.create( BufferGeometry.prototype );

    CubeGeometry.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    CubeGeometry.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    CubeGeometry.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    CubeGeometry.setInternal = function ( name, value ) { internal[ name ] = value; };
    CubeGeometry.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof CubeGeometry === 'function' ) {
        var t = {}, p = {};
        for ( var i in CubeGeometry ) t[i] = CubeGeometry[i];
        for ( var i in CubeGeometry.prototype ) try { p[i] = CubeGeometry.prototype[i] } catch(e) {};
        scope.CubeGeometry = CubeGeometry.bind( scope );
    } else {
        scope.CubeGeometry = CubeGeometry;
    }
    internal['constructor'] = CubeGeometry;
    scope.CubeGeometry.prototype = CubeGeometry.prototype;
    for ( var i in t ) scope.CubeGeometry[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.CubeGeometry.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__CubeGeometry ) {
        for ( var i = 0, il = scope.__CubeGeometry.length; i < il; i ++ ) scope.__CubeGeometry[ i ]( CubeGeometry );
        delete scope.__CubeGeometry;
    }

}) ( NWE.gfx );


// src/graphics/extras/geometries/PlaneGeometry.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var BufferGeometry = NWE.gfx.BufferGeometry;
    if ( !BufferGeometry ) { NWE.gfx.__BufferGeometry = (NWE.gfx.__BufferGeometry || []); NWE.gfx.__BufferGeometry.push( function ( obj ) { BufferGeometry = obj; } ); }


    var PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

        this.width = width;
        this.height = height;

        this.widthSegments = widthSegments || 1;
        this.heightSegments = heightSegments || 1;

        var totalTriangles = 2 * this.widthSegments * this.heightSegments;
        var totalVertices = ( this.widthSegments + 1 ) * ( this.heightSegments + 1 );
        var params = { name: 'Plane', vertCount: totalVertices, trisCount: totalTriangles };

        objInternal = {};
        BufferGeometry.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        //

        var index = this.addAttribute( 'index', 3 * totalTriangles ).array;
        var positions = this.addAttribute( 'position', 3 ).array;
        var uvs = this.addAttribute( 'uv', 2 ).array;
        var normals = this.addAttribute( 'normal', 3 ).array;

        //

        var i, il, ix, iz;
        var width_half = width / 2;
        var height_half = height / 2;

        var gridX = this.widthSegments;
        var gridZ = this.heightSegments;

        var gridX1 = gridX + 1;
        var gridZ1 = gridZ + 1;

        var segment_width = this.width / gridX;
        var segment_height = this.height / gridZ;

        var k = 0;

        for ( iz = 0; iz < gridZ1; iz ++ ) {

            for ( ix = 0; ix < gridX1; ix ++ ) {

                var x = ix * segment_width - width_half;
                var y = iz * segment_height - height_half;

                positions[ 3 * k + 0 ] = x;
                positions[ 3 * k + 1 ] = - y;
                positions[ 3 * k + 2 ] = 0;

                normals[ 3 * k + 0 ] = 1;
                normals[ 3 * k + 1 ] = 0;
                normals[ 3 * k + 2 ] = 0;

                uvs[ 2 * k + 0 ] = ix * 1 / this.widthSegments;
                uvs[ 2 * k + 1 ] = 1 - iz * 1 / this.heightSegments;

                k ++;

            }

        }

        var chunkSize = ( index instanceof Uint32Array ) ? Number.MAX_VALUE : 65536;
        var a, b, c;
        var row, N;

        for ( i = 0, il = index.length; i < il; i += 6 ) {

            N = i / 6;

            row = Math.floor( N / this.widthSegments );

            a = N % this.heightSegments + row * ( this.widthSegments + 1 );
            b = a + 1;
            c = b + ( this.widthSegments + 1 );

            index[ i + 0 ] = c % chunkSize;
            index[ i + 1 ] = b % chunkSize;
            index[ i + 2 ] = a % chunkSize;

            a = N % this.heightSegments + 1 + ( 1 + row ) * ( this.widthSegments + 1 );
            b = a - 1;
            c = b - ( this.widthSegments + 1 );

            index[ i + 3 ] = c % chunkSize;
            index[ i + 4 ] = b % chunkSize;
            index[ i + 5 ] = a % chunkSize;

        }

        this.computeChunkOffsets();

    };

    PlaneGeometry.prototype = Object.create( BufferGeometry.prototype );

    PlaneGeometry.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    PlaneGeometry.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    PlaneGeometry.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    PlaneGeometry.setInternal = function ( name, value ) { internal[ name ] = value; };
    PlaneGeometry.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof PlaneGeometry === 'function' ) {
        var t = {}, p = {};
        for ( var i in PlaneGeometry ) t[i] = PlaneGeometry[i];
        for ( var i in PlaneGeometry.prototype ) try { p[i] = PlaneGeometry.prototype[i] } catch(e) {};
        scope.PlaneGeometry = PlaneGeometry.bind( scope );
    } else {
        scope.PlaneGeometry = PlaneGeometry;
    }
    internal['constructor'] = PlaneGeometry;
    scope.PlaneGeometry.prototype = PlaneGeometry.prototype;
    for ( var i in t ) scope.PlaneGeometry[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.PlaneGeometry.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__PlaneGeometry ) {
        for ( var i = 0, il = scope.__PlaneGeometry.length; i < il; i ++ ) scope.__PlaneGeometry[ i ]( PlaneGeometry );
        delete scope.__PlaneGeometry;
    }

}) ( NWE.gfx );


// src/graphics/extras/scene/GpuSelector.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var WebGLRenderer = NWE.gfx.WebGLRenderer;
    if ( !WebGLRenderer ) { NWE.gfx.__WebGLRenderer = (NWE.gfx.__WebGLRenderer || []); NWE.gfx.__WebGLRenderer.push( function ( obj ) { WebGLRenderer = obj; } ); }

    var WebGLRenderTarget = NWE.gfx.WebGLRenderTarget;
    if ( !WebGLRenderTarget ) { NWE.gfx.__WebGLRenderTarget = (NWE.gfx.__WebGLRenderTarget || []); NWE.gfx.__WebGLRenderTarget.push( function ( obj ) { WebGLRenderTarget = obj; } ); }

    var Scene = NWE.gfx.Scene;
    if ( !Scene ) { NWE.gfx.__Scene = (NWE.gfx.__Scene || []); NWE.gfx.__Scene.push( function ( obj ) { Scene = obj; } ); }

    var CubeGeometry = NWE.gfx.CubeGeometry;
    if ( !CubeGeometry ) { NWE.gfx.__CubeGeometry = (NWE.gfx.__CubeGeometry || []); NWE.gfx.__CubeGeometry.push( function ( obj ) { CubeGeometry = obj; } ); }

    var Mesh = NWE.gfx.Mesh;
    if ( !Mesh ) { NWE.gfx.__Mesh = (NWE.gfx.__Mesh || []); NWE.gfx.__Mesh.push( function ( obj ) { Mesh = obj; } ); }

    var MeshBasicMaterial = NWE.gfx.MeshBasicMaterial;
    if ( !MeshBasicMaterial ) { NWE.gfx.__MeshBasicMaterial = (NWE.gfx.__MeshBasicMaterial || []); NWE.gfx.__MeshBasicMaterial.push( function ( obj ) { MeshBasicMaterial = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }


    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }


    var GpuSelector = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        this.uuid = Math.generateUUID();
        internal[ this.uuid ] = objInternal;

        this._glContext = false;

        this.objects = [];

        this.mapWidth = params.width || 120,
        this.mapHeight = params.height || 120;

        this.scene = new Scene();

        this.pickingTexture = new WebGLRenderTarget( this.mapWidth, this.mapHeight ); 
        this.pickingTexture.generateMipmaps = false;

        this.pixelBuffer = new Uint8Array( 4 );

        this.renderer = new WebGLRenderer({ antialias: false });
        this.renderer.setClearColor( 0xffffff );
        this.renderer.viewport.setSize( this.mapWidth, this.mapHeight, false );

        //

        this.mesh = null;
        this.material = new NWE.gfx.MeshBasicMaterial({ shading: NWE.gfx.Const.FlatShading, vertexColors: NWE.gfx.Const.VertexColors });
        this.matrix = new Matrix4();

        //

        this.instanceof = 'GpuSelector';

    };

    GpuSelector.prototype.generateGroup = function () {

        this.scene.remove( this.mesh );

        this.mesh = new NWE.gfx.Mesh( NWE.gfx.BufferGeometry.merge( this.objects ), this.material );
        this.scene.add( this.mesh );

    };

    GpuSelector.prototype.addObject = function ( params ) {

        // id, position, rotation, size, staticObject, deferedUpdate

        var matrix = this.matrix;

        if ( params.staticObject ) {

            var geometry = new CubeGeometry( params.size.x, params.size.y, params.size.z );
            geometry.setVertexColor( new Color( this.objects.length ) );

            this.objects.push( geometry );
            geometry.pickId = params.id;

            geometry.applyMatrix( matrix.makeRotationFromEuler( params.rotation ) );
            matrix.identity();

            geometry.applyMatrix( matrix.makeTranslation( params.position ) );
            matrix.identity();

            //

            if ( ! params.deferedUpdate ) {

                this.generateGroup();

            }

        } else if ( params.object ) {

            if ( params.object.instanceof === 'Object3D' ) {

                var newObject = new NWE.gfx.Object3D();

                for ( var i = 0, il = params.object.children.length; i < il; i ++ ) {

                    var sourceMesh = params.object.children[ i ];

                    var material = new MeshBasicMaterial({ color: new Color( this.objects.length ) });
                    var geometryCopy = sourceMesh.geometry.clone();

                    this.objects.push( geometryCopy );
                    geometryCopy.pickId = params.id + i;

                    var mesh = new NWE.gfx.Mesh( geometryCopy, material );
                    mesh.position = sourceMesh.position;
                    mesh.rotation = sourceMesh.rotation;
                    geometryCopy.mesh = mesh;

                    newObject.position = params.object.position;
                    newObject.rotation = params.object.rotation;
                    newObject.quaternion = params.object.quaternion;

                    newObject.add( mesh );

                }

                this.scene.add( newObject );

            }

        }

    };

    GpuSelector.prototype.removeObject = function ( id, deferedUpdate ) {

        var tmpArray = [];
        var objectForDeleting = null;

        for ( var i = 0, il = this.objects.length; i < il; i ++ ) {

            if ( this.objects[ i ].pickId === id ) {

                objectForDeleting = this.objects[ i ];
                tmpArray.push( false );

            } else {

                tmpArray.push( this.objects[ i ] );

            }

        }

        this.objects = tmpArray;

        //

        if ( objectForDeleting.mesh ) objectForDeleting = objectForDeleting.mesh; // tmp ?!

        if ( objectForDeleting.instanceof && ( objectForDeleting.instanceof === 'Mesh' || objectForDeleting.instanceof === 'Object3D' ) ) {

            if ( objectForDeleting.instanceof === 'Mesh' ) {

                if ( objectForDeleting.parent ) {

                    objectForDeleting.parent.remove( objectForDeleting );

                } else {

                    this.scene.remove( objectForDeleting );

                }

            } else if ( objectForDeleting.instanceof === 'Object3D' ) {

                this.scene.remove( objectForDeleting );

            }

        } else {

            if ( ! deferedUpdate ) {

                this.generateGroup();

            }

        }

    };

    GpuSelector.prototype.update = function ( camera ) {

        this.renderer.render( this.scene, camera, this.pickingTexture );

        this._glContext = this.renderer.getContext();

    };

    GpuSelector.prototype.pick = function ( x, y, camera ) { // x & y in range [0..1]

        var result = false;

        x = ( this.mapWidth * x );
        y = ( 1 - y ) * this.mapHeight;

        this.update( camera );

        var gl = this._glContext;

        // read the pixel under the mouse from the texture
        gl.readPixels( x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, this.pixelBuffer );

        // interpret the pixel as an ID
        var id = ( this.pixelBuffer[ 0 ] << 16 ) | ( this.pixelBuffer[ 1 ] << 8 ) | ( this.pixelBuffer[ 2 ] );

        if ( !! this.objects[ id ] ) {

            this.dispatchEvent({ type: 'onSelect', objectID: this.objects[ id ].pickId });

        }

    };

    EventDispatcher.prototype.apply( GpuSelector.prototype );

    GpuSelector.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    GpuSelector.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    GpuSelector.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    GpuSelector.setInternal = function ( name, value ) { internal[ name ] = value; };
    GpuSelector.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof GpuSelector === 'function' ) {
        var t = {}, p = {};
        for ( var i in GpuSelector ) t[i] = GpuSelector[i];
        for ( var i in GpuSelector.prototype ) try { p[i] = GpuSelector.prototype[i] } catch(e) {};
        scope.GpuSelector = GpuSelector.bind( scope );
    } else {
        scope.GpuSelector = GpuSelector;
    }
    internal['constructor'] = GpuSelector;
    scope.GpuSelector.prototype = GpuSelector.prototype;
    for ( var i in t ) scope.GpuSelector[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.GpuSelector.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__GpuSelector ) {
        for ( var i = 0, il = scope.__GpuSelector.length; i < il; i ++ ) scope.__GpuSelector[ i ]( GpuSelector );
        delete scope.__GpuSelector;
    }

}) ( NWE.gfx );


// src/graphics/extras/scene/Fog.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var Fog = function ( hex, near, far ) {

        this.name = '';

        this.color = new Color( hex );

        this.near = ( near !== undefined ) ? near : 1;
        this.far = ( far !== undefined ) ? far : 1000;

        this.instanceof = 'Fog';

    };

    Fog.prototype.clone = function () {

        return new Fog( this.color.getHex(), this.near, this.far );

    };

    if ( typeof Fog === 'function' ) {
        var t = {}, p = {};
        for ( var i in Fog ) t[i] = Fog[i];
        for ( var i in Fog.prototype ) try { p[i] = Fog.prototype[i] } catch(e) {};
        scope.Fog = Fog.bind( scope );
    } else {
        scope.Fog = Fog;
    }
    scope.Fog.prototype = Fog.prototype;
    for ( var i in t ) scope.Fog[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Fog.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Fog ) {
        for ( var i = 0, il = scope.__Fog.length; i < il; i ++ ) scope.__Fog[ i ]( Fog );
        delete scope.__Fog;
    }

}) ( NWE.gfx );


// src/graphics/extras/scene/FogExp2.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var FogExp2 = function ( hex, density ) {

        this.name = '';

        this.color = new Color( hex );
        this.density = ( density !== undefined ) ? density : 0.00025;

        this.instanceof = 'FogExp2';

    };

    FogExp2.prototype.clone = function () {

        return new FogExp2( this.color.getHex(), this.density );

    };

    if ( typeof FogExp2 === 'function' ) {
        var t = {}, p = {};
        for ( var i in FogExp2 ) t[i] = FogExp2[i];
        for ( var i in FogExp2.prototype ) try { p[i] = FogExp2.prototype[i] } catch(e) {};
        scope.FogExp2 = FogExp2.bind( scope );
    } else {
        scope.FogExp2 = FogExp2;
    }
    scope.FogExp2.prototype = FogExp2.prototype;
    for ( var i in t ) scope.FogExp2[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.FogExp2.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__FogExp2 ) {
        for ( var i = 0, il = scope.__FogExp2.length; i < il; i ++ ) scope.__FogExp2[ i ]( FogExp2 );
        delete scope.__FogExp2;
    }

}) ( NWE.gfx );


// src/graphics/extras/core/Curve.js

( function ( scope ) {

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Extensible curve object
     *
     * Some common of Curve methods
     * .getPoint(t), getTangent(t)
     * .getPointAt(u), getTagentAt(u)
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following classes subclasses NWE.Curve:
     *
     * -- 2d classes --
     * NWE.LineCurve
     * NWE.QuadraticBezierCurve
     * NWE.CubicBezierCurve
     * NWE.SplineCurve
     * NWE.ArcCurve
     * NWE.EllipseCurve
     *
     * -- 3d classes --
     * NWE.LineCurve3
     * NWE.QuadraticBezierCurve3
     * NWE.CubicBezierCurve3
     * NWE.SplineCurve3
     * NWE.ClosedSplineCurve3
     *
     * A series of curves can be represented as a NWE.CurvePath
     *
     **/

    /**************************************************************
     *  Abstract Curve base class
     **************************************************************/

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var Curve = function () {

    };

    // Virtual base class method to overwrite and implement in subclasses
    //  - t [0 .. 1]

    Curve.prototype.getPoint = function ( t ) {

        Logger.log( 'NWE.Curve.getPoint(): Warning, getPoint() not implemented!' );
        return null;

    };

    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]

    Curve.prototype.getPointAt = function ( u ) {

        var t = this.getUtoTmapping( u );
        return this.getPoint( t );

    };

    // Get sequence of points using getPoint( t )

    Curve.prototype.getPoints = function ( divisions ) {

        if ( ! divisions ) divisions = 5;

        var d, pts = [];

        for ( d = 0; d <= divisions; d ++ ) {

            pts.push( this.getPoint( d / divisions ) );

        }

        return pts;

    };

    // Get sequence of points using getPointAt( u )

    Curve.prototype.getSpacedPoints = function ( divisions ) {

        if ( ! divisions ) divisions = 5;

        var d, pts = [];

        for ( d = 0; d <= divisions; d ++ ) {

            pts.push( this.getPointAt( d / divisions ) );

        }

        return pts;

    };

    // Get total curve arc length

    Curve.prototype.getLength = function () {

        var lengths = this.getLengths();
        return lengths[ lengths.length - 1 ];

    };

    // Get list of cumulative segment lengths

    Curve.prototype.getLengths = function ( divisions ) {

        if ( ! divisions ) divisions = ( internal[ this.uuid ].arcLengthDivisions ) ? ( internal[ this.uuid ].arcLengthDivisions ) : 200;

        if ( this.cacheArcLengths && ( this.cacheArcLengths.length === divisions + 1 ) && ! this.needsUpdate ) {

            //console.log( "cached", this.cacheArcLengths );
            return this.cacheArcLengths;

        }

        this.needsUpdate = false;

        var cache = [];
        var current, last = this.getPoint( 0 );
        var p, sum = 0;

        cache.push( 0 );

        for ( p = 1; p <= divisions; p ++ ) {

            current = this.getPoint ( p / divisions );
            sum += current.distanceTo( last );
            cache.push( sum );
            last = current;

        }

        this.cacheArcLengths = cache;

        return cache; // { sums: cache, sum:sum }; Sum is in the last element.

    };

    Curve.prototype.updateArcLengths = function () {

        this.needsUpdate = true;
        this.getLengths();

    };

    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

    Curve.prototype.getUtoTmapping = function ( u, distance ) {

        var arcLengths = this.getLengths();

        var i = 0, il = arcLengths.length;

        var targetArcLength; // The targeted u distance value to get

        if ( distance ) {

            targetArcLength = distance;

        } else {

            targetArcLength = u * arcLengths[ il - 1 ];

        }

        // var time = Date.now();

        // binary search for the index with largest value smaller than target u distance

        var low = 0, high = il - 1, comparison;

        while ( low <= high ) {

            i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

            comparison = arcLengths[ i ] - targetArcLength;

            if ( comparison < 0 ) {

                low = i + 1;
                continue;

            } else if ( comparison > 0 ) {

                high = i - 1;
                continue;

            } else {

                high = i;
                break;

                // DONE

            }

        }

        i = high;

        // console.log('b' , i, low, high, Date.now()- time);

        if ( arcLengths[ i ] == targetArcLength ) {

            var t = i / ( il - 1 );
            return t;

        }

        // we could get finer grain at lengths, or use simple interpolatation between two points

        var lengthBefore = arcLengths[ i ];
        var lengthAfter = arcLengths[ i + 1 ];

        var segmentLength = lengthAfter - lengthBefore;

        // determine where we are between the 'before' and 'after' points

        var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

        // add that fractional amount to t

        var t = ( i + segmentFraction ) / ( il -1 );

        return t;

    };

    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation

    Curve.prototype.getTangent = function ( t ) {

        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;

        // Capping in case of danger

        if ( t1 < 0 ) t1 = 0;
        if ( t2 > 1 ) t2 = 1;

        var pt1 = this.getPoint( t1 );
        var pt2 = this.getPoint( t2 );

        var vec = pt2.clone().sub( pt1 );
        return vec.normalize();

    };

    Curve.prototype.getTangentAt = function ( u ) {

        var t = this.getUtoTmapping( u );
        return this.getTangent( t );

    };

    /**************************************************************
     *  Utils
     **************************************************************/

    Curve.Utils = {

        tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

            return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

        },

        // Puay Bing, thanks for helping with this derivative!

        tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

            return -3 * p0 * (1 - t) * (1 - t)  +
                3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
                6 * t *  p2 * (1-t) - 3 * t * t * p2 +
                3 * t * t * p3;

        },


        tangentSpline: function ( t, p0, p1, p2, p3 ) {

            // To check if my formulas are correct

            var h00 = 6 * t * t - 6 * t;    // derived from 2t^3  3t^2 + 1
            var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
            var h01 = -6 * t * t + 6 * t;   //  2t3 + 3t2
            var h11 = 3 * t * t - 2 * t;    // t3  t2

            return h00 + h10 + h01 + h11;

        },

        // Catmull-Rom

        interpolate: function( p0, p1, p2, p3, t ) {

            var v0 = ( p2 - p0 ) * 0.5;
            var v1 = ( p3 - p1 ) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

        }

    };

    // TODO: Transformation for Curves?

    /**************************************************************
     *  3D Curves
     **************************************************************/

    // A Factory method for creating new curve subclasses

    Curve.create = function ( constructor, getPointFunc ) {

        constructor.prototype = Object.create( Curve.prototype );
        constructor.prototype.getPoint = getPointFunc;

        return constructor;

    };

    if ( typeof Curve === 'function' ) {
        var t = {}, p = {};
        for ( var i in Curve ) t[i] = Curve[i];
        for ( var i in Curve.prototype ) try { p[i] = Curve.prototype[i] } catch(e) {};
        scope.Curve = Curve.bind( scope );
    } else {
        scope.Curve = Curve;
    }
    scope.Curve.prototype = Curve.prototype;
    for ( var i in t ) scope.Curve[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Curve.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Curve ) {
        for ( var i = 0, il = scope.__Curve.length; i < il; i ++ ) scope.__Curve[ i ]( Curve );
        delete scope.__Curve;
    }

}) ( NWE );


// src/graphics/extras/curves/SplineCurve3.js

( function ( scope ) {

    /**************************************************************
     *  Spline 3D curve
     **************************************************************/

    var Curve = NWE.Curve;
    if ( !Curve ) { NWE.__Curve = (NWE.__Curve || []); NWE.__Curve.push( function ( obj ) { Curve = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var SplineCurve3 = NWE.Curve.create(

        function ( points /* array of Vector3 */ ) {

            this.points = ( points == undefined ) ? [] : points;

        },

        function ( t ) {

            var v = new Vec3();
            var c = [];
            var points = this.points, point, intPoint, weight;
            point = ( points.length - 1 ) * t;

            intPoint = Math.floor( point );
            weight = point - intPoint;

            c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
            c[ 1 ] = intPoint;
            c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
            c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

            var pt0 = points[ c[0] ],
                pt1 = points[ c[1] ],
                pt2 = points[ c[2] ],
                pt3 = points[ c[3] ];

            v.x = Curve.Utils.interpolate( pt0.x, pt1.x, pt2.x, pt3.x, weight );
            v.y = Curve.Utils.interpolate( pt0.y, pt1.y, pt2.y, pt3.y, weight );
            v.z = Curve.Utils.interpolate( pt0.z, pt1.z, pt2.z, pt3.z, weight );

            return v;

        }

    );

    if ( typeof SplineCurve3 === 'function' ) {
        var t = {}, p = {};
        for ( var i in SplineCurve3 ) t[i] = SplineCurve3[i];
        for ( var i in SplineCurve3.prototype ) try { p[i] = SplineCurve3.prototype[i] } catch(e) {};
        scope.SplineCurve3 = SplineCurve3.bind( scope );
    } else {
        scope.SplineCurve3 = SplineCurve3;
    }
    scope.SplineCurve3.prototype = SplineCurve3.prototype;
    for ( var i in t ) scope.SplineCurve3[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.SplineCurve3.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__SplineCurve3 ) {
        for ( var i = 0, il = scope.__SplineCurve3.length; i < il; i ++ ) scope.__SplineCurve3[ i ]( SplineCurve3 );
        delete scope.__SplineCurve3;
    }

}) ( NWE );


// src/loaders/Loader.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var DefaultLoadingManager = NWE.DefaultLoadingManager;
    if ( !DefaultLoadingManager ) { NWE.__DefaultLoadingManager = (NWE.__DefaultLoadingManager || []); NWE.__DefaultLoadingManager.push( function ( obj ) { DefaultLoadingManager = obj; } ); }

    var ShaderMaterial = NWE.gfx.ShaderMaterial;
    if ( !ShaderMaterial ) { NWE.gfx.__ShaderMaterial = (NWE.gfx.__ShaderMaterial || []); NWE.gfx.__ShaderMaterial.push( function ( obj ) { ShaderMaterial = obj; } ); }

    var ShaderLib = NWE.gfx.ShaderLib;
    if ( !ShaderLib ) { NWE.gfx.__ShaderLib = (NWE.gfx.__ShaderLib || []); NWE.gfx.__ShaderLib.push( function ( obj ) { ShaderLib = obj; } ); }

    var UniformUtils = NWE.gfx.UniformUtils;
    if ( !UniformUtils ) { NWE.gfx.__UniformUtils = (NWE.gfx.__UniformUtils || []); NWE.gfx.__UniformUtils.push( function ( obj ) { UniformUtils = obj; } ); }

    var ImageUtils = NWE.gfx.ImageUtils;
    if ( !ImageUtils ) { NWE.gfx.__ImageUtils = (NWE.gfx.__ImageUtils || []); NWE.gfx.__ImageUtils.push( function ( obj ) { ImageUtils = obj; } ); }

    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }


    var Loader = function ( showStatus ) {

        this.showStatus = showStatus;
        this.statusDomElement = showStatus ? Loader.prototype.addStatusElement() : null;

        this.onLoadStart = function () {};
        this.onLoadProgress = function () {};
        this.onLoadComplete = function () {};

    };

    Loader.prototype = {

        constructor: Loader,

        crossOrigin: 'anonymous',

        addStatusElement: function () {

            var e = document.createElement( "div" );

            e.style.position = "absolute";
            e.style.right = "0px";
            e.style.top = "0px";
            e.style.fontSize = "0.8em";
            e.style.textAlign = "left";
            e.style.background = "rgba(0,0,0,0.25)";
            e.style.color = "#fff";
            e.style.width = "120px";
            e.style.padding = "0.5em 0.5em 0.5em 0.5em";
            e.style.zIndex = 1000;

            e.innerHTML = "Loading ...";

            return e;

        },

        updateProgress: function ( progress ) {

            var message = "Loaded ";

            if ( progress.total ) {

                message += ( 100 * progress.loaded / progress.total ).toFixed(0) + "%";


            } else {

                message += ( progress.loaded / 1000 ).toFixed(2) + " KB";

            }

            this.statusDomElement.innerHTML = message;

        },

        extractUrlBase: function ( url ) {

            var parts = url.split( '/' );
            parts.pop();
            return ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';

        },

        initMaterials: function ( materials, texturePath ) {

            var array = [];

            for ( var i = 0; i < materials.length; ++ i ) {

                array[ i ] = Loader.prototype.createMaterial( materials[ i ], texturePath );

            }

            return array;

        },

        needsTangents: function ( materials ) {

            for( var i = 0, il = materials.length; i < il; i ++ ) {

                var m = materials[ i ];

                if ( m instanceof ShaderMaterial ) return true;

            }

            return false;

        },

        createMaterial: function ( m, texturePath ) {

            var _this = this;

            function is_pow2( n ) {

                var l = Math.log( n ) / Math.LN2;
                return Math.floor( l ) == l;

            }

            function nearest_pow2( n ) {

                var l = Math.log( n ) / Math.LN2;
                return Math.pow( 2, Math.round(  l ) );

            }

            function load_image( where, url ) {

                var image = new Image();

                image.onload = function () {

                    if ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {

                        var width = nearest_pow2( this.width );
                        var height = nearest_pow2( this.height );

                        where.image.width = width;
                        where.image.height = height;
                        where.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );

                    } else {

                        where.image = this;

                    }

                    where.needsUpdate = true;

                };

                image.crossOrigin = _this.crossOrigin;
                image.src = url;

            }

            function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

                var isCompressed = /\.dds$/i.test( sourceFile );
                var isTGA = /\.tga$/i.test( sourceFile );

                var fullPath = texturePath + "/" + sourceFile;

                if ( isCompressed ) {

                    var texture = ImageUtils.loadCompressedTexture( fullPath );

                    where[ name ] = texture;

                } else if ( isTGA ) {

                    var texture = ImageUtils.loadTGATexture( fullPath );

                    where[ name ] = texture;

                } else {

                    var texture = document.createElement( 'canvas' );

                    where[ name ] = new Texture( texture );

                }

                where[ name ].sourceFile = sourceFile;

                if ( repeat ) {

                    where[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );

                    if ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = NWE.RepeatWrapping;
                    if ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = NWE.RepeatWrapping;

                }

                if ( offset ) {

                    where[ name ].offset.set( offset[ 0 ], offset[ 1 ] );

                }

                if ( wrap ) {

                    var wrapMap = {
                        "repeat": NWE.RepeatWrapping,
                        "mirror": NWE.MirroredRepeatWrapping
                    }

                    if ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];
                    if ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];

                }

                if ( anisotropy ) {

                    where[ name ].anisotropy = anisotropy;

                }

                if ( ! isCompressed ) {

                    load_image( where[ name ], fullPath );

                }

            }

            function rgb2hex( rgb ) {

                return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

            }

            // defaults

            var mtype = "MeshLambertMaterial";
            var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

            // parameters from model file

            if ( m.shading ) {

                var shading = m.shading.toLowerCase();

                if ( shading === "phong" ) mtype = "MeshPhongMaterial";
                else if ( shading === "basic" ) mtype = "MeshBasicMaterial";

            }

            if ( m.blending !== undefined && NWE[ m.blending ] !== undefined ) {

                mpars.blending = NWE[ m.blending ];

            }

            if ( m.transparent !== undefined || m.opacity < 1.0 ) {

                mpars.transparent = m.transparent;

            }

            if ( m.depthTest !== undefined ) {

                mpars.depthTest = m.depthTest;

            }

            if ( m.depthWrite !== undefined ) {

                mpars.depthWrite = m.depthWrite;

            }

            if ( m.visible !== undefined ) {

                mpars.visible = m.visible;

            }

            if ( m.flipSided !== undefined ) {

                mpars.side = NWE.BackSide;

            }

            if ( m.doubleSided !== undefined ) {

                mpars.side = NWE.DoubleSide;

            }

            if ( m.wireframe !== undefined ) {

                mpars.wireframe = m.wireframe;

            }

            if ( m.vertexColors !== undefined ) {

                if ( m.vertexColors === "face" ) {

                    mpars.vertexColors = NWE.FaceColors;

                } else if ( m.vertexColors ) {

                    mpars.vertexColors = NWE.VertexColors;

                }

            }

            // colors

            if ( m.colorDiffuse ) {

                mpars.color = rgb2hex( m.colorDiffuse );

            } else if ( m.DbgColor ) {

                mpars.color = m.DbgColor;

            }

            if ( m.colorSpecular ) {

                mpars.specular = rgb2hex( m.colorSpecular );

            }

            if ( m.colorAmbient ) {

                mpars.ambient = rgb2hex( m.colorAmbient );

            }

            // modifiers

            if ( m.transparency ) {

                mpars.opacity = m.transparency;

            }

            if ( m.specularCoef ) {

                mpars.shininess = m.specularCoef;

            }

            // textures

            if ( m.mapDiffuse && texturePath ) {

                create_texture( mpars, "map", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

            }

            if ( m.mapLight && texturePath ) {

                create_texture( mpars, "lightMap", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

            }

            if ( m.mapBump && texturePath ) {

                create_texture( mpars, "bumpMap", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

            }

            if ( m.mapNormal && texturePath ) {

                create_texture( mpars, "normalMap", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

            }

            if ( m.mapSpecular && texturePath ) {

                create_texture( mpars, "specularMap", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

            }

            //

            if ( m.mapBumpScale ) {

                mpars.bumpScale = m.mapBumpScale;

            }

            // special case for normal mapped material

            if ( m.mapNormal ) {

                var shader = ShaderLib[ "normalmap" ];
                var uniforms = UniformsUtils.clone( shader.uniforms );

                uniforms[ "tNormal" ].value = mpars.normalMap;

                if ( m.mapNormalFactor ) {

                    uniforms[ "uNormalScale" ].value.set( m.mapNormalFactor, m.mapNormalFactor );

                }

                if ( mpars.map ) {

                    uniforms[ "tDiffuse" ].value = mpars.map;
                    uniforms[ "enableDiffuse" ].value = true;

                }

                if ( mpars.specularMap ) {

                    uniforms[ "tSpecular" ].value = mpars.specularMap;
                    uniforms[ "enableSpecular" ].value = true;

                }

                if ( mpars.lightMap ) {

                    uniforms[ "tAO" ].value = mpars.lightMap;
                    uniforms[ "enableAO" ].value = true;

                }

                // for the moment don't handle displacement texture

                uniforms[ "uDiffuseColor" ].value.setHex( mpars.color );
                uniforms[ "uSpecularColor" ].value.setHex( mpars.specular );
                uniforms[ "uAmbientColor" ].value.setHex( mpars.ambient );

                uniforms[ "uShininess" ].value = mpars.shininess;

                if ( mpars.opacity !== undefined ) {

                    uniforms[ "uOpacity" ].value = mpars.opacity;

                }

                var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
                var material = new ShaderMaterial( parameters );

                if ( mpars.transparent ) {

                    material.transparent = true;

                }

            } else {

                var material = new NWE[ mtype ]( mpars );

            }

            if ( m.DbgName !== undefined ) material.name = m.DbgName;

            return material;

        }

    };

    if ( typeof Loader === 'function' ) {
        var t = {}, p = {};
        for ( var i in Loader ) t[i] = Loader[i];
        for ( var i in Loader.prototype ) try { p[i] = Loader.prototype[i] } catch(e) {};
        scope.Loader = Loader.bind( scope );
    } else {
        scope.Loader = Loader;
    }
    scope.Loader.prototype = Loader.prototype;
    for ( var i in t ) scope.Loader[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Loader.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Loader ) {
        for ( var i = 0, il = scope.__Loader.length; i < il; i ++ ) scope.__Loader[ i ]( Loader );
        delete scope.__Loader;
    }

}) ( NWE );


// src/loaders/XHRLoader.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var DefaultLoadingManager = NWE.DefaultLoadingManager;
    if ( !DefaultLoadingManager ) { NWE.__DefaultLoadingManager = (NWE.__DefaultLoadingManager || []); NWE.__DefaultLoadingManager.push( function ( obj ) { DefaultLoadingManager = obj; } ); }


    var XHRLoader = function ( manager ) {

        this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

    };

    XHRLoader.prototype = {

        constructor: XHRLoader,

        load: function ( url, onLoad, onProgress, onError ) {

            var scope = this;
            var request = new XMLHttpRequest();

            if ( onLoad !== undefined ) {

                request.addEventListener( 'load', function ( event ) {

                    if ( scope.binary ) {

                        onLoad( '', event.target );

                    } else {

                        onLoad( event.target.responseText, event.target );

                    }

                    scope.manager.itemEnd( url );

                }, false );

            }

            if ( onProgress !== undefined ) {

                request.addEventListener( 'progress', function ( event ) {

                    onProgress( event );

                }, false );

            }

            if ( onError !== undefined ) {

                request.addEventListener( 'error', function ( event ) {

                    onError( event );

                }, false );

            }

            request.open( 'GET', url, true );

            if ( this.binary ) request.responseType = 'arraybuffer';
            if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
            
            request.send( null );

            scope.manager.itemStart( url );

        },

        setCrossOrigin: function ( value ) {

            this.crossOrigin = value;

        },

        setBinaryLoading: function ( value ) {

            this.binary = true;

        }

    };

    if ( typeof XHRLoader === 'function' ) {
        var t = {}, p = {};
        for ( var i in XHRLoader ) t[i] = XHRLoader[i];
        for ( var i in XHRLoader.prototype ) try { p[i] = XHRLoader.prototype[i] } catch(e) {};
        scope.XHRLoader = XHRLoader.bind( scope );
    } else {
        scope.XHRLoader = XHRLoader;
    }
    scope.XHRLoader.prototype = XHRLoader.prototype;
    for ( var i in t ) scope.XHRLoader[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.XHRLoader.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__XHRLoader ) {
        for ( var i = 0, il = scope.__XHRLoader.length; i < il; i ++ ) scope.__XHRLoader[ i ]( XHRLoader );
        delete scope.__XHRLoader;
    }

}) ( NWE );


// src/loaders/ImageLoader.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */



    var DefaultLoadingManager = NWE.DefaultLoadingManager;
    if ( !DefaultLoadingManager ) { NWE.__DefaultLoadingManager = (NWE.__DefaultLoadingManager || []); NWE.__DefaultLoadingManager.push( function ( obj ) { DefaultLoadingManager = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var ImageLoader = function ( manager ) {

        this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

    };

    ImageLoader.prototype = {

        constructor: ImageLoader,

        parse: function ( image, buffer ) {

            var pluginName = ImageLoader.formats[ image.format ];
            var plugin = ImageLoader[ pluginName ];

            if ( !! plugin ) {

                return plugin.fromBin( image, buffer );

            } else {

                Logger.error( 'NWE.gfx.Texture.fromRaw(): unknown texture format.' );
                return false;

            }

        },

        load: function ( input, onLoad, onProgress, onError ) {

            var self = this;

            var url = input.url || input;
            var buffer = input.data || null;

            var image = {
            
                width: 0,
                height: 0,
                data: null,
                mapping: null,
                sourceFile: url,
                format: url.split('.').pop().toLowerCase()

            };

            switch ( image.format ) {

                case 'tga':
                case 'dds':
                case 'png':

                    if ( buffer ) {

                        image = self.parse( image, buffer );
                        if ( onLoad ) onLoad( image );

                        break;

                    }

                    var request = new XMLHttpRequest();

                    request.onload = function () {

                        if ( this.status === 200 ) {

                            image = self.parse( image, this.response );
                            if ( onLoad ) onLoad( image );

                        }

                    };

                    request.addEventListener( 'load', function ( event ) {

                        // if ( onLoad ) onLoad( image );

                    }, false );

                    request.addEventListener( 'error', function ( event ) {

                        if ( onError ) onError( event );

                    }, false );

                    request.open( 'GET', url, true );
                    request.responseType = 'arraybuffer';
                    request.send( null );

                    break;

                default:

                    image.data = document.createElement( 'img' );

                    if ( onLoad !== undefined ) {

                        image.data.addEventListener( 'load', function ( event ) {

                            onLoad( this );

                        }, false );

                    }

                    if ( onProgress !== undefined ) {

                        image.data.addEventListener( 'progress', function ( event ) {

                            onProgress( event );

                        }, false );

                    }

                    if ( onError !== undefined ) {

                        image.data.addEventListener( 'error', function ( event ) {

                            onError( event );

                        }, false );

                    }

                    if ( this.crossOrigin !== undefined ) image.data.crossOrigin = this.crossOrigin;

                    image.data.src = url;
                    image.sourceFile = url;
                    image.width = image.data.width;
                    image.height = image.data.height;

            }

            return image;

        },

        setCrossOrigin: function ( value ) {

            this.crossOrigin = value;

        }

    };

    var ImageLoader = new ImageLoader();
    ImageLoader.formats = {};

    scope.ImageLoader = ImageLoader;
    if ( scope.__ImageLoader ) {
        for ( var i = 0, il = scope.__ImageLoader.length; i < il; i ++ ) scope.__ImageLoader[ i ]( ImageLoader );
        delete scope.__ImageLoader;
    }

}) ( NWE );


// src/loaders/JSONLoader.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author ohmed
     */

    var DefaultLoadingManager = NWE.DefaultLoadingManager;
    if ( !DefaultLoadingManager ) { NWE.__DefaultLoadingManager = (NWE.__DefaultLoadingManager || []); NWE.__DefaultLoadingManager.push( function ( obj ) { DefaultLoadingManager = obj; } ); }

    var Loader = NWE.Loader;
    if ( !Loader ) { NWE.__Loader = (NWE.__Loader || []); NWE.__Loader.push( function ( obj ) { Loader = obj; } ); }

    var XHRLoader = NWE.XHRLoader;
    if ( !XHRLoader ) { NWE.__XHRLoader = (NWE.__XHRLoader || []); NWE.__XHRLoader.push( function ( obj ) { XHRLoader = obj; } ); }


    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Vec4 = NWE.Vec4;
    if ( !Vec4 ) { NWE.__Vec4 = (NWE.__Vec4 || []); NWE.__Vec4.push( function ( obj ) { Vec4 = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var JSONLoader = function ( showStatus ) {

        Loader.call( this, showStatus );

        this.withCredentials = false;

    };

    JSONLoader.prototype = Object.create( Loader.prototype );

    JSONLoader.prototype.load = function ( name, url, callback, texturePath ) {

        var scope = this;

        texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

        function newCallback ( geometry, materials ) {

            callback( name, geometry, materials );

        }

        this.onLoadStart();
        this.loadAjaxJSON( this, url, newCallback, texturePath );

    };

    JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

        var xhr = new XMLHttpRequest();

        var length = 0;

        xhr.onreadystatechange = function () {

            if ( xhr.readyState === xhr.DONE ) {

                if ( xhr.status === 200 || xhr.status === 0 ) {

                    if ( xhr.responseText ) {

                        var json = JSON.parse( xhr.responseText );
                        var result = context.parse( json, texturePath );
                        callback( result.geometry, result.materials );

                    } else {

                        Logger.warn( 'NWE.JSONLoader.loadAjaxJSON(): [' + url + '] seems to be unreachable or file there is empty' );

                    }

                    // in context of more complex asset initialization
                    // do not block on single failed file
                    // maybe should go even one more level up

                    context.onLoadComplete();

                } else {

                    Logger.error( 'NWE.JSONLoader.loadAjaxJSON(): Couldn\'t load [' + url + '] [' + xhr.status + ']' );

                }

            } else if ( xhr.readyState === xhr.LOADING ) {

                if ( callbackProgress ) {

                    if ( length === 0 ) {

                        length = xhr.getResponseHeader( 'Content-Length' );

                    }

                    callbackProgress( { total: length, loaded: xhr.responseText.length } );

                }

            } else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

                if ( callbackProgress !== undefined ) {

                    length = xhr.getResponseHeader( 'Content-Length' );

                }

            }

        };

        xhr.open( 'GET', url, true );
        xhr.withCredentials = this.withCredentials;
        xhr.send( null );

    };

    JSONLoader.prototype.parse = function ( json, texturePath ) {

        var scope = this,
        geometry = new BufferGeometry(),
        scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

        parseModel( scale );

        parseSkin();
        parseMorphing( scale );

        geometry.computeCentroids();
        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();

        function parseModel ( scale ) {

            function isBitSet ( value, position ) {

                return value & ( 1 << position );

            }

            var i, j, fi,

            offset, zLength,

            colorIndex, normalIndex, uvIndex, materialIndex,

            type,
            isQuad,
            hasMaterial,
            hasFaceVertexUv,
            hasFaceNormal, hasFaceVertexNormal,
            hasFaceColor, hasFaceVertexColor,

            vertex, face, faceA, faceB, color, hex, normal,

            uvLayer, uv, u, v,

            faces = json.faces,
            vertices = json.vertices,
            normals = json.normals,
            colors = json.colors,

            nUvLayers = 0;

            if ( json.uvs !== undefined ) {

                // disregard empty arrays

                for ( i = 0; i < json.uvs.length; i++ ) {

                    if ( json.uvs[ i ].length ) nUvLayers ++;

                }

                for ( i = 0; i < nUvLayers; i++ ) {

                    geometry.faceVertexUvs[ i ] = [];

                }

            }

            offset = 0;
            zLength = vertices.length;

            while ( offset < zLength ) {

                vertex = new Vec3();

                vertex.x = vertices[ offset ++ ] * scale;
                vertex.y = vertices[ offset ++ ] * scale;
                vertex.z = vertices[ offset ++ ] * scale;

                geometry.vertices.push( vertex );

            }

            offset = 0;
            zLength = faces.length;

            while ( offset < zLength ) {

                type = faces[ offset ++ ];

                isQuad              = isBitSet( type, 0 );
                hasMaterial         = isBitSet( type, 1 );
                hasFaceVertexUv     = isBitSet( type, 3 );
                hasFaceNormal       = isBitSet( type, 4 );
                hasFaceVertexNormal = isBitSet( type, 5 );
                hasFaceColor        = isBitSet( type, 6 );
                hasFaceVertexColor  = isBitSet( type, 7 );

                // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

                if ( isQuad ) {

                    faceA = new Face();
                    faceA.a = faces[ offset ];
                    faceA.b = faces[ offset + 1 ];
                    faceA.c = faces[ offset + 3 ];

                    faceB = new Face();
                    faceB.a = faces[ offset + 1 ];
                    faceB.b = faces[ offset + 2 ];
                    faceB.c = faces[ offset + 3 ];

                    offset += 4;

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset ++ ];
                        faceA.materialIndex = materialIndex;
                        faceB.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];
                            geometry.faceVertexUvs[ i ][ fi + 1 ] = []

                            for ( j = 0; j < 4; j ++ ) {

                                uvIndex = faces[ offset ++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new Vec2( u, v );

                                if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                                if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset ++ ] * 3;

                        faceA.normal.set(
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ]
                        );

                        faceB.normal.copy( faceA.normal );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 4; i++ ) {

                            normalIndex = faces[ offset ++ ] * 3;

                            normal = new Vec3(
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ]
                            );


                            if ( i !== 2 ) faceA.vertexNormals.push( normal );
                            if ( i !== 0 ) faceB.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset ++ ];
                        hex = colors[ colorIndex ];

                        faceA.color.setHex( hex );
                        faceB.color.setHex( hex );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 4; i++ ) {

                            colorIndex = faces[ offset ++ ];
                            hex = colors[ colorIndex ];

                            if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
                            if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

                        }

                    }

                    geometry.faces.push( faceA );
                    geometry.faces.push( faceB );

                } else {

                    face = new Face();
                    face.a = faces[ offset ++ ];
                    face.b = faces[ offset ++ ];
                    face.c = faces[ offset ++ ];

                    if ( hasMaterial ) {

                        materialIndex = faces[ offset ++ ];
                        face.materialIndex = materialIndex;

                    }

                    // to get face <=> uv index correspondence

                    fi = geometry.faces.length;

                    if ( hasFaceVertexUv ) {

                        for ( i = 0; i < nUvLayers; i++ ) {

                            uvLayer = json.uvs[ i ];

                            geometry.faceVertexUvs[ i ][ fi ] = [];

                            for ( j = 0; j < 3; j ++ ) {

                                uvIndex = faces[ offset ++ ];

                                u = uvLayer[ uvIndex * 2 ];
                                v = uvLayer[ uvIndex * 2 + 1 ];

                                uv = new Vec2( u, v );

                                geometry.faceVertexUvs[ i ][ fi ].push( uv );

                            }

                        }

                    }

                    if ( hasFaceNormal ) {

                        normalIndex = faces[ offset ++ ] * 3;

                        face.normal.set(
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ]
                        );

                    }

                    if ( hasFaceVertexNormal ) {

                        for ( i = 0; i < 3; i++ ) {

                            normalIndex = faces[ offset ++ ] * 3;

                            normal = new Vec3(
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ]
                            );

                            face.vertexNormals.push( normal );

                        }

                    }


                    if ( hasFaceColor ) {

                        colorIndex = faces[ offset ++ ];
                        face.color.setHex( colors[ colorIndex ] );

                    }


                    if ( hasFaceVertexColor ) {

                        for ( i = 0; i < 3; i++ ) {

                            colorIndex = faces[ offset ++ ];
                            face.vertexColors.push( new Color( colors[ colorIndex ] ) );

                        }

                    }

                    geometry.faces.push( face );

                }

            }

        };

        function parseSkin () {

            var i, l, x, y, z, w, a, b, c, d;

            if ( json.skinWeights ) {

                for ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {

                    x = json.skinWeights[ i     ];
                    y = json.skinWeights[ i + 1 ];
                    z = 0;
                    w = 0;

                    geometry.skinWeights.push( new Vec4( x, y, z, w ) );

                }

            }

            if ( json.skinIndices ) {

                for ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {

                    a = json.skinIndices[ i     ];
                    b = json.skinIndices[ i + 1 ];
                    c = 0;
                    d = 0;

                    geometry.skinIndices.push( new Vec4( a, b, c, d ) );

                }

            }

            geometry.bones = json.bones;
            geometry.animation = json.animation;

        };

        function parseMorphing ( scale ) {

            if ( json.morphTargets !== undefined ) {

                var i, l, v, vl, dstVertices, srcVertices;

                for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

                    geometry.morphTargets[ i ] = {};
                    geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
                    geometry.morphTargets[ i ].vertices = [];

                    dstVertices = geometry.morphTargets[ i ].vertices;
                    srcVertices = json.morphTargets [ i ].vertices;

                    for( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

                        var vertex = new Vec3();
                        vertex.x = srcVertices[ v ] * scale;
                        vertex.y = srcVertices[ v + 1 ] * scale;
                        vertex.z = srcVertices[ v + 2 ] * scale;

                        dstVertices.push( vertex );

                    }

                }

            }

            if ( json.morphColors !== undefined ) {

                var i, l, c, cl, dstColors, srcColors, color;

                for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

                    geometry.morphColors[ i ] = {};
                    geometry.morphColors[ i ].name = json.morphColors[ i ].name;
                    geometry.morphColors[ i ].colors = [];

                    dstColors = geometry.morphColors[ i ].colors;
                    srcColors = json.morphColors [ i ].colors;

                    for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

                        color = new Color( 0xffaa00 );
                        color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
                        dstColors.push( color );

                    }

                }

            }

        };

        if ( json.materials === undefined ) {

            return { geometry: geometry };

        } else {

            var materials = this.initMaterials( json.materials, texturePath );

            if ( this.needsTangents( materials ) ) {

                geometry.computeTangents();

            }

            return { geometry: geometry, materials: materials };

        }

    };

    if ( typeof JSONLoader === 'function' ) {
        var t = {}, p = {};
        for ( var i in JSONLoader ) t[i] = JSONLoader[i];
        for ( var i in JSONLoader.prototype ) try { p[i] = JSONLoader.prototype[i] } catch(e) {};
        scope.JSONLoader = JSONLoader.bind( scope );
    } else {
        scope.JSONLoader = JSONLoader;
    }
    scope.JSONLoader.prototype = JSONLoader.prototype;
    for ( var i in t ) scope.JSONLoader[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.JSONLoader.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__JSONLoader ) {
        for ( var i = 0, il = scope.__JSONLoader.length; i < il; i ++ ) scope.__JSONLoader[ i ]( JSONLoader );
        delete scope.__JSONLoader;
    }

}) ( NWE );


// src/loaders/PackLoader.js

( function ( scope ) {

    /*
     * @author ohmed
    */

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var XHRLoader = NWE.XHRLoader;
    if ( !XHRLoader ) { NWE.__XHRLoader = (NWE.__XHRLoader || []); NWE.__XHRLoader.push( function ( obj ) { XHRLoader = obj; } ); }

    var Pack = NWE.Pack;
    if ( !Pack ) { NWE.__Pack = (NWE.__Pack || []); NWE.__Pack.push( function ( obj ) { Pack = obj; } ); }


    var PackLoader = function () {};

    PackLoader.prototype = {

        constructor: PackLoader,

        load: function ( url, onLoad, onProgress, onError ) {

            var scope = this;

            var loader = new XHRLoader();
            loader.setBinaryLoading( true );
            loader.setCrossOrigin( this.crossOrigin );

            loader.load( url, function ( text , rawData ) {

                onLoad( scope.parse( rawData ) );

            } );

        },

        encode: function ( input ) {

            var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
                output = '',
                chr1, chr2, chr3, enc1, enc2, enc3, enc4,
                i = 0;

            while ( i < input.length ) {

                chr1 = input[ i ++ ];
                chr2 = input[ i ++ ];
                chr3 = input[ i ++ ];

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if ( isNaN(chr2) ) {

                    enc3 = enc4 = 64;

                } else if ( isNaN(chr3) ) {

                    enc4 = 64;

                }

                output += keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                          keyStr.charAt(enc3) + keyStr.charAt(enc4);

            }

            return output;

        },

        parse: function ( data ) {

            var decoder,
                info,

                i, il,
                g, m, t, s,

                rawData,
                pack;

            decoder = new JSZip();
            decoder.load( data.response );

            info = decoder.file('info.json').asText();
            info = JSON.parse( info );

            info.geometries = info.geometries || [];
            info.materials = info.materials || [];
            info.textures = info.textures || [];
            info.shaders = info.shaders || [];
            info.configs = info.configs || [];

            rawData = {

                geometries: {},
                materials: {},
                textures: {},
                shaders: {},
                configs: {}

            };

            // parse geos

            var buffer, attribute,
                offset, key,

                i, il, j, jl,
                frameData;

            for ( i = 0, il = info.geometries.length; i < il; i ++ ) {

                try {

                    g = info.geometries[ i ];

                    buffer = decoder.file('geometries/' + g.url + g.name + '.bin').asArrayBuffer();

                    rawData.geometries[ g.name ] = {

                        name: g.name,
                        vertices: g.vertices,
                        triangles: g.triangles,
                        textures: g.textures,
                        attributes: {},
                        animation: {
                            targets: []
                        }

                    };

                    // attributes

                    offset = 0;

                    for ( key in g.attributes ) {

                        attribute = g.attributes[ key ];

                        if ( key === 'index' ) {

                            attribute.size = 3 * g.triangles;

                        } else {

                            attribute.size = g.vertices;

                        }

                        rawData.geometries[ g.name ].attributes[ key ] = new NWE.gfx[ attribute.type ]( buffer, attribute.size, attribute.itemSize, offset );

                        offset += rawData.geometries[ g.name ].attributes[ key ].byteSize;

                    }

                    // animation

                    attribute = g.attributes[ 'position' ];

                    for ( j = 0, jl = g.animation.frames; j < jl; j ++ ) {

                        frameData = new NWE.gfx[ attribute.type ]( buffer, attribute.size, attribute.itemSize, offset );
                        offset += frameData.byteSize;

                        rawData.geometries[ g.name ].animation.targets.push( frameData );

                    }

                } catch ( e ) {

                    Logger.error( 'NWE.PackLoader.parse(): ' + g.name + ' geo has some problems.' );

                }

            }

            // parse materials

            for ( i = 0, il = info.materials.length; i < il; i ++ ) {

                m = info.materials[ i ];

                // todo

                rawData.materials[ m.name ] = {};

            }

            // parse shaders

            for ( i = 0, il = info.shaders.length; i < il; i ++ ) {

                try {

                    s = info.shaders[ i ];

                    rawData.shaders[ s.name ] = {

                        vertex:     decoder.file('shaders/' + s.url + s.name + '/vertex.glsl').asText(),
                        fragment:   decoder.file('shaders/' + s.url + s.name + '/fragment.glsl').asText(),
                        params:     JSON.parse( decoder.file('shaders/' + s.url + s.name + '/params.json').asText() )

                    };

                } catch ( e ) {

                    Logger.error( 'NWE.PackLoader.parse(): ' + s.name + ' shader has some problems.' );

                }

            }

            // parse textures

            var bytes, image;

            for ( i = 0, il = info.textures.length; i < il; i ++ ) {

                try {

                    t = info.textures[ i ];

                    buffer = decoder.file( 'textures/' + t.url ).asArrayBuffer();

                    var imageType = t.url.split('.').pop();

                    rawData.textures[ t.name ] = {};
                    rawData.textures[ t.name ].url = '/textures/' + t.url;

                    if ( imageType !== 'tga' && imageType !== 'dds' && imageType !== 'png' ) {

                        bytes = new Uint8Array( buffer );

                        image = new Image();
                        image.src = 'data:image/png;base64,' + this.encode( bytes );

                        rawData.textures[ t.name ].data = image;

                    } else {

                        rawData.textures[ t.name ].data = buffer;

                    }

                } catch ( e ) {

                    Logger.error( 'NWE.PackLoader.parse(): ' + t.name + ' image has some problems.' );

                }

            }

            // parse configfiles files

            for ( i = 0, il = info.configs.length; i < il; i ++ ) {

                try {

                    c = info.configs[ i ];

                    rawData.configs[ c.name ] = decoder.file('configs/' + c.url + c.name ).asText();

                } catch ( e ) {

                    Logger.error( 'NWE.PackLoader.parse(): ' + c.name + ' config file has some problems.' );

                }

            }

            //

            pack = new Pack( rawData );

            return pack;

        }

    };

    if ( typeof PackLoader === 'function' ) {
        var t = {}, p = {};
        for ( var i in PackLoader ) t[i] = PackLoader[i];
        for ( var i in PackLoader.prototype ) try { p[i] = PackLoader.prototype[i] } catch(e) {};
        scope.PackLoader = PackLoader.bind( scope );
    } else {
        scope.PackLoader = PackLoader;
    }
    scope.PackLoader.prototype = PackLoader.prototype;
    for ( var i in t ) scope.PackLoader[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.PackLoader.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__PackLoader ) {
        for ( var i = 0, il = scope.__PackLoader.length; i < il; i ++ ) scope.__PackLoader[ i ]( PackLoader );
        delete scope.__PackLoader;
    }

}) ( NWE );


// src/loaders/LoadingManager.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var DefaultLoadingManager = NWE.DefaultLoadingManager;
    if ( !DefaultLoadingManager ) { NWE.__DefaultLoadingManager = (NWE.__DefaultLoadingManager || []); NWE.__DefaultLoadingManager.push( function ( obj ) { DefaultLoadingManager = obj; } ); }


    var LoadingManager = function ( onLoad, onProgress, onError ) {

        var scope = this;

        var loaded = 0, total = 0;

        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;

        this.itemStart = function ( url ) {

            total ++;

        };

        this.itemEnd = function ( url ) {

            loaded ++;

            if ( scope.onProgress !== undefined ) {

                scope.onProgress( url, loaded, total );

            }

            if ( loaded === total && scope.onLoad !== undefined ) {

                scope.onLoad();

            }

        };

    };

    var DefaultLoadingManager = new LoadingManager(); // TODO: THINK

    if ( typeof LoadingManager === 'function' ) {
        var t = {}, p = {};
        for ( var i in LoadingManager ) t[i] = LoadingManager[i];
        for ( var i in LoadingManager.prototype ) try { p[i] = LoadingManager.prototype[i] } catch(e) {};
        scope.LoadingManager = LoadingManager.bind( scope );
    } else {
        scope.LoadingManager = LoadingManager;
    }
    scope.LoadingManager.prototype = LoadingManager.prototype;
    for ( var i in t ) scope.LoadingManager[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.LoadingManager.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__LoadingManager ) {
        for ( var i = 0, il = scope.__LoadingManager.length; i < il; i ++ ) scope.__LoadingManager[ i ]( LoadingManager );
        delete scope.__LoadingManager;
    }

    if ( typeof DefaultLoadingManager === 'function' ) {
        var t = {}, p = {};
        for ( var i in DefaultLoadingManager ) t[i] = DefaultLoadingManager[i];
        for ( var i in DefaultLoadingManager.prototype ) try { p[i] = DefaultLoadingManager.prototype[i] } catch(e) {};
        scope.DefaultLoadingManager = DefaultLoadingManager.bind( scope );
    } else {
        scope.DefaultLoadingManager = DefaultLoadingManager;
    }
    scope.DefaultLoadingManager.prototype = DefaultLoadingManager.prototype;
    for ( var i in t ) scope.DefaultLoadingManager[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DefaultLoadingManager.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DefaultLoadingManager ) {
        for ( var i = 0, il = scope.__DefaultLoadingManager.length; i < il; i ++ ) scope.__DefaultLoadingManager[ i ]( DefaultLoadingManager );
        delete scope.__DefaultLoadingManager;
    }

}) ( NWE );


// src/loaders/BufferGeometryLoader.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var DefaultLoadingManager = NWE.DefaultLoadingManager;
    if ( !DefaultLoadingManager ) { NWE.__DefaultLoadingManager = (NWE.__DefaultLoadingManager || []); NWE.__DefaultLoadingManager.push( function ( obj ) { DefaultLoadingManager = obj; } ); }

    var XHRLoader = NWE.XHRLoader;
    if ( !XHRLoader ) { NWE.__XHRLoader = (NWE.__XHRLoader || []); NWE.__XHRLoader.push( function ( obj ) { XHRLoader = obj; } ); }

    var BufferGeometry = NWE.gfx.BufferGeometry;
    if ( !BufferGeometry ) { NWE.gfx.__BufferGeometry = (NWE.gfx.__BufferGeometry || []); NWE.gfx.__BufferGeometry.push( function ( obj ) { BufferGeometry = obj; } ); }


    var BufferGeometryLoader = function ( manager ) {

        this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

    };

    BufferGeometryLoader.prototype = {

        constructor: BufferGeometryLoader,

        load: function ( url, onLoad, onProgress, onError ) {

            var scope = this;

            var loader = new XHRLoader();
            loader.setBinaryLoading( true );
            loader.setCrossOrigin( this.crossOrigin );
            loader.load( url, function ( text , rawData) {

                onLoad( scope.parse( rawData ) );

            } );

        },

        setCrossOrigin: function ( value ) {

            this.crossOrigin = value;

        },

        parse: function ( json ) {

            var geometry = new BufferGeometry();

            var attributes = json.attributes;

            for ( var key in attributes ) {

                var attribute = attributes[ key ];

                geometry.attributes[ key ] = {
                    itemSize: attribute.itemSize,
                    array: new self[ attribute.type ]( attribute.array )
                }

            }

            var offsets = json.offsets;

            if ( offsets !== undefined ) {

                geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

            }

            var boundingSphere = json.boundingSphere;

            if ( boundingSphere !== undefined ) {

                geometry.boundingSphere = new THREE.Sphere(
                    new THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),
                    boundingSphere.radius
                );

            }

            return geometry;

        }

    };

    if ( typeof BufferGeometryLoader === 'function' ) {
        var t = {}, p = {};
        for ( var i in BufferGeometryLoader ) t[i] = BufferGeometryLoader[i];
        for ( var i in BufferGeometryLoader.prototype ) try { p[i] = BufferGeometryLoader.prototype[i] } catch(e) {};
        scope.BufferGeometryLoader = BufferGeometryLoader.bind( scope );
    } else {
        scope.BufferGeometryLoader = BufferGeometryLoader;
    }
    scope.BufferGeometryLoader.prototype = BufferGeometryLoader.prototype;
    for ( var i in t ) scope.BufferGeometryLoader[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.BufferGeometryLoader.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__BufferGeometryLoader ) {
        for ( var i = 0, il = scope.__BufferGeometryLoader.length; i < il; i ++ ) scope.__BufferGeometryLoader[ i ]( BufferGeometryLoader );
        delete scope.__BufferGeometryLoader;
    }

}) ( NWE );


// src/loaders/GeometryLoader.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var DefaultLoadingManager = NWE.DefaultLoadingManager;
    if ( !DefaultLoadingManager ) { NWE.__DefaultLoadingManager = (NWE.__DefaultLoadingManager || []); NWE.__DefaultLoadingManager.push( function ( obj ) { DefaultLoadingManager = obj; } ); }

    var XHRLoader = NWE.XHRLoader;
    if ( !XHRLoader ) { NWE.__XHRLoader = (NWE.__XHRLoader || []); NWE.__XHRLoader.push( function ( obj ) { XHRLoader = obj; } ); }


    var GeometryLoader = function ( manager ) {

        this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

    };

    GeometryLoader.prototype = {

        constructor: GeometryLoader,

        load: function ( url, onLoad, onProgress, onError ) {

            var scope = this;

            var loader = new XHRLoader();
            loader.setCrossOrigin( this.crossOrigin );
            loader.load( url, function ( text ) {

                onLoad( scope.parse( JSON.parse( text ) ) );

            } );

        },

        setCrossOrigin: function ( value ) {

            this.crossOrigin = value;

        },

        parse: function ( json ) {

            

        }

    };

    if ( typeof GeometryLoader === 'function' ) {
        var t = {}, p = {};
        for ( var i in GeometryLoader ) t[i] = GeometryLoader[i];
        for ( var i in GeometryLoader.prototype ) try { p[i] = GeometryLoader.prototype[i] } catch(e) {};
        scope.GeometryLoader = GeometryLoader.bind( scope );
    } else {
        scope.GeometryLoader = GeometryLoader;
    }
    scope.GeometryLoader.prototype = GeometryLoader.prototype;
    for ( var i in t ) scope.GeometryLoader[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.GeometryLoader.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__GeometryLoader ) {
        for ( var i = 0, il = scope.__GeometryLoader.length; i < il; i ++ ) scope.__GeometryLoader[ i ]( GeometryLoader );
        delete scope.__GeometryLoader;
    }

}) ( NWE );


// src/loaders/TextureLoader.js

( function ( scope ) {

    /**
     * @author mrdoob / http://mrdoob.com/
     */



    var DefaultLoadingManager = NWE.DefaultLoadingManager;
    if ( !DefaultLoadingManager ) { NWE.__DefaultLoadingManager = (NWE.__DefaultLoadingManager || []); NWE.__DefaultLoadingManager.push( function ( obj ) { DefaultLoadingManager = obj; } ); }

    var ImageLoader = NWE.ImageLoader;
    if ( !ImageLoader ) { NWE.__ImageLoader = (NWE.__ImageLoader || []); NWE.__ImageLoader.push( function ( obj ) { ImageLoader = obj; } ); }

    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }

    var DataTexture = NWE.gfx.DataTexture;
    if ( !DataTexture ) { NWE.gfx.__DataTexture = (NWE.gfx.__DataTexture || []); NWE.gfx.__DataTexture.push( function ( obj ) { DataTexture = obj; } ); }

    var CompressedTexture = NWE.gfx.CompressedTexture;
    if ( !CompressedTexture ) { NWE.gfx.__CompressedTexture = (NWE.gfx.__CompressedTexture || []); NWE.gfx.__CompressedTexture.push( function ( obj ) { CompressedTexture = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var TextureLoader = function ( manager ) {

        this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

    };

    TextureLoader.prototype = {

        constructor: TextureLoader,

        load: function ( input, onLoad, onProgress, onError ) {

            var scope = this;

            var url = input.url || input;
            var buffer = input.data || null;

            var format = url.split('.').pop().toLowerCase(),
                texture;

            switch ( format ) {

                case 'png':
                case 'tga':

                    texture = new DataTexture();
                    texture.generateMipmaps = true;
                    texture.magFilter = Const.LinearFilter;
                    texture.minFilter = Const.LinearMipMapLinearFilter;
                    break;

                case 'dds':

                    texture = new CompressedTexture();
                    texture.generateMipmaps = false;
                    texture.needsUpdate = true;
                    break;

                case 'gif':
                case 'jpg':

                    texture = new Texture();
                    texture.image = {};

                    break;

                default:

                    return Logger.error( 'NWE.TextureLoader.load(): texture format `' + format + '` not supported.' );

            }

            var image = ImageLoader.load( input, function ( image ) {

                if ( texture.instanceof === 'Texture' ) {

                    texture.image = image;

                } else {

                    texture.image.width = image.width;
                    texture.image.height = image.height;
                    texture.image.data = image.data;
                    texture.mipmaps = image.mipmaps || [];
                    texture.format = image.ddsformat || texture.format;

                }

                if ( onLoad ) {

                    onLoad();

                }

            }, onProgress, onError );

            return texture;

        },

        setCrossOrigin: function ( value ) {

            this.crossOrigin = value;

        }

    };

    var TextureLoader = new TextureLoader();

    scope.TextureLoader = TextureLoader;
    if ( scope.__TextureLoader ) {
        for ( var i = 0, il = scope.__TextureLoader.length; i < il; i ++ ) scope.__TextureLoader[ i ]( TextureLoader );
        delete scope.__TextureLoader;
    }

}) ( NWE );


// src/graphics/extras/shaders/ShaderSprite.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var Sprite = function () {

        this.defines = {

        };

        this.attributes = {

            'position':  { type: 'v2', value: [] },
            'uv':        { type: 'v2', value: [] }

        };

        this.uniforms = {

            'rotation':     { type: 'f', value: 0 },
            'scale':        { type: 'fv', value: null, global: -1 },
            'opacity':      { type: 'f', value: 0 },

            'uvOffset':     { type: 'v2', value: null, global: -1 },
            'uvScale':      { type: 'v2', value: null, global: -1  },
            'offset':       { type: 'v3', value: null, global: -1  },

            'color':        { type: 'c', value: null },
            'map':          { type: 't', value: null, global: -1 },

            'alphaTest':    { type: 'f', value: 0 },

            'fogDensity':   { type: 'f', value: 0.00025, global: 2 },
            'fogNear':      { type: 'f', value: 1, global: 2 },
            'fogFar':       { type: 'f', value: 2000, global: 2 },
            'fogColor':     { type: 'c', value: null, global: 2 },

            'modelMatrix':      { type: 'm4', value: null, global: -1 },
            'modelViewMatrix':  { type: 'm4', value: null, global: -1 },
            'projectionMatrix': { type: 'm4', value: null, global: -1 },
            'viewMatrix':       { type: 'm4', value: null, global: -1 },
            'normalMatrix':     { type: 'm3', value: null, global: -1 },
            'cameraPosition':   { type: 'v3', value: null, global: -1 }

        };

        this.varyings = {

            'vUv':      { type: 'v2' }

        };

        this.vertexShader = {

            main: [
                'void main () {',

                '   vUv = uvOffset + uv * uvScale;',

                '   vec2 alignedPosition = position * scale;',

                '   vec2 rotatedPosition;',
                '   rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
                '   rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

                '   vec4 finalPosition;',

                '   finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
                '   finalPosition.xy += rotatedPosition;',
                '   finalPosition = projectionMatrix * ( finalPosition + vec4( offset, 0.0 ) );',

                '   gl_Position = finalPosition;',

                '}'
            ].join('\n')

        };

        this.fragmentShader = {

            main: [
                'void main () {',

                '   vec4 texture = texture2D( map, vUv );',

                '   if ( texture.a < alphaTest ) discard;',

                '   gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

                '   #ifdef USE_FOG',

                '       float depth = gl_FragCoord.z / gl_FragCoord.w;',
                '       float fogFactor = 0.0;',

                '       #ifdef FOG_EXP2',

                '           const float LOG2 = 1.442695;',
                '           fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
                '           fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

                '       #else',

                '           fogFactor = smoothstep( fogNear, fogFar, depth );',

                '       #endif',

                '       gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

                '   #endif',

                '}'
            ].join('\n')

        };

    };

    if ( typeof Sprite === 'function' ) {
        var t = {}, p = {};
        for ( var i in Sprite ) t[i] = Sprite[i];
        for ( var i in Sprite.prototype ) try { p[i] = Sprite.prototype[i] } catch(e) {};
        scope.Sprite = Sprite.bind( scope );
    } else {
        scope.Sprite = Sprite;
    }
    scope.Sprite.prototype = Sprite.prototype;
    for ( var i in t ) scope.Sprite[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Sprite.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Sprite ) {
        for ( var i = 0, il = scope.__Sprite.length; i < il; i ++ ) scope.__Sprite[ i ]( Sprite );
        delete scope.__Sprite;
    }

}) ( NWE.gfx.ShaderLib );


// src/graphics/extras/shaders/CopyShader.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author ohmed
     *
     * Full-screen textured quad shader
     */

    var CopyShader = function () {

        this.defines = {

        };

        this.uniforms = {

            'tDiffuse': { type: 't', value: null, global: -1 },
            'opacity':  { type: 'f', value: 1.0 },

            'modelMatrix':      { type: 'm4', value: null, global: -1 },
            'modelViewMatrix':  { type: 'm4', value: null, global: -1 },
            'projectionMatrix': { type: 'm4', value: null, global: -1 },
            'viewMatrix':       { type: 'm4', value: null, global: -1 },
            'normalMatrix':     { type: 'm3', value: null, global: -1 },
            'cameraPosition':   { type: 'v3', value: null, global: -1 }

        };

        this.attributes = {

            'position':  { type: 'v3', value: [] },
            'uv':        { type: 'v2', value: [] }

        };

        this.varyings = {

            'vUv': { type: 'v2' }

        };

        this.vertexShader = {

            main: [

                'void main () {',

                '   vUv = uv;',
                '   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            main: [

                'void main () {',

                '   vec4 texel = texture2D( tDiffuse, vUv );',
                '   gl_FragColor = opacity * texel;',

                '}'

            ].join('\n')

        };

    };

    if ( typeof CopyShader === 'function' ) {
        var t = {}, p = {};
        for ( var i in CopyShader ) t[i] = CopyShader[i];
        for ( var i in CopyShader.prototype ) try { p[i] = CopyShader.prototype[i] } catch(e) {};
        scope.CopyShader = CopyShader.bind( scope );
    } else {
        scope.CopyShader = CopyShader;
    }
    scope.CopyShader.prototype = CopyShader.prototype;
    for ( var i in t ) scope.CopyShader[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.CopyShader.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__CopyShader ) {
        for ( var i = 0, il = scope.__CopyShader.length; i < il; i ++ ) scope.__CopyShader[ i ]( CopyShader );
        delete scope.__CopyShader;
    }

}) ( NWE.gfx.ShaderLib );


// src/graphics/extras/shaders/BlendShader.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author ohmed
     *
     * Blend two textures
     */

    var BlendShader = function () {

        this.defines = {

        };

        this.uniforms = {

            'tDiffuse1': { type: 't', value: null, global: -1 },
            'tDiffuse2': { type: 't', value: null, global: -1 },
            'mixRatio':  { type: 'f', value: 0.5 },
            'opacity':   { type: 'f', value: 1.0 },

            'modelMatrix':      { type: 'm4', value: null, global: -1 },
            'modelViewMatrix':  { type: 'm4', value: null, global: -1 },
            'projectionMatrix': { type: 'm4', value: null, global: -1 },
            'viewMatrix':       { type: 'm4', value: null, global: -1 },
            'normalMatrix':     { type: 'm3', value: null, global: -1 },
            'cameraPosition':   { type: 'v3', value: null, global: -1 }

        };

        this.attributes = {

            'position':  { type: 'v3', value: [] },
            'uv':        { type: 'v2', value: [] }

        };

        this.varyings = {

            'vUv':  { type: 'v2' }

        };

        this.vertexShader = {

            main: [

                'void main () {',

                '   vUv = uv;',
                '   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            main: [

                'void main () {',

                '   vec4 texel1 = texture2D( tDiffuse1, vUv );',
                '   vec4 texel2 = texture2D( tDiffuse2, vUv );',
                '   gl_FragColor = opacity * mix( texel1, texel2, mixRatio );',

                '}'

            ].join('\n')

        };

    };

    if ( typeof BlendShader === 'function' ) {
        var t = {}, p = {};
        for ( var i in BlendShader ) t[i] = BlendShader[i];
        for ( var i in BlendShader.prototype ) try { p[i] = BlendShader.prototype[i] } catch(e) {};
        scope.BlendShader = BlendShader.bind( scope );
    } else {
        scope.BlendShader = BlendShader;
    }
    scope.BlendShader.prototype = BlendShader.prototype;
    for ( var i in t ) scope.BlendShader[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.BlendShader.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__BlendShader ) {
        for ( var i = 0, il = scope.__BlendShader.length; i < il; i ++ ) scope.__BlendShader[ i ]( BlendShader );
        delete scope.__BlendShader;
    }

}) ( NWE.gfx.ShaderLib );


// src/graphics/extras/shaders/FXAAShader.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author davidedc / http://www.sketchpatch.net/
     * @author ohmed
     *
     * NVIDIA FXAA by Timothy Lottes
     * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
     * - WebGL port by @supereggbert
     * http://www.glge.org/demos/fxaa/
     */

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }


    var FXAAShader = function () {

        this.defines = {

            'FXAA_REDUCE_MIN':   1.0 / 128.0,
            'FXAA_REDUCE_MUL':   1.0 / 8.0,
            'FXAA_SPAN_MAX':     8.0,

        };

        this.attributes = {

            'position':  { type: 'v3', value: [] },
            'uv':        { type: 'v2', value: [] }

        };

        this.uniforms = {

            'tDiffuse':   { type: 't', value: null, global: -1 },
            'resolution': { type: 'v2', value: new Vec2( 1 / 1024, 1 / 512 ) },

            'modelMatrix':      { type: 'm4', value: null, global: -1 },
            'modelViewMatrix':  { type: 'm4', value: null, global: -1 },
            'projectionMatrix': { type: 'm4', value: null, global: -1 },
            'viewMatrix':       { type: 'm4', value: null, global: -1 },
            'normalMatrix':     { type: 'm3', value: null, global: -1 },
            'cameraPosition':   { type: 'v3', value: null, global: -1 }

        };

        this.varyings = {

            'vUv':  { type: 'v2' }

        };

        this.vertexShader = {

            main: [

                'void main () {',

                '   vUv = uv;',
                '   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            main: [

                'void main () {',

                '   vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;',
                '   vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;',
                '   vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;',
                '   vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;',
                '   vec4 rgbaM = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );',
                '   vec3 rgbM  = rgbaM.xyz;',

                '   float opacity = rgbaM.w;',

                '   vec3 luma = vec3( 0.299, 0.587, 0.114 );',

                '   float lumaNW = dot( rgbNW, luma );',
                '   float lumaNE = dot( rgbNE, luma );',
                '   float lumaSW = dot( rgbSW, luma );',
                '   float lumaSE = dot( rgbSE, luma );',
                '   float lumaM  = dot( rgbM,  luma );',
                '   float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );',
                '   float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );',

                '   vec2 dir;',
                '   dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));',
                '   dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));',

                '   float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );',

                '   float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );',
                '   dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX), max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * resolution;',

                '   vec3 rgbA = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz;',
                '   rgbA += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz;',
                '   rgbA *= 0.5;',

                '   vec3 rgbB = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz;',
                '   rgbB += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz;',
                '   rgbB *= 0.25;',
                '   rgbB += rgbA * 0.5;',

                '   float lumaB = dot( rgbB, luma );',

                '   if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {',

                '       gl_FragColor = vec4( rgbA, opacity );',

                '   } else {',

                '       gl_FragColor = vec4( rgbB, opacity );',

                '   }',

                '}'

            ].join('\n')

        };

    };

    if ( typeof FXAAShader === 'function' ) {
        var t = {}, p = {};
        for ( var i in FXAAShader ) t[i] = FXAAShader[i];
        for ( var i in FXAAShader.prototype ) try { p[i] = FXAAShader.prototype[i] } catch(e) {};
        scope.FXAAShader = FXAAShader.bind( scope );
    } else {
        scope.FXAAShader = FXAAShader;
    }
    scope.FXAAShader.prototype = FXAAShader.prototype;
    for ( var i in t ) scope.FXAAShader[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.FXAAShader.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__FXAAShader ) {
        for ( var i = 0, il = scope.__FXAAShader.length; i < il; i ++ ) scope.__FXAAShader[ i ]( FXAAShader );
        delete scope.__FXAAShader;
    }

}) ( NWE.gfx.ShaderLib );


// src/graphics/extras/shaders/SSAOShader.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }


    var SSAOShader = function () {

        this.defines = {

            'DL':       2.399963229728653,
            'EULER':    2.718281828459045

        };

        this.attributes = {

            'position':  { type: 'v3', value: [] },
            'uv':        { type: 'v2', value: [] }

        };

        this.uniforms = {

            'tDiffuse':     { type: 't', value: null, global: -1 },
            'tDepth':       { type: 't', value: null, global: -1 },
            'size':         { type: 'v2', value: new Vec2( 512, 512 ), global: -1 },
            'cameraNear':   { type: 'f', value: 1, global: -1 },
            'cameraFar':    { type: 'f', value: 100, global: -1 },
            'aoClamp':      { type: 'f', value: 0.5, global: -1 },
            'lumInfluence': { type: 'f', value: 0.5, global: -1 },

            'modelMatrix':      { type: 'm4', value: null, global: -1 },
            'modelViewMatrix':  { type: 'm4', value: null, global: -1 },
            'projectionMatrix': { type: 'm4', value: null, global: -1 },
            'viewMatrix':       { type: 'm4', value: null, global: -1 },
            'normalMatrix':     { type: 'm3', value: null, global: -1 },
            'cameraPosition':   { type: 'v3', value: null, global: -1 }

        };

        this.varyings = {

            'vUv':  { type: 'v2' }

        };

        this.vertexShader = {

            main: [

                'void main () {',

                '    vUv = uv;',

                '    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            unpackDepth: [

                '// helpers',

                'float width = size.x;   // texture width',
                'float height = size.y;  // texture height',

                'float cameraFarPlusNear = cameraFar + cameraNear;',
                'float cameraFarMinusNear = cameraFar - cameraNear;',
                'float cameraCoef = 2.0 * cameraNear;',

                '// user variables',

                'const int samples = 8;     // ao sample count',
                'const float radius = 5.0;  // ao radius',

                'const bool useNoise = false;      // use noise instead of pattern for sample dithering',
                'const float noiseAmount = 0.0003; // dithering amount',

                'const float diffArea = 0.4;   // self-shadowing reduction',
                'const float gDisplace = 0.4;  // gauss bell center',

                '// RGBA depth',

                'float unpackDepth ( const in vec4 rgba_depth ) {',

                '    const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );',
                '    float depth = dot( rgba_depth, bit_shift );',
                '    return depth;',

                '}'

            ].join('\n'),

            rand: [

                '// generating noise / pattern texture for dithering',

                'vec2 rand ( const vec2 coord ) {',

                '    vec2 noise;',

                '    if ( useNoise ) {',

                '        float nx = dot ( coord, vec2( 12.9898, 78.233 ) );',
                '        float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );',

                '        noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );',

                '    } else {',

                '        float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );',
                '        float gg = fract( coord.t * ( height / 2.0 ) );',

                '        noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;',

                '    }',

                '    return ( noise * 2.0  - 1.0 ) * noiseAmount;',

                '}'

            ].join('\n'),

            readDepth: [

                'float readDepth ( const in vec2 coord ) {',

                '    // return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );',
                '    return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );',

                '}'

            ].join('\n'),

            compareDepths: [

                'float compareDepths ( const in float depth1, const in float depth2, inout int far ) {',

                '    float garea = 2.0;                         // gauss bell width',
                '    float diff = ( depth1 - depth2 ) * 100.0;  // depth difference (0-100)',

                '    // reduce left bell width to avoid self-shadowing',

                '    if ( diff < gDisplace ) {',

                '        garea = diffArea;',

                '    } else {',

                '        far = 1;',

                '    }',

                '    float dd = diff - gDisplace;',
                '    float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );',
                '    return gauss;',

                '}'

            ].join('\n'),

            calcAO: [

                'float calcAO ( float depth, float dw, float dh ) {',

                '    float dd = radius - depth * radius;',
                '    vec2 vv = vec2( dw, dh );',

                '    vec2 coord1 = vUv + dd * vv;',
                '    vec2 coord2 = vUv - dd * vv;',

                '    float temp1 = 0.0;',
                '    float temp2 = 0.0;',

                '    int far = 0;',
                '    temp1 = compareDepths( depth, readDepth( coord1 ), far );',

                '    // DEPTH EXTRAPOLATION',

                '    if ( far > 0 ) {',

                '        temp2 = compareDepths( readDepth( coord2 ), depth, far );',
                '        temp1 += ( 1.0 - temp1 ) * temp2;',

                '    }',

                '    return temp1;',

                '}'

            ].join('\n'),

            main: [

                'void main () {',

                '    vec2 noise = rand( vUv );',
                '    float depth = readDepth( vUv );',

                '    float tt = clamp( depth, aoClamp, 1.0 );',

                '    float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );',
                '    float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );',

                '    float ao = 0.0;',

                '    float dz = 1.0 / float( samples );',
                '    float z = 1.0 - dz / 2.0;',
                '    float l = 0.0;',

                '    for ( int i = 0; i <= samples; i ++ ) {',

                '        float r = sqrt( 1.0 - z );',

                '        float pw = cos( l ) * r;',
                '        float ph = sin( l ) * r;',
                '        ao += calcAO( depth, pw * w, ph * h );',
                '        z = z - dz;',
                '        l = l + DL;',

                '    }',

                '    ao /= float( samples );',
                '    ao = 1.0 - ao;',

                '    vec3 color = texture2D( tDiffuse, vUv ).rgb;',

                '    vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );',
                '    float lum = dot( color.rgb, lumcoeff );',
                '    vec3 luminance = vec3( lum );',

                '    vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );  // mix( color * ao, white, luminance )',

                '    gl_FragColor = vec4( final, 1.0 );',

                '}'

            ].join('\n')

        };

    };

    if ( typeof SSAOShader === 'function' ) {
        var t = {}, p = {};
        for ( var i in SSAOShader ) t[i] = SSAOShader[i];
        for ( var i in SSAOShader.prototype ) try { p[i] = SSAOShader.prototype[i] } catch(e) {};
        scope.SSAOShader = SSAOShader.bind( scope );
    } else {
        scope.SSAOShader = SSAOShader;
    }
    scope.SSAOShader.prototype = SSAOShader.prototype;
    for ( var i in t ) scope.SSAOShader[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.SSAOShader.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__SSAOShader ) {
        for ( var i = 0, il = scope.__SSAOShader.length; i < il; i ++ ) scope.__SSAOShader[ i ]( SSAOShader );
        delete scope.__SSAOShader;
    }

}) ( NWE.gfx.ShaderLib );


// src/graphics/extras/postprocessing/EffectComposer.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author ohmed
     */

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var CopyShader = NWE.gfx.ShaderLib.CopyShader;
    if ( !CopyShader ) { NWE.gfx.ShaderLib.__CopyShader = (NWE.gfx.ShaderLib.__CopyShader || []); NWE.gfx.ShaderLib.__CopyShader.push( function ( obj ) { CopyShader = obj; } ); }

    var ShaderPass = NWE.gfx.ShaderPass;
    if ( !ShaderPass ) { NWE.gfx.__ShaderPass = (NWE.gfx.__ShaderPass || []); NWE.gfx.__ShaderPass.push( function ( obj ) { ShaderPass = obj; } ); }

    var ClearMaskPass = NWE.gfx.ClearMaskPass;
    if ( !ClearMaskPass ) { NWE.gfx.__ClearMaskPass = (NWE.gfx.__ClearMaskPass || []); NWE.gfx.__ClearMaskPass.push( function ( obj ) { ClearMaskPass = obj; } ); }

    var MaskPass = NWE.gfx.MaskPass;
    if ( !MaskPass ) { NWE.gfx.__MaskPass = (NWE.gfx.__MaskPass || []); NWE.gfx.__MaskPass.push( function ( obj ) { MaskPass = obj; } ); }


    var Scene = NWE.gfx.Scene;
    if ( !Scene ) { NWE.gfx.__Scene = (NWE.gfx.__Scene || []); NWE.gfx.__Scene.push( function ( obj ) { Scene = obj; } ); }

    var OrthographicCamera = NWE.gfx.OrthographicCamera;
    if ( !OrthographicCamera ) { NWE.gfx.__OrthographicCamera = (NWE.gfx.__OrthographicCamera || []); NWE.gfx.__OrthographicCamera.push( function ( obj ) { OrthographicCamera = obj; } ); }

    var Mesh = NWE.gfx.Mesh;
    if ( !Mesh ) { NWE.gfx.__Mesh = (NWE.gfx.__Mesh || []); NWE.gfx.__Mesh.push( function ( obj ) { Mesh = obj; } ); }

    var PlaneGeometry = NWE.gfx.PlaneGeometry;
    if ( !PlaneGeometry ) { NWE.gfx.__PlaneGeometry = (NWE.gfx.__PlaneGeometry || []); NWE.gfx.__PlaneGeometry.push( function ( obj ) { PlaneGeometry = obj; } ); }

    var WebGLRenderTarget = NWE.gfx.WebGLRenderTarget;
    if ( !WebGLRenderTarget ) { NWE.gfx.__WebGLRenderTarget = (NWE.gfx.__WebGLRenderTarget || []); NWE.gfx.__WebGLRenderTarget.push( function ( obj ) { WebGLRenderTarget = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var EffectComposer = function ( renderer, renderTarget, alpha ) {

        this.renderer = renderer;
        this.lastPath = false;

        if ( ! renderTarget ) {

            var width = window.innerWidth || 1;
            var height = window.innerHeight || 1;
            var parameters = { minFilter: Const.LinearFilter, magFilter: Const.LinearFilter, format: Const.RGBFormat, stencilBuffer: false };

            if ( alpha ) {

                parameters.format = Const.RGBAFormat;

            }

            renderTarget = new WebGLRenderTarget( width, height, parameters );

        }

        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();

        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;

        this.passes = [];

        CopyShader = new CopyShader();

        if ( CopyShader === undefined ) {

            Logger.error( 'NWE.gfx.EffectComposer: relies on NWE.gfx.ShaderLib.CopyShader' );

        }

        this.copyPass = new ShaderPass( CopyShader );

    };

    EffectComposer.camera = null;
    EffectComposer.quad = null;
    EffectComposer.scene = null;

    EffectComposer.prototype = {

        swapBuffers: function () {

            var tmp = this.readBuffer;
            this.readBuffer = this.writeBuffer;
            this.writeBuffer = tmp;

        },

        setPassToScreen: function ( pass ) {

            for ( var i = 0, il = this.passes.length; i < il; i ++ ) {

                this.passes[ i ].renderToScreen = false;

            }

            pass.renderToScreen = true;

        },

        setLastPassToScreen: function () {

            var i = this.passes.length - 1;

            while ( i >= 0 && ! this.passes[ i ].enabled ) {

                i --;

            }

            this.setPassToScreen( this.passes[ i ] );

        },

        addPass: function ( pass ) {

            if ( pass.setSize ) {

                pass.setSize( this.width, this.height );

            }

            this.passes.push( pass );

            this.setPassToScreen( pass );

        },

        insertPass: function ( pass, index ) {

            this.passes.splice( index, 0, pass );

        },

        render: function ( delta ) {

            this.writeBuffer = this.renderTarget1;
            this.readBuffer = this.renderTarget2;

            var maskActive = false;

            var pass, i, il = this.passes.length;

            for ( i = 0; i < il; i ++ ) {

                pass = this.passes[ i ];

                if ( ! pass.enabled ) continue;

                pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

                if ( pass.needsSwap ) {

                    if ( maskActive ) {

                        var context = this.renderer.context;

                        context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

                        this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, true );

                        context.stencilFunc( context.EQUAL, 1, 0xffffffff );

                    }

                    this.swapBuffers();

                }

                if ( pass instanceof MaskPass ) {

                    maskActive = true;

                } else if ( pass instanceof ClearMaskPass ) {

                    maskActive = false;

                }

            }

        },

        reset: function ( renderTarget ) {

            if ( renderTarget === undefined ) {

                renderTarget = this.renderTarget1.clone();

                renderTarget.width = window.innerWidth;
                renderTarget.height = window.innerHeight;

            }

            this.renderTarget1 = renderTarget;
            this.renderTarget2 = renderTarget.clone();

            this.writeBuffer = this.renderTarget1;
            this.readBuffer = this.renderTarget2;

        },

        setSize: function ( width, height ) {

            this.width = width;
            this.height = height;

            width = width * window.devicePixelRatio;
            height = height * window.devicePixelRatio;

            var renderTarget = this.renderTarget1.clone();

            renderTarget.width = width;
            renderTarget.height = height;

            this.reset( renderTarget );

            for ( var i = 0, il = this.passes.length; i < il; i ++ ) {

                if ( this.passes[i].uniforms ) {

                    var screenSize = this.passes[i].uniforms[ 'screenSize' ];
                    var resolution = this.passes[i].uniforms[ 'resolution' ];

                    if ( screenSize ) {

                        screenSize.value.set( width, height );
                        screenSize.needsUpdate = true;

                    }

                    if ( resolution ) {

                        resolution.value.set( 1 / width, 1 / height );
                        resolution.needsUpdate = true;

                    }

                }

            }

        }

    };

    EffectComposer.init = function () {

        this.camera = new OrthographicCamera( -1, 1, 1, -1, 0, 1 );

        this.quad = new Mesh( new PlaneGeometry( 2, 2 ), null );

        this.scene = new Scene();
        this.scene.add( this.quad );

    };

    if ( typeof EffectComposer === 'function' ) {
        var t = {}, p = {};
        for ( var i in EffectComposer ) t[i] = EffectComposer[i];
        for ( var i in EffectComposer.prototype ) try { p[i] = EffectComposer.prototype[i] } catch(e) {};
        scope.EffectComposer = EffectComposer.bind( scope );
    } else {
        scope.EffectComposer = EffectComposer;
    }
    scope.EffectComposer.prototype = EffectComposer.prototype;
    for ( var i in t ) scope.EffectComposer[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.EffectComposer.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__EffectComposer ) {
        for ( var i = 0, il = scope.__EffectComposer.length; i < il; i ++ ) scope.__EffectComposer[ i ]( EffectComposer );
        delete scope.__EffectComposer;
    }

}) ( NWE.gfx );


// src/graphics/extras/postprocessing/MaskPass.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var MaskPass = function ( scene, camera ) {

        this.scene = scene;
        this.camera = camera;

        this.enabled = true;
        this.clear = true;
        this.needsSwap = false;

        this.inverse = false;

    };

    MaskPass.prototype = {

        render: function ( renderer, writeBuffer, readBuffer, delta ) {

            var context = renderer.context;

            // don't update color or depth

            context.colorMask( false, false, false, false );
            context.depthMask( false );

            // set up stencil

            var writeValue, clearValue;

            if ( this.inverse ) {

                writeValue = 0;
                clearValue = 1;

            } else {

                writeValue = 1;
                clearValue = 0;

            }

            context.enable( context.STENCIL_TEST );
            context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
            context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
            context.clearStencil( clearValue );

            // draw into the stencil buffer

            renderer.render( this.scene, this.camera, readBuffer, this.clear, true );
            renderer.render( this.scene, this.camera, writeBuffer, this.clear, true );

            // re-enable update of color and depth

            context.colorMask( true, true, true, true );
            context.depthMask( true );

            // only render where stencil is set to 1

            context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
            context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

        }

    };

    //

    var ClearMaskPass = function () {

        this.enabled = true;

    };

    ClearMaskPass.prototype = {

        render: function ( renderer, writeBuffer, readBuffer, delta ) {

            var context = renderer.context;

            context.disable( context.STENCIL_TEST );

        }

    };

    if ( typeof MaskPass === 'function' ) {
        var t = {}, p = {};
        for ( var i in MaskPass ) t[i] = MaskPass[i];
        for ( var i in MaskPass.prototype ) try { p[i] = MaskPass.prototype[i] } catch(e) {};
        scope.MaskPass = MaskPass.bind( scope );
    } else {
        scope.MaskPass = MaskPass;
    }
    scope.MaskPass.prototype = MaskPass.prototype;
    for ( var i in t ) scope.MaskPass[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.MaskPass.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__MaskPass ) {
        for ( var i = 0, il = scope.__MaskPass.length; i < il; i ++ ) scope.__MaskPass[ i ]( MaskPass );
        delete scope.__MaskPass;
    }

    if ( typeof ClearMaskPass === 'function' ) {
        var t = {}, p = {};
        for ( var i in ClearMaskPass ) t[i] = ClearMaskPass[i];
        for ( var i in ClearMaskPass.prototype ) try { p[i] = ClearMaskPass.prototype[i] } catch(e) {};
        scope.ClearMaskPass = ClearMaskPass.bind( scope );
    } else {
        scope.ClearMaskPass = ClearMaskPass;
    }
    scope.ClearMaskPass.prototype = ClearMaskPass.prototype;
    for ( var i in t ) scope.ClearMaskPass[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.ClearMaskPass.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__ClearMaskPass ) {
        for ( var i = 0, il = scope.__ClearMaskPass.length; i < il; i ++ ) scope.__ClearMaskPass[ i ]( ClearMaskPass );
        delete scope.__ClearMaskPass;
    }

}) ( NWE.gfx );


// src/graphics/extras/postprocessing/RenderPass.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var EffectComposer = NWE.gfx.EffectComposer;
    if ( !EffectComposer ) { NWE.gfx.__EffectComposer = (NWE.gfx.__EffectComposer || []); NWE.gfx.__EffectComposer.push( function ( obj ) { EffectComposer = obj; } ); }


    var RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

        this.scene = scene;
        this.camera = camera;

        this.overrideMaterial = overrideMaterial;

        this.clearColor = clearColor;
        this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

        this.oldClearColor = new Color();
        this.oldClearAlpha = 1;

        this.renderToScreen = false;

        this.enabled = true;
        this.clear = true;
        this.needsSwap = false;

    };

    RenderPass.prototype = {

        render: function ( renderer, writeBuffer, readBuffer, delta ) {

            this.scene.overrideMaterial = this.overrideMaterial;

            if ( this.clearColor ) {

                this.oldClearColor.copy( renderer.getClearColor() );
                this.oldClearAlpha = renderer.getClearAlpha();

                renderer.setClearColor( this.clearColor, this.clearAlpha );

            }

            if ( this.renderToScreen ) {

                renderer.render( this.scene, this.camera );

            } else {

                renderer.render( this.scene, this.camera, readBuffer, this.clear );

            }

            if ( this.clearColor ) {

                renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

            }

            this.scene.overrideMaterial = null;

        }

    };

    if ( typeof RenderPass === 'function' ) {
        var t = {}, p = {};
        for ( var i in RenderPass ) t[i] = RenderPass[i];
        for ( var i in RenderPass.prototype ) try { p[i] = RenderPass.prototype[i] } catch(e) {};
        scope.RenderPass = RenderPass.bind( scope );
    } else {
        scope.RenderPass = RenderPass;
    }
    scope.RenderPass.prototype = RenderPass.prototype;
    for ( var i in t ) scope.RenderPass[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.RenderPass.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__RenderPass ) {
        for ( var i = 0, il = scope.__RenderPass.length; i < il; i ++ ) scope.__RenderPass[ i ]( RenderPass );
        delete scope.__RenderPass;
    }

}) ( NWE.gfx );


// src/graphics/extras/postprocessing/SavePass.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var CopyShader = NWE.gfx.ShaderLib.CopyShader;
    if ( !CopyShader ) { NWE.gfx.ShaderLib.__CopyShader = (NWE.gfx.ShaderLib.__CopyShader || []); NWE.gfx.ShaderLib.__CopyShader.push( function ( obj ) { CopyShader = obj; } ); }

    var UniformUtils = NWE.gfx.UniformUtils;
    if ( !UniformUtils ) { NWE.gfx.__UniformUtils = (NWE.gfx.__UniformUtils || []); NWE.gfx.__UniformUtils.push( function ( obj ) { UniformUtils = obj; } ); }

    var ShaderMaterial = NWE.gfx.ShaderMaterial;
    if ( !ShaderMaterial ) { NWE.gfx.__ShaderMaterial = (NWE.gfx.__ShaderMaterial || []); NWE.gfx.__ShaderMaterial.push( function ( obj ) { ShaderMaterial = obj; } ); }

    var WebGLRenderTarget = NWE.gfx.WebGLRenderTarget;
    if ( !WebGLRenderTarget ) { NWE.gfx.__WebGLRenderTarget = (NWE.gfx.__WebGLRenderTarget || []); NWE.gfx.__WebGLRenderTarget.push( function ( obj ) { WebGLRenderTarget = obj; } ); }

    var EffectComposer = NWE.gfx.EffectComposer;
    if ( !EffectComposer ) { NWE.gfx.__EffectComposer = (NWE.gfx.__EffectComposer || []); NWE.gfx.__EffectComposer.push( function ( obj ) { EffectComposer = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var SavePass = function ( renderTarget ) {

        CopyShader = new CopyShader();

        if ( CopyShader === undefined ) {

            Logger.error( 'NWE.gfx.SavePass: relies on NWE.gfx.ShaderLib.CopyShader' );

        }

        var shader = CopyShader;

        this.textureID = 'tDiffuse';

        this.uniforms = UniformUtils.clone( shader.uniforms );

        this.material = new ShaderMaterial( {

            defines: shader.defines,
            uniforms: this.uniforms,
            attributes: shader.attributes,
            varyings: shader.varyings,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader

        } );

        this.renderTarget = renderTarget;

        if ( this.renderTarget === undefined ) {

            this.renderTargetParameters = { minFilter: Const.LinearFilter, magFilter: Const.LinearFilter, format: Const.RGBFormat, stencilBuffer: false };
            this.renderTarget = new WebGLRenderTarget( window.innerWidth, window.innerHeight, this.renderTargetParameters );

        }

        this.renderToScreen = false;

        this.enabled = true;
        this.needsSwap = false;
        this.clear = false;

    };

    SavePass.prototype = {

        render: function ( renderer, writeBuffer, readBuffer, delta ) {

            if ( this.uniforms[ this.textureID ] ) {

                this.uniforms[ this.textureID ].value = readBuffer;

            }

            EffectComposer.quad.material = this.material;

            if ( this.renderToScreen ) {

                renderer.render( EffectComposer.scene, EffectComposer.camera, null, null, true );

            } else {

                renderer.render( EffectComposer.scene, EffectComposer.camera, this.renderTarget, this.clear, true );

            }

        }

    };

    if ( typeof SavePass === 'function' ) {
        var t = {}, p = {};
        for ( var i in SavePass ) t[i] = SavePass[i];
        for ( var i in SavePass.prototype ) try { p[i] = SavePass.prototype[i] } catch(e) {};
        scope.SavePass = SavePass.bind( scope );
    } else {
        scope.SavePass = SavePass;
    }
    scope.SavePass.prototype = SavePass.prototype;
    for ( var i in t ) scope.SavePass[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.SavePass.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__SavePass ) {
        for ( var i = 0, il = scope.__SavePass.length; i < il; i ++ ) scope.__SavePass[ i ]( SavePass );
        delete scope.__SavePass;
    }

}) ( NWE.gfx );


// src/graphics/extras/postprocessing/ShaderPass.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var UniformUtils = NWE.gfx.UniformUtils;
    if ( !UniformUtils ) { NWE.gfx.__UniformUtils = (NWE.gfx.__UniformUtils || []); NWE.gfx.__UniformUtils.push( function ( obj ) { UniformUtils = obj; } ); }

    var ShaderMaterial = NWE.gfx.ShaderMaterial;
    if ( !ShaderMaterial ) { NWE.gfx.__ShaderMaterial = (NWE.gfx.__ShaderMaterial || []); NWE.gfx.__ShaderMaterial.push( function ( obj ) { ShaderMaterial = obj; } ); }

    var EffectComposer = NWE.gfx.EffectComposer;
    if ( !EffectComposer ) { NWE.gfx.__EffectComposer = (NWE.gfx.__EffectComposer || []); NWE.gfx.__EffectComposer.push( function ( obj ) { EffectComposer = obj; } ); }


    var ShaderPass = function ( shader, textureID ) {

        this.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';

        this.uniforms = shader.uniforms;

        this.material = new ShaderMaterial( {

            defines: shader.defines,
            uniforms: this.uniforms,
            attributes: shader.attributes,
            varyings: shader.varyings,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader

        } );

        this.renderToScreen = false;

        this.enabled = true;
        this.needsSwap = true;
        this.clear = false;

    };

    ShaderPass.prototype = {

        setSize: function ( width, height ) {

            width = width * window.devicePixelRatio;
            height = height * window.devicePixelRatio;

            var screenSize = this.uniforms[ 'screenSize' ];
            var resolution = this.uniforms[ 'resolution' ];

            if ( screenSize ) {

                screenSize.value.set( width, height );
                screenSize.needsUpdate = true;

            }

            if ( resolution ) {

                resolution.value.set( 1 / width, 1 / height );
                resolution.needsUpdate = true;

            }

        },

        render: function ( renderer, writeBuffer, readBuffer, delta ) {

            if ( this.uniforms[ this.textureID ] ) {

                this.uniforms[ this.textureID ].value = readBuffer;

            }

            EffectComposer.quad.material = this.material;

            if ( this.renderToScreen ) {

                renderer.render( EffectComposer.scene, EffectComposer.camera, null, null, true );

            } else {

                renderer.render( EffectComposer.scene, EffectComposer.camera, writeBuffer, this.clear, true );

            }

        }

    };

    if ( typeof ShaderPass === 'function' ) {
        var t = {}, p = {};
        for ( var i in ShaderPass ) t[i] = ShaderPass[i];
        for ( var i in ShaderPass.prototype ) try { p[i] = ShaderPass.prototype[i] } catch(e) {};
        scope.ShaderPass = ShaderPass.bind( scope );
    } else {
        scope.ShaderPass = ShaderPass;
    }
    scope.ShaderPass.prototype = ShaderPass.prototype;
    for ( var i in t ) scope.ShaderPass[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.ShaderPass.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__ShaderPass ) {
        for ( var i = 0, il = scope.__ShaderPass.length; i < il; i ++ ) scope.__ShaderPass[ i ]( ShaderPass );
        delete scope.__ShaderPass;
    }

}) ( NWE.gfx );


// src/graphics/extras/postprocessing/TexturePass.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var CopyShader = NWE.gfx.ShaderLib.CopyShader;
    if ( !CopyShader ) { NWE.gfx.ShaderLib.__CopyShader = (NWE.gfx.ShaderLib.__CopyShader || []); NWE.gfx.ShaderLib.__CopyShader.push( function ( obj ) { CopyShader = obj; } ); }

    var UniformUtils = NWE.gfx.UniformUtils;
    if ( !UniformUtils ) { NWE.gfx.__UniformUtils = (NWE.gfx.__UniformUtils || []); NWE.gfx.__UniformUtils.push( function ( obj ) { UniformUtils = obj; } ); }

    var ShaderMaterial = NWE.gfx.ShaderMaterial;
    if ( !ShaderMaterial ) { NWE.gfx.__ShaderMaterial = (NWE.gfx.__ShaderMaterial || []); NWE.gfx.__ShaderMaterial.push( function ( obj ) { ShaderMaterial = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var EffectComposer = NWE.gfx.EffectComposer;
    if ( !EffectComposer ) { NWE.gfx.__EffectComposer = (NWE.gfx.__EffectComposer || []); NWE.gfx.__EffectComposer.push( function ( obj ) { EffectComposer = obj; } ); }


    var TexturePass = function ( texture, opacity ) {

        CopyShader = new CopyShader();

        if ( CopyShader === undefined ) {

            Logger.error( 'NWE.gfx.TexturePass: relies on NWE.gfx.ShaderLib.CopyShader' );

        }

        var shader = CopyShader;

        this.uniforms = shader.uniforms;

        this.uniforms[ 'opacity' ].value = ( opacity !== undefined ) ? opacity : 1.0;
        this.uniforms[ 'tDiffuse' ].value = texture;

        this.material = new ShaderMaterial( {

            defines: shader.defines,
            uniforms: this.uniforms,
            attributes: shader.attributes,
            varyings: shader.varyings,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader

        } );

        this.enabled = true;
        this.needsSwap = false;

    };

    TexturePass.prototype = {

        render: function ( renderer, writeBuffer, readBuffer, delta ) {

            EffectComposer.quad.material = this.material;

            if ( this.renderToScreen ) {

                renderer.render( EffectComposer.scene, EffectComposer.camera, null, null, true );

            } else {

                renderer.render( EffectComposer.scene, EffectComposer.camera, readBuffer, this.clear, true );

            }

        }

    };

    if ( typeof TexturePass === 'function' ) {
        var t = {}, p = {};
        for ( var i in TexturePass ) t[i] = TexturePass[i];
        for ( var i in TexturePass.prototype ) try { p[i] = TexturePass.prototype[i] } catch(e) {};
        scope.TexturePass = TexturePass.bind( scope );
    } else {
        scope.TexturePass = TexturePass;
    }
    scope.TexturePass.prototype = TexturePass.prototype;
    for ( var i in t ) scope.TexturePass[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.TexturePass.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__TexturePass ) {
        for ( var i = 0, il = scope.__TexturePass.length; i < il; i ++ ) scope.__TexturePass[ i ]( TexturePass );
        delete scope.__TexturePass;
    }

}) ( NWE.gfx );


// src/graphics/extras/postprocessing/BloomPass.js

( function ( scope ) {

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var WebGLRenderTarget = NWE.gfx.WebGLRenderTarget;
    if ( !WebGLRenderTarget ) { NWE.gfx.__WebGLRenderTarget = (NWE.gfx.__WebGLRenderTarget || []); NWE.gfx.__WebGLRenderTarget.push( function ( obj ) { WebGLRenderTarget = obj; } ); }

    var UniformUtils = NWE.gfx.UniformUtils;
    if ( !UniformUtils ) { NWE.gfx.__UniformUtils = (NWE.gfx.__UniformUtils || []); NWE.gfx.__UniformUtils.push( function ( obj ) { UniformUtils = obj; } ); }

    var CopyShader = NWE.gfx.ShaderLib.CopyShader;
    if ( !CopyShader ) { NWE.gfx.ShaderLib.__CopyShader = (NWE.gfx.ShaderLib.__CopyShader || []); NWE.gfx.ShaderLib.__CopyShader.push( function ( obj ) { CopyShader = obj; } ); }

    var ConvolutionShader = NWE.gfx.ShaderLib.ConvolutionShader;
    if ( !ConvolutionShader ) { NWE.gfx.ShaderLib.__ConvolutionShader = (NWE.gfx.ShaderLib.__ConvolutionShader || []); NWE.gfx.ShaderLib.__ConvolutionShader.push( function ( obj ) { ConvolutionShader = obj; } ); }

    var ShaderMaterial = NWE.gfx.ShaderMaterial;
    if ( !ShaderMaterial ) { NWE.gfx.__ShaderMaterial = (NWE.gfx.__ShaderMaterial || []); NWE.gfx.__ShaderMaterial.push( function ( obj ) { ShaderMaterial = obj; } ); }

    var EffectComposer = NWE.gfx.EffectComposer;
    if ( !EffectComposer ) { NWE.gfx.__EffectComposer = (NWE.gfx.__EffectComposer || []); NWE.gfx.__EffectComposer.push( function ( obj ) { EffectComposer = obj; } ); }

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var BloomPass = function ( strength, kernelSize, sigma, resolution ) {

        strength = ( strength !== undefined ) ? strength : 1;
        kernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;
        sigma = ( sigma !== undefined ) ? sigma : 4.0;
        resolution = ( resolution !== undefined ) ? resolution : 256;

        // render targets

        var pars = { minFilter: Const.LinearFilter, magFilter: Const.LinearFilter, format: Const.RGBFormat };

        this.renderTargetX = new WebGLRenderTarget( resolution, resolution, pars );
        this.renderTargetY = new WebGLRenderTarget( resolution, resolution, pars );

        // copy material

        if ( CopyShader === undefined ) {

            Logger.error( 'NWE.gfx.BloomPass: relies on NWE.gfx.CopyShader' );

        }

        var copyShader = CopyShader;

        this.copyUniforms = UniformUtils.clone( copyShader.uniforms );

        this.copyUniforms[ 'opacity' ].value = strength;

        this.materialCopy = new ShaderMaterial( {

            uniforms: this.copyUniforms,
            vertexShader: copyShader.vertexShader,
            fragmentShader: copyShader.fragmentShader,
            blending: Const.AdditiveBlending,
            transparent: true

        } );

        // convolution material

        if ( ConvolutionShader === undefined ) {

            Logger.error( 'NWE.gfx.BloomPass: relies on NWE.gfx.ConvolutionShader' );

        }

        var convolutionShader = ConvolutionShader;

        this.convolutionUniforms = UniformUtils.clone( convolutionShader.uniforms );

        this.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurx;
        this.convolutionUniforms[ 'cKernel' ].value = ConvolutionShader.buildKernel( sigma );

        this.materialConvolution = new ShaderMaterial( {

            uniforms: this.convolutionUniforms,
            vertexShader:  convolutionShader.vertexShader,
            fragmentShader: convolutionShader.fragmentShader,
            defines: {
                'KERNEL_SIZE_FLOAT': kernelSize.toFixed( 1 ),
                'KERNEL_SIZE_INT': kernelSize.toFixed( 0 )
            }

        } );

        this.enabled = true;
        this.needsSwap = false;
        this.clear = false;

    };

    BloomPass.prototype = {

        render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

            if ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );

            // Render quad with blured scene into texture (convolution pass 1)

            EffectComposer.quad.material = this.materialConvolution;

            this.convolutionUniforms[ 'tDiffuse' ].value = readBuffer;
            this.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurX;

            renderer.render( EffectComposer.scene, EffectComposer.camera, this.renderTargetX, true );


            // Render quad with blured scene into texture (convolution pass 2)

            this.convolutionUniforms[ 'tDiffuse' ].value = this.renderTargetX;
            this.convolutionUniforms[ 'uImageIncrement' ].value = BloomPass.blurY;

            renderer.render( EffectComposer.scene, EffectComposer.camera, this.renderTargetY, true );

            // Render original scene with superimposed blur to texture

            EffectComposer.quad.material = this.materialCopy;

            this.copyUniforms[ 'tDiffuse' ].value = this.renderTargetY;

            if ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );

            renderer.render( EffectComposer.scene, EffectComposer.camera, readBuffer, this.clear, true );

        }
     
    };

    BloomPass.blurX = new Vec2( 0.001953125, 0.0 );
    BloomPass.blurY = new Vec2( 0.0, 0.001953125 );

    if ( typeof BloomPass === 'function' ) {
        var t = {}, p = {};
        for ( var i in BloomPass ) t[i] = BloomPass[i];
        for ( var i in BloomPass.prototype ) try { p[i] = BloomPass.prototype[i] } catch(e) {};
        scope.BloomPass = BloomPass.bind( scope );
    } else {
        scope.BloomPass = BloomPass;
    }
    scope.BloomPass.prototype = BloomPass.prototype;
    for ( var i in t ) scope.BloomPass[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.BloomPass.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__BloomPass ) {
        for ( var i = 0, il = scope.__BloomPass.length; i < il; i ++ ) scope.__BloomPass[ i ]( BloomPass );
        delete scope.__BloomPass;
    }

}) ( NWE.gfx );


// src/plugins/images/ddsPlugin.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    // Adapted from @toji's DDS utils
    // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

    // All values and structures referenced from:
    // http://msdn.microsoft.com/en-us/library/bb943991.aspx/



    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var ImageLoader = NWE.ImageLoader;
    if ( !ImageLoader ) { NWE.__ImageLoader = (NWE.__ImageLoader || []); NWE.__ImageLoader.push( function ( obj ) { ImageLoader = obj; } ); }


    var DDSPlugin = {

        parse: function ( buffer, loadMipmaps ) {

            var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

            var DDS_MAGIC = 0x20534444;

            var DDSD_CAPS = 0x1,
                DDSD_HEIGHT = 0x2,
                DDSD_WIDTH = 0x4,
                DDSD_PITCH = 0x8,
                DDSD_PIXELFORMAT = 0x1000,
                DDSD_MIPMAPCOUNT = 0x20000,
                DDSD_LINEARSIZE = 0x80000,
                DDSD_DEPTH = 0x800000;

            var DDSCAPS_COMPLEX = 0x8,
                DDSCAPS_MIPMAP = 0x400000,
                DDSCAPS_TEXTURE = 0x1000;

            var DDSCAPS2_CUBEMAP = 0x200,
                DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
                DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
                DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
                DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
                DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
                DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
                DDSCAPS2_VOLUME = 0x200000;

            var DDPF_ALPHAPIXELS = 0x1,
                DDPF_ALPHA = 0x2,
                DDPF_FOURCC = 0x4,
                DDPF_RGB = 0x40,
                DDPF_YUV = 0x200,
                DDPF_LUMINANCE = 0x20000;

            function fourCCToInt32 ( value ) {

                return value.charCodeAt(0) +
                    (value.charCodeAt(1) << 8) +
                    (value.charCodeAt(2) << 16) +
                    (value.charCodeAt(3) << 24);

            };

            function int32ToFourCC ( value ) {

                return String.fromCharCode(
                    value & 0xff,
                    (value >> 8) & 0xff,
                    (value >> 16) & 0xff,
                    (value >> 24) & 0xff
                );

            };

            function loadARGBMip ( buffer, dataOffset, width, height ) {

                var dataLength = 4 * width * height;
                var srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
                var byteArray = new Uint8Array( dataLength );
                var dst = 0;
                var src = 0;

                for ( var y = 0; y < height; y ++ ) {

                    for ( var x = 0; x < width; x ++ ) {

                        var b = srcBuffer[ src ++ ];
                        var g = srcBuffer[ src ++ ];
                        var r = srcBuffer[ src ++ ];
                        var a = srcBuffer[ src ++ ];

                        byteArray[ dst ++ ] = r;  //r
                        byteArray[ dst ++ ] = g;  //g
                        byteArray[ dst ++ ] = b;  //b
                        byteArray[ dst ++ ] = a;  //a

                    }

                }

                return byteArray;

            };

            var FOURCC_DXT1 = fourCCToInt32('DXT1');
            var FOURCC_DXT3 = fourCCToInt32('DXT3');
            var FOURCC_DXT5 = fourCCToInt32('DXT5');

            var headerLengthInt = 31; // The header length in 32 bit ints

            // Offsets into the header array

            var off_magic = 0;

            var off_size = 1;
            var off_flags = 2;
            var off_height = 3;
            var off_width = 4;

            var off_mipmapCount = 7;

            var off_pfFlags = 20;
            var off_pfFourCC = 21;
            var off_RGBBitCount = 22;
            var off_RBitMask = 23;
            var off_GBitMask = 24;
            var off_BBitMask = 25;
            var off_ABitMask = 26;

            var off_caps = 27;
            var off_caps2 = 28;
            var off_caps3 = 29;
            var off_caps4 = 30;

            // Parse header

            var header = new Int32Array( buffer, 0, headerLengthInt );

            if ( header[ off_magic ] !== DDS_MAGIC ) {

                Logger.error( 'NWE.gfx.Texture.DDSPlugin.parse(): Invalid magic number in DDS header' );
                return dds;

            }

            if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {

                Logger.error( 'NWE.gfx.Texture.DDSPlugin.parse(): Unsupported format, must contain a FourCC code' );
                return dds;

            }

            var blockBytes;

            var fourCC = header[ off_pfFourCC ];

            var isRGBAUncompressed = false;

            switch ( fourCC ) {

                case FOURCC_DXT1:

                    blockBytes = 8;
                    dds.format = Const.RGB_S3TC_DXT1_Format;
                    break;

                case FOURCC_DXT3:

                    blockBytes = 16;
                    dds.format = Const.RGBA_S3TC_DXT3_Format;
                    break;

                case FOURCC_DXT5:

                    blockBytes = 16;
                    dds.format = Const.RGBA_S3TC_DXT5_Format;
                    break;

                default:

                    if ( header[off_RGBBitCount] === 32 
                         && header[off_RBitMask] & 0xff0000
                         && header[off_GBitMask] & 0xff00 
                         && header[off_BBitMask] & 0xff
                         && header[off_ABitMask] & 0xff000000 ) {

                        isRGBAUncompressed = true;
                        blockBytes = 64;
                        dds.format = Const.RGBAFormat;

                    } else {

                        Logger.error( 'NWE.gfx.Texture.DDSPlugin.parse(): Unsupported FourCC code: ', int32ToFourCC( fourCC ) );
                        return dds;

                    }

            }

            dds.mipmapCount = 1;

            if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {

                dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

            }

            // TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.

            dds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;

            dds.width = header[ off_width ];
            dds.height = header[ off_height ];

            var dataOffset = header[ off_size ] + 4;

            // Extract mipmaps buffers

            var width = dds.width;
            var height = dds.height;

            var faces = dds.isCubemap ? 6 : 1;

            for ( var face = 0; face < faces; face ++ ) {

                for ( var i = 0; i < dds.mipmapCount; i ++ ) {

                    if ( isRGBAUncompressed ) {

                        var byteArray = loadARGBMip( buffer, dataOffset, width, height );
                        var dataLength = byteArray.length;

                    } else {

                        var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
                        var byteArray = new Uint8Array( buffer, dataOffset, dataLength );

                    }
                    
                    var mipmap = { 'data': byteArray, 'width': width, 'height': height };
                    dds.mipmaps.push( mipmap );

                    dataOffset += dataLength;

                    width = Math.max( width * 0.5, 1 );
                    height = Math.max( height * 0.5, 1 );

                }

                width = dds.width;
                height = dds.height;

            }

            return dds;

        },

        fromBin: function ( image, arraybuffer ) {

            var data = DDSPlugin.parse( arraybuffer, true );

            if ( data ) {

                image.ddsformat = data.format;

                if ( data.isCubemap ) {

                    var faces = data.mipmaps.length / data.mipmapCount;

                    for ( var f = 0; f < faces; f ++ ) {

                        images[ f ] = { mipmaps : [] };

                        for ( var i = 0; i < data.mipmapCount; i ++ ) {

                            images[ f ].mipmaps.push( data.mipmaps[ f * data.mipmapCount + i ] );
                            images[ f ].format = data.format;
                            images[ f ].width = data.width;
                            images[ f ].height = data.height;

                        }

                    }

                } else {

                    image.width = data.width;
                    image.height = data.height;
                    image.mipmaps = data.mipmaps;

                }

                return image;

            } else {

                Logger.error( 'NWE.gfx.DDSPlugin.fromBin(): Some error during parsing DDS.' );
                return false;

            }

        }

    };

    ImageLoader.formats['dds'] = 'DDSPlugin';

    scope.DDSPlugin = DDSPlugin;
    if ( scope.__DDSPlugin ) {
        for ( var i = 0, il = scope.__DDSPlugin.length; i < il; i ++ ) scope.__DDSPlugin[ i ]( DDSPlugin );
        delete scope.__DDSPlugin;
    }

}) ( NWE.ImageLoader );


// src/plugins/images/tgaPlugin.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js



    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var ImageLoader = NWE.ImageLoader;
    if ( !ImageLoader ) { NWE.__ImageLoader = (NWE.__ImageLoader || []); NWE.__ImageLoader.push( function ( obj ) { ImageLoader = obj; } ); }


    var TGAPlugin = {

        decode: function ( arrayBuffer ) {

            // TGA Constants
            var TGA_TYPE_NO_DATA = 0,
            TGA_TYPE_INDEXED = 1,
            TGA_TYPE_RGB = 2,
            TGA_TYPE_GREY = 3,
            TGA_TYPE_RLE_INDEXED = 9,
            TGA_TYPE_RLE_RGB = 10,
            TGA_TYPE_RLE_GREY = 11,

            TGA_ORIGIN_MASK = 0x30,
            TGA_ORIGIN_SHIFT = 0x04,
            TGA_ORIGIN_BL = 0x00,
            TGA_ORIGIN_BR = 0x01,
            TGA_ORIGIN_UL = 0x02,
            TGA_ORIGIN_UR = 0x03;

            
            if ( arrayBuffer.length < 19 ) {

                Logger.error( 'NWE.gfx.TGAPlugin.decode(): Not enough data to contain header.' );

            }

            var content = new Uint8Array( arrayBuffer ),
                offset = 0,

                header = {

                    id_length: content[ offset++ ], 
                    colormap_type: content[ offset++ ],
                    image_type:      content[offset++],
                    colormap_index:  content[offset++] | content[offset++] << 8,
                    colormap_length: content[offset++] | content[offset++] << 8,
                    colormap_size:   content[offset++],

                    origin: [
                        content[offset++] | content[offset++] << 8,
                        content[offset++] | content[offset++] << 8
                    ],

                    width:      content[offset++] | content[offset++] << 8,
                    height:     content[offset++] | content[offset++] << 8,
                    pixel_size: content[offset++],
                    flags:      content[offset++]

                };

            function checkHeader ( header ) {

                switch ( header.image_type ) {

                    // Check indexed type
                    case TGA_TYPE_INDEXED:
                    case TGA_TYPE_RLE_INDEXED:

                        if ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {

                            Logger.error( 'NWE.gfx.TGAPlugin.checkHeader(): Invalid type colormap data for indexed type' );

                        }

                        break;

                    // Check colormap type
                    case TGA_TYPE_RGB:
                    case TGA_TYPE_GREY:
                    case TGA_TYPE_RLE_RGB:
                    case TGA_TYPE_RLE_GREY:

                        if ( header.colormap_type ) {

                            Logger.error( 'NWE.gfx.TGAPlugin.checkHeader(): Invalid type colormap data for colormap type' );

                        }

                        break;

                    // What the need of a file without data ?
                    case TGA_TYPE_NO_DATA:

                        Logger.error('NWE.gfx.TGAPlugin.checkHeader(): No data');

                    // Invalid type ?
                    default:

                        Logger.error('NWE.gfx.TGAPlugin.checkHeader(): Invalid type " '+ header.image_type + '"');

                }

                // Check image width and height
                if ( header.width <= 0 || header.height <= 0 ) {

                    Logger.error( 'NWE.gfx.TGAPlugin.checkHeader(): Invalid image size' );

                }

                // Check image pixel size 
                if ( header.pixel_size !== 8  &&
                     header.pixel_size !== 16 &&
                     header.pixel_size !== 24 &&
                     header.pixel_size !== 32 ) {

                    Logger.error( 'NWE.gfx.TGAPlugin.checkHeader(): Invalid pixel size "' + header.pixel_size + '"' );

                }

            }

            // Check tga if it is valid format
            checkHeader( header );

            if ( header.id_length + offset > arrayBuffer.length ) {

                Logger.error( 'NWE.gfx.TGAPlugin.load(): No data' );

            }

            // Skip the needn't data
            offset += header.id_length;

            // Get targa information about RLE compression and palette
            var use_rle = false, 
                use_pal = false, 
                use_grey = false;

            switch ( header.image_type ) {

                case TGA_TYPE_RLE_INDEXED:
                    use_rle = true;
                    use_pal = true;
                    break;

                case TGA_TYPE_INDEXED:
                    use_pal = true;
                    break;

                case TGA_TYPE_RLE_RGB:
                    use_rle = true;
                    break;

                case TGA_TYPE_RGB:
                    break;

                case TGA_TYPE_RLE_GREY:
                    use_rle = true;
                    use_grey = true;
                    break;

                case TGA_TYPE_GREY:
                    use_grey = true;
                    break;

            }

            // Parse tga image buffer
            function parse ( use_rle, use_pal, header, offset, data ) {

                var pixel_data,
                    pixel_size,
                    pixel_total,
                    palettes;

                    pixel_size = header.pixel_size >> 3;
                    pixel_total = header.width * header.height * pixel_size;

                // Read palettes
                if ( use_pal ) {

                    palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );

                }

                // Read RLE
                if ( use_rle ) {

                    pixel_data = new Uint8Array(pixel_total);

                    var c, count, i;
                    var shift = 0;
                    var pixels = new Uint8Array(pixel_size);

                    while ( shift < pixel_total ) {

                        c     = data[ offset ++ ];
                        count = (c & 0x7f) + 1;

                        // RLE pixels.
                        if ( c & 0x80 ) {

                            // Bind pixel tmp array
                            for ( i = 0; i < pixel_size; ++ i ) {

                                pixels[i] = data[ offset ++ ];

                            }

                            // Copy pixel array
                            for ( i = 0; i < count; ++ i ) {

                                pixel_data.set(pixels, shift + i * pixel_size);

                            }

                            shift += pixel_size * count;

                        } else {

                            // Raw pixels.

                            count *= pixel_size;

                            for ( i = 0; i < count; ++ i ) {

                                pixel_data[shift + i] = data[offset++];

                            }

                            shift += count;

                        }

                    }

                } else {

                    // RAW Pixels

                    pixel_data = data.subarray(
                        offset, offset += ( use_pal ? header.width * header.height : pixel_total )
                    );

                }

                return { 
                    pixel_data: pixel_data, 
                    palettes: palettes 
                };

            };

            function getImageData8bits ( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {

                var colormap = palettes;
                var color, i = 0, x, y;
                var width = header.width;

                for ( y = y_start; y !== y_end; y += y_step ) {

                    for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

                        color = image[i];
                        imageData[ (x + width * y) * 4 + 3 ] = 255;
                        imageData[ (x + width * y) * 4 + 2 ] = colormap[ (color * 3) + 0 ];
                        imageData[ (x + width * y) * 4 + 1 ] = colormap[ (color * 3) + 1 ];
                        imageData[ (x + width * y) * 4 + 0 ] = colormap[ (color * 3) + 2 ];

                    }

                }

                return imageData;

            };

            function getImageData16bits ( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

                var color, i = 0, x, y;
                var width = header.width;

                for ( y = y_start; y !== y_end; y += y_step ) {

                    for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

                        color = image[i + 0] + (image[i + 1] << 8); // Inversed ?
                        imageData[ (x + width * y) * 4 + 0 ] = (color & 0x7C00) >> 7;
                        imageData[ (x + width * y) * 4 + 1 ] = (color & 0x03E0) >> 2;
                        imageData[ (x + width * y) * 4 + 2 ] = (color & 0x001F) >> 3;
                        imageData[ (x + width * y) * 4 + 3 ] = (color & 0x8000) ? 0 : 255;

                    }

                }

                return imageData;

            };

            function getImageData24bits ( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

                var i = 0, x, y;
                var width = header.width;

                for ( y = y_start; y !== y_end; y += y_step ) {

                    for ( x = x_start; x !== x_end; x += x_step, i += 3 ) {

                        imageData[ (x + width * y) * 4 + 3 ] = 255;
                        imageData[ (x + width * y) * 4 + 2 ] = image[i + 0];
                        imageData[ (x + width * y) * 4 + 1 ] = image[i + 1];
                        imageData[ (x + width * y) * 4 + 0 ] = image[i + 2];

                    }

                }

                return imageData;

            };

            function getImageData32bits ( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

                var i = 0, x, y;
                var width = header.width;

                for ( y = y_start; y !== y_end; y += y_step ) {

                    for ( x = x_start; x !== x_end; x += x_step, i += 4 ) {

                        imageData[(x + width * y) * 4 + 2] = image[i + 0];
                        imageData[(x + width * y) * 4 + 1] = image[i + 1];
                        imageData[(x + width * y) * 4 + 0] = image[i + 2];
                        imageData[(x + width * y) * 4 + 3] = image[i + 3];

                    }

                }

                return imageData;

            };

            function getImageDataGrey8bits ( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

                var color, i = 0, x, y;
                var width = header.width;

                for ( y = y_start; y !== y_end; y += y_step ) {

                    for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

                        color = image[i];
                        imageData[ (x + width * y) * 4 + 0 ] = color;
                        imageData[ (x + width * y) * 4 + 1 ] = color;
                        imageData[ (x + width * y) * 4 + 2 ] = color;
                        imageData[ (x + width * y) * 4 + 3 ] = 255;

                    }

                }

                return imageData;

            };

            function getImageDataGrey16bits ( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

                var i = 0, x, y;
                var width = header.width;

                for ( y = y_start; y !== y_end; y += y_step ) {

                    for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

                        imageData[ (x + width * y) * 4 + 0 ] = image[ i + 0 ];
                        imageData[ (x + width * y) * 4 + 1 ] = image[ i + 0 ];
                        imageData[ (x + width * y) * 4 + 2 ] = image[ i + 0 ];
                        imageData[ (x + width * y) * 4 + 3 ] = image[ i + 1 ];

                    }

                }

                return imageData;

            };

            function getRGBA ( width, height, image, palette ) {

                var x_start,
                    y_start,
                    x_step,
                    y_step,
                    x_end,
                    y_end,

                    data = new Uint8Array( width * height * 4 );

                switch ( (header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT ) {

                    default:
                    case TGA_ORIGIN_UL:
                        x_start = 0;
                        x_step = 1;
                        x_end = width;
                        y_start = 0;
                        y_step = 1;
                        y_end = height;
                        break;

                    case TGA_ORIGIN_BL:
                        x_start = 0;
                        x_step = 1;
                        x_end = width;
                        y_start = height - 1;
                        y_step = -1;
                        y_end = -1;
                        break;

                    case TGA_ORIGIN_UR:
                        x_start = width - 1;
                        x_step = -1;
                        x_end = -1;
                        y_start = 0;
                        y_step = 1;
                        y_end = height;
                        break;

                    case TGA_ORIGIN_BR:
                        x_start = width - 1;
                        x_step = -1;
                        x_end = -1;
                        y_start = height - 1;
                        y_step = -1;
                        y_end = -1;
                        break;

                }

                if ( use_grey ) {

                    switch ( header.pixel_size ) {

                        case 8:
                            getImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
                            break;

                        case 16:
                            getImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
                            break;

                        default:
                            Logger.error( 'NWE.gfx.TGAPlugin.getRGBA(): not support this format' );
                            break;

                    }

                } else {

                    switch ( header.pixel_size ) {

                        case 8:
                            getImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );
                            break;

                        case 16:
                            getImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
                            break;

                        case 24:
                            getImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
                            break;

                        case 32:
                            getImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
                            break;

                        default:
                            Logger.error( 'NWE.gfx.TGAPlugin.getRGBA(): not support this format' );
                            break;

                    }

                }

                // Load image data according to specific method
                // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
                //func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );

                return data;

            };

            var result = parse( use_rle, use_pal, header, offset, content );
            var rgbaData = getRGBA( header.width, header.height, result.pixel_data, result.palettes );

            return {
                width: header.width,
                height: header.height,
                data: rgbaData
            };

        },

        fromBin: function ( image, arraybuffer ) {

            var image = TGAPlugin.decode( arraybuffer );

            if ( image ) {

                image.width = image.width;
                image.height = image.height;
                image.data = image.data;

                return image;

            } else {

                Logger.error( 'NWE.gfx.TGAPlugin.fromBin(): Some error during parsing TGA.' );
                return false;

            }

        },

    };

    ImageLoader.formats['tga'] = 'TGAPlugin';

    scope.TGAPlugin = TGAPlugin;
    if ( scope.__TGAPlugin ) {
        for ( var i = 0, il = scope.__TGAPlugin.length; i < il; i ++ ) scope.__TGAPlugin[ i ]( TGAPlugin );
        delete scope.__TGAPlugin;
    }

}) ( NWE.ImageLoader );


// src/plugins/images/pngPlugin.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    // part of code from https://github.com/arian/pngjs

    var ImageLoader = NWE.ImageLoader;
    if ( !ImageLoader ) { NWE.__ImageLoader = (NWE.__ImageLoader || []); NWE.__ImageLoader.push( function ( obj ) { ImageLoader = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }




    var PNGPlugin = {

        decode: function ( arrayBuffer ) {

            var offset = 0;
            var header = {
                width: 0,
                height: 0,
                bitDepth: 0,
                colorType: 0,
                colors: 0,
                alpha: false,
                compressionMethod: 0,
                filterMethod: 0,
                interlaceMethod: 0
            };
            var headerData;
            var dataChunks = [];
            var rgbaData;
            var uintArrayBuffer = new Uint8Array( arrayBuffer );

            function equalBytes ( a, b ) {

                if ( a.length !== b.length ) {

                    return false;

                }

                for ( var l = a.length; l --; ) {

                    if ( a[l] !== b[l] ) return false;

                }

                return true;

            };

            function slice ( data, start, end ) {

                var bytes = new Uint8Array( end - start );

                for ( var i = start; i < end; i ++ ) {

                    bytes[ i - start ] = data[ i ];

                }

                return bytes;

            };

            function readBytes ( length ) {

                var end = offset + length;

                if ( end > uintArrayBuffer.length ) {

                    Logger.error( 'NWE.gfx.Texture.PNGPlugin.readBytes(): Unexpectedly reached end of file' );

                }

                offset = end;

                return slice( uintArrayBuffer, offset - length, end );

            };

            function readUInt32( buffer, offset ) {

                return  (buffer[offset] << 24) +
                        (buffer[offset + 1] << 16) +
                        (buffer[offset + 2] << 8) +
                        (buffer[offset + 3] << 0);

            };

            function readUInt16 ( buffer, offset ) {

                return (buffer[offset + 1] << 8) + (buffer[offset] << 0);

            };

            function readUInt8 ( buffer, offset ) {

                return buffer[offset] << 0;

            };

            function bufferToString ( buffer ) {

                var str = '';
                
                for ( var i = 0; i < buffer.length; i ++ ) {

                    str += String.fromCharCode(buffer[i]);

                }

                return str;

            };

            function decodeIHDR ( chunk ) {

                header.width =             readUInt32(chunk, 0);
                header.height =            readUInt32(chunk, 4);
                header.bitDepth =          readUInt8(chunk,  8);
                header.compressionMethod = readUInt8(chunk, 10);
                header.filterMethod =      readUInt8(chunk, 11);
                header.interlaceMethod =   readUInt8(chunk, 12);

                setColorType( readUInt8(chunk,  9) );

            };

            function decodeIDAT ( chunk ) {

                dataChunks.push( chunk );

            };

            function decodeChunk () {

                var length = readUInt32( readBytes(4), 0 );

                if ( length < 0 ) {

                    Logger.error( 'NWE.gfx.Texture.PNGPlugin.decodeChunk(): Bad chunk length ' + (0xFFFFFFFF & length) );

                }

                var type = bufferToString(readBytes(4));
                var chunk = readBytes(length);
                var crc = readBytes(4);

                switch ( type ) {

                    case 'IHDR': decodeIHDR(chunk); break;
                    case 'PLTE': /*decodePLTE(chunk);*/ break;
                    case 'IDAT': decodeIDAT(chunk); break;
                    case 'IEND': /*decodeIEND(chunk);*/ break;

                }

                return type;

            };

            function checkHeader ( header ) {

                if ( offset !== 0 ) {

                    Logger.error( 'NWE.gfx.Texture.PNGPlugin.checkHeader(): file pointer should be at 0 to read the header' );

                }

                headerData = readBytes(8);

                if ( !equalBytes(headerData, [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]) ) {

                    Logger.error( 'NWE.gfx.Texture.PNGPlugin.checkHeader(): invalid PNGReader file (bad signature)' );

                }

            };

            function setColorType ( colorType ) {

                var colors = 0,
                    alpha = false;

                switch ( colorType ) {

                    case 0: colors = 1; break;
                    case 2: colors = 3; break;
                    case 3: colors = 1; break;
                    case 4: colors = 2; alpha = true; break;
                    case 6: colors = 4; alpha = true; break;
                    default: Logger.error( 'NWE.gfx.Texture.PNGPlugin.setColorType(): invalid color type' );

                }

                header.colors = colors;
                header.alpha = alpha;

            };

            function unFilterNone ( scanline, pixels, bpp, of, length ) {

                for ( var i = 0, to = length; i < to; i ++ ) {

                    pixels[ of + i ] = scanline[i];

                }

            };

            function unFilterSub ( scanline, pixels, bpp, of, length ) {

                var i = 0;

                for ( ; i < bpp; i ++ ) {

                    pixels[ of + i ] = scanline[i];

                }

                for ( ; i < length; i ++ ) {

                    // Raw(x) + Raw(x - bpp)
                    pixels[ of + i ] = (scanline[i] + pixels[ of + i - bpp ]) & 0xFF;

                }

            };

            function unFilterUp ( scanline, pixels, bpp, of, length ) {

                var i = 0, 
                    byte,
                    prev;

                // Prior(x) is 0 for all x on the first scanline

                if ( (of - length) < 0 ) {

                    for ( ; i < length; i ++ ) {

                        pixels[ of + i ] = scanline[i];

                    }

                } else {

                    for ( ; i < length; i ++ ) {

                        // Raw(x)
                        byte = scanline[i];
                        // Prior(x)
                        prev = pixels[ of + i - length ];
                        pixels[ of + i ] = (byte + prev) & 0xFF;

                    }

                }

            };

            function unFilterAverage ( scanline, pixels, bpp, of, length ) {

                var i = 0,
                    byte,
                    prev,
                    prior;

                if ( (of - length) < 0 ) {

                    // Prior(x) == 0 && Raw(x - bpp) == 0
                    for ( ; i < bpp; i ++ ) {

                        pixels[ of + i ] = scanline[i];

                    }

                    // Prior(x) == 0 && Raw(x - bpp) != 0 (right shift, prevent doubles)
                    for ( ; i < length; i ++ ) {

                        pixels[ of + i ] = (scanline[i] + (pixels[ of + i - bpp ] >> 1)) & 0xFF;

                    }

                } else {
                    
                    // Prior(x) != 0 && Raw(x - bpp) == 0
                    for ( ; i < bpp; i ++ ) {

                        pixels[ of + i ] = (scanline[i] + (pixels[ of - length + i ] >> 1)) & 0xFF;

                    }

                    // Prior(x) != 0 && Raw(x - bpp) != 0
                    for ( ; i < length; i ++ ) {

                        byte = scanline[i];
                        prev = pixels[ of + i - bpp ];
                        prior = pixels[ of + i - length ];
                        pixels[ of + i ] = (byte + (prev + prior >> 1)) & 0xFF;

                    }

                }

            };

            function unFilterPaeth ( scanline, pixels, bpp, of, length ) {

                var i = 0,
                    raw, a, b, c, p, pa, pb, pc, pr;

                if ( (of - length) < 0 ) {

                    // Prior(x) == 0 && Raw(x - bpp) == 0
                    for ( ; i < bpp; i ++ ) {

                        pixels[ of + i ] = scanline[i];

                    }

                    // Prior(x) == 0 && Raw(x - bpp) != 0
                    // paethPredictor(x, 0, 0) is always x
                    for ( ; i < length; i ++ ) {

                        pixels[ of + i ] = (scanline[i] + pixels[ of + i - bpp ]) & 0xFF;

                    }

                } else {
                    
                    // Prior(x) != 0 && Raw(x - bpp) == 0
                    // paethPredictor(x, 0, 0) is always x
                    for ( ; i < bpp; i ++ ) {

                        pixels[ of + i ] = (scanline[i] + pixels[ of + i - length ]) & 0xFF;

                    }

                    // Prior(x) != 0 && Raw(x - bpp) != 0
                    for ( ; i < length; i ++ ) {

                        raw = scanline[i];

                        a = pixels[ of + i - bpp ];
                        b = pixels[ of + i - length ];
                        c = pixels[ of + i - length - bpp ];

                        p = a + b - c;
                        pa = Math.abs(p - a);
                        pb = Math.abs(p - b);
                        pc = Math.abs(p - c);

                        if ( pa <= pb && pa <= pc ) pr = a;
                        else if ( pb <= pc ) pr = b;
                        else pr = c;

                        pixels[ of + i ] = (raw + pr) & 0xFF;

                    }

                }

            };

            function interlaceNone ( data ) {

                // bytes per pixel
                var bpp = Math.max( 1, header.colors * header.bitDepth / 8 );

                // color bytes per row
                var cpr = bpp * header.width;

                var pixels = new Uint8Array( bpp * header.width * header.height );
                var scanline;
                var offset = 0;

                data = new FlateStream(data);
                data = data.getBytes();

                for ( var i = 0; i < data.length; i += cpr + 1 ){

                    scanline = slice( data, i + 1, i + cpr + 1 );

                    switch ( readUInt8(data, i) ) {

                        case 0: unFilterNone(   scanline, pixels, bpp, offset, cpr); break;
                        case 1: unFilterSub(    scanline, pixels, bpp, offset, cpr); break;
                        case 2: unFilterUp(     scanline, pixels, bpp, offset, cpr); break;
                        case 3: unFilterAverage(scanline, pixels, bpp, offset, cpr); break;
                        case 4: unFilterPaeth(  scanline, pixels, bpp, offset, cpr); break;
                        default: Logger.error( 'NWE.gfx.Texture.PNGPlugin.interlaceNone(): unkown filtered scanline.' );

                    }

                    offset += cpr;

                }

                return pixels;

            };

            function interlaceAdam7 ( data ) {

                Logger.error( 'NWE.gfx.Texture.PNGPlugin.interlaceAdam7(): interlacing is not implemented yet' );

            };

            function parse () {

                checkHeader();

                while ( offset < uintArrayBuffer.length ) {

                    var type = decodeChunk();

                    // stop after IHDR chunk, or after IEND
                    if ( type == 'IEND' ) break;

                }

                var length = 0;
                var i, j, k, l;

                for ( l = dataChunks.length; l --; ) {

                    length += dataChunks[l].length;

                }

                var data = new Uint8Array( length );
            
                for ( i = 0, k = 0, l = dataChunks.length; i < l; i ++ ) {

                    var chunk = dataChunks[i];
                    for ( j = 0; j < chunk.length; j ++ ) {

                        data[ k ++ ] = chunk[ j ];

                    }

                }

                if ( header.interlaceMethod === 0 ) {

                    return interlaceNone( data );

                } else {

                    return interlaceAdam7( data );

                }

            };

            rgbaData = parse();

            return {
                width: header.width,
                height: header.height,
                data: rgbaData
            };

        },

        fromBin: function ( image, arrayBuffer ) {

            var image = PNGPlugin.decode( arrayBuffer );

            if ( image ) {

                image.width = image.width;
                image.height = image.height;
                image.data = image.data;

                return image;

            } else {

                Logger.error( 'NWE.gfx.PNGPlugin.fromBin(): Some error during parsing TGA.' );
                return false;

            }

        }

    };

    ImageLoader.formats['png'] = 'PNGPlugin';

    scope.PNGPlugin = PNGPlugin;
    if ( scope.__PNGPlugin ) {
        for ( var i = 0, il = scope.__PNGPlugin.length; i < il; i ++ ) scope.__PNGPlugin[ i ]( PNGPlugin );
        delete scope.__PNGPlugin;
    }

}) ( NWE.ImageLoader );


// src/framework/Fw.js

( function ( scope ) {

    /*
     * @author ohmed
    */



    scope.controls = {};

    // nothing here as for now

}) ( NWE.fw );


// src/framework/group/Group.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var LayoutBufferGeometry = NWE.gfx.LayoutBufferGeometry;
    if ( !LayoutBufferGeometry ) { NWE.gfx.__LayoutBufferGeometry = (NWE.gfx.__LayoutBufferGeometry || []); NWE.gfx.__LayoutBufferGeometry.push( function ( obj ) { LayoutBufferGeometry = obj; } ); }

    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var DeviceCapabilities = NWE.gfx.DeviceCapabilities;
    if ( !DeviceCapabilities ) { NWE.gfx.__DeviceCapabilities = (NWE.gfx.__DeviceCapabilities || []); NWE.gfx.__DeviceCapabilities.push( function ( obj ) { DeviceCapabilities = obj; } ); }

    var DataTexture = NWE.gfx.DataTexture;
    if ( !DataTexture ) { NWE.gfx.__DataTexture = (NWE.gfx.__DataTexture || []); NWE.gfx.__DataTexture.push( function ( obj ) { DataTexture = obj; } ); }

    var GroupMaterial = NWE.gfx.GroupMaterial;
    if ( !GroupMaterial ) { NWE.gfx.__GroupMaterial = (NWE.gfx.__GroupMaterial || []); NWE.gfx.__GroupMaterial.push( function ( obj ) { GroupMaterial = obj; } ); }

    var MeshBasicMaterial = NWE.gfx.MeshBasicMaterial;
    if ( !MeshBasicMaterial ) { NWE.gfx.__MeshBasicMaterial = (NWE.gfx.__MeshBasicMaterial || []); NWE.gfx.__MeshBasicMaterial.push( function ( obj ) { MeshBasicMaterial = obj; } ); }

    var Mesh = NWE.gfx.Mesh;
    if ( !Mesh ) { NWE.gfx.__Mesh = (NWE.gfx.__Mesh || []); NWE.gfx.__Mesh.push( function ( obj ) { Mesh = obj; } ); }

    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }


    var GroupInstance = NWE.fw.GroupInstance;
    if ( !GroupInstance ) { NWE.fw.__GroupInstance = (NWE.fw.__GroupInstance || []); NWE.fw.__GroupInstance.push( function ( obj ) { GroupInstance = obj; } ); }

    var GroupTextureIntMode = NWE.fw.GroupTextureIntMode;
    if ( !GroupTextureIntMode ) { NWE.fw.__GroupTextureIntMode = (NWE.fw.__GroupTextureIntMode || []); NWE.fw.__GroupTextureIntMode.push( function ( obj ) { GroupTextureIntMode = obj; } ); }

    var GroupTextureFloatMode = NWE.fw.GroupTextureFloatMode;
    if ( !GroupTextureFloatMode ) { NWE.fw.__GroupTextureFloatMode = (NWE.fw.__GroupTextureFloatMode || []); NWE.fw.__GroupTextureFloatMode.push( function ( obj ) { GroupTextureFloatMode = obj; } ); }

    var GroupInstancesMode = NWE.fw.GroupInstancesMode;
    if ( !GroupInstancesMode ) { NWE.fw.__GroupInstancesMode = (NWE.fw.__GroupInstancesMode || []); NWE.fw.__GroupInstancesMode.push( function ( obj ) { GroupInstancesMode = obj; } ); }


    var Group = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        this.uuid = Math.generateUUID();
        internal[ this.uuid ] = objInternal;

        this.id = NWE.fw.GroupIdCount ++;
        this.name = params.name || '';

        this.parent = undefined;

        this.defferedUpdate = params.defferedUpdate || true;

        //

        internal[ this.uuid ].attributes = [

            { name: 'index', size: 1 },
            { name: 'position', size: 3 }

        ];

        this.geometry = params.geometry || new LayoutBufferGeometry();
        this.material = params.material || new MeshBasicMaterial();

        //

        this.instances = [];

        //

        var visible;

        Object.defineProperty( this, 'visible', {

            get: function () {

                return visible;

            },

            set: function ( value ) {

                if ( internal[ this.uuid ].mesh ) {

                    internal[ this.uuid ].mesh.visible = value;

                }

                visible = value;

            },

            enumerable: true

        });

        //

        this.instanceof = 'Group';

    };

    Group.prototype = {

        constructor: Group

    };

    Group.prototype.setup = function () {};

    Group.prototype.removeInstance = function ( param ) {

        return internal[ this.uuid ].mode.remove.call( this );

    };

    Group.prototype.updateInstance = function ( instance ) {

        return internal[ this.uuid ].mode.updateInstance.call( this, instance );

    };

    Group.prototype.update = function () {

        return internal[ this.uuid ].mode.update.call( this );

    };

    Group.prototype.updateGeometry = function () {

        return internal[ this.uuid ].mode.updateGeometry.call( this );

    };

    Group.prototype.setAtlasTexture = function ( texture, density ) {

        if ( ! ( texture instanceof Texture ) ) {

            Logger.warn( 'NWE.fw.Group.setAtlasTexture(): atlasTexute needs to be Texture type.' );
            return;

        }

        this.material.uniforms.atlasTexture.value = texture;
        this.material.uniforms.atlasTexture.value.needsUpdate = true;

        density = density || 1;
        this.material.uniforms.atlasTextureItemsPerRow.value = density;

    };

    Group.prototype.clone = function () {

        // todo

    };

    Group.prototype.dispose = function () {

        // todo

    };

    NWE.fw.GroupIdCount = 0;

    Group.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Group.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Group.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Group.setInternal = function ( name, value ) { internal[ name ] = value; };
    Group.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Group === 'function' ) {
        var t = {}, p = {};
        for ( var i in Group ) t[i] = Group[i];
        for ( var i in Group.prototype ) try { p[i] = Group.prototype[i] } catch(e) {};
        scope.Group = Group.bind( scope );
    } else {
        scope.Group = Group;
    }
    internal['constructor'] = Group;
    scope.Group.prototype = Group.prototype;
    for ( var i in t ) scope.Group[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Group.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Group ) {
        for ( var i = 0, il = scope.__Group.length; i < il; i ++ ) scope.__Group[ i ]( Group );
        delete scope.__Group;
    }

}) ( NWE.fw );


// src/framework/group/DynamicGroup.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var LayoutBufferGeometry = NWE.gfx.LayoutBufferGeometry;
    if ( !LayoutBufferGeometry ) { NWE.gfx.__LayoutBufferGeometry = (NWE.gfx.__LayoutBufferGeometry || []); NWE.gfx.__LayoutBufferGeometry.push( function ( obj ) { LayoutBufferGeometry = obj; } ); }

    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var DeviceCapabilities = NWE.gfx.DeviceCapabilities;
    if ( !DeviceCapabilities ) { NWE.gfx.__DeviceCapabilities = (NWE.gfx.__DeviceCapabilities || []); NWE.gfx.__DeviceCapabilities.push( function ( obj ) { DeviceCapabilities = obj; } ); }

    var DataTexture = NWE.gfx.DataTexture;
    if ( !DataTexture ) { NWE.gfx.__DataTexture = (NWE.gfx.__DataTexture || []); NWE.gfx.__DataTexture.push( function ( obj ) { DataTexture = obj; } ); }

    var DynamicGroupMaterial = NWE.gfx.DynamicGroupMaterial;
    if ( !DynamicGroupMaterial ) { NWE.gfx.__DynamicGroupMaterial = (NWE.gfx.__DynamicGroupMaterial || []); NWE.gfx.__DynamicGroupMaterial.push( function ( obj ) { DynamicGroupMaterial = obj; } ); }

    var MeshBasicMaterial = NWE.gfx.MeshBasicMaterial;
    if ( !MeshBasicMaterial ) { NWE.gfx.__MeshBasicMaterial = (NWE.gfx.__MeshBasicMaterial || []); NWE.gfx.__MeshBasicMaterial.push( function ( obj ) { MeshBasicMaterial = obj; } ); }

    var Mesh = NWE.gfx.Mesh;
    if ( !Mesh ) { NWE.gfx.__Mesh = (NWE.gfx.__Mesh || []); NWE.gfx.__Mesh.push( function ( obj ) { Mesh = obj; } ); }

    var Scene = NWE.gfx.Scene;
    if ( !Scene ) { NWE.gfx.__Scene = (NWE.gfx.__Scene || []); NWE.gfx.__Scene.push( function ( obj ) { Scene = obj; } ); }


    var Group = NWE.fw.Group;
    if ( !Group ) { NWE.fw.__Group = (NWE.fw.__Group || []); NWE.fw.__Group.push( function ( obj ) { Group = obj; } ); }

    var GroupInstance = NWE.fw.GroupInstance;
    if ( !GroupInstance ) { NWE.fw.__GroupInstance = (NWE.fw.__GroupInstance || []); NWE.fw.__GroupInstance.push( function ( obj ) { GroupInstance = obj; } ); }

    var GroupTextureIntMode = NWE.fw.GroupTextureIntMode;
    if ( !GroupTextureIntMode ) { NWE.fw.__GroupTextureIntMode = (NWE.fw.__GroupTextureIntMode || []); NWE.fw.__GroupTextureIntMode.push( function ( obj ) { GroupTextureIntMode = obj; } ); }

    var GroupTextureFloatMode = NWE.fw.GroupTextureFloatMode;
    if ( !GroupTextureFloatMode ) { NWE.fw.__GroupTextureFloatMode = (NWE.fw.__GroupTextureFloatMode || []); NWE.fw.__GroupTextureFloatMode.push( function ( obj ) { GroupTextureFloatMode = obj; } ); }

    var GroupInstancesMode = NWE.fw.GroupInstancesMode;
    if ( !GroupInstancesMode ) { NWE.fw.__GroupInstancesMode = (NWE.fw.__GroupInstancesMode || []); NWE.fw.__GroupInstancesMode.push( function ( obj ) { GroupInstancesMode = obj; } ); }


    var DynamicGroup = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Group.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        //

        this.mode = params.mode || 'useIntTextures';

        //

        this.instanceMaxCount = params.instanceMaxCount || 100;
        this.instanceTypeMaxCount = params.instanceTypeMaxCount || 10;

        this.paramsPerInstance = params.paramsPerInstance || 3;

        //

        internal[ this.uuid ].attributes.push({ name: 'normal', size: 3 });
        internal[ this.uuid ].attributes.push({ name: 'uv', size: 2 });
        internal[ this.uuid ].attributes.push({ name: 'vertex_index', size: 1 });
        internal[ this.uuid ].attributes.push({ name: 'instance_index', size: 1 });
        internal[ this.uuid ].attributes.push({ name: 'texture_index', size: 1 });

        internal[ this.uuid ].instanceTypes = {
            length: 0
        };

        //

        this.instanceof = 'DynamicGroup';

    };

    DynamicGroup.prototype = Object.create( Group.prototype );

    DynamicGroup.prototype.setup = function () {

        if ( this.mode === 'useInstances' && DeviceCapabilities.supportsInstancing() ) {

            // think: need to operate separate mashes.
            // todo

            internal[ this.uuid ].mode = GroupInstancesMode;

        } else if ( this.mode === 'useFloatTextures' && DeviceCapabilities.supportsBoneTextures() ) {

            // todo

            internal[ this.uuid ].mode = GroupTextureFloatMode;

        } else if ( this.mode === 'useIntTextures' ) {

            this.material = new DynamicGroupMaterial(); // think: make more flaxible in future

            internal[ this.uuid ].instanceParamsTexture = new DataTexture( null, this.instanceMaxCount, this.paramsPerInstance * this.instanceTypeMaxCount );
            internal[ this.uuid ].instanceParams = internal[ this.uuid ].instanceParamsTexture.image;

            this.material.uniforms.instanceParamsTexture.value = internal[ this.uuid ].instanceParamsTexture;
            this.material.uniforms.instanceParamsTexture.value.needsUpdate = true;

            this.material.uniforms['INSTANCES_PER_BLOCK'].value = this.instanceMaxCount;
            this.material.uniforms['PARAM_TEXTURE_W_DEF'].value = 1 / this.instanceMaxCount;
            this.material.uniforms['PARAM_TEXTURE_H_DEF'].value = 1 / ( this.paramsPerInstance * this.instanceTypeMaxCount );
            this.material.uniforms['BLOCK_SIZE'].value = 255;

            internal[ this.uuid ].mesh = new Mesh( this.geometry, this.material );
            internal[ this.uuid ].mesh.parent = this;
            internal[ this.uuid ].mesh.matrixAutoUpdate = false;

            internal[ this.uuid ].mode = DynamicGroup.getInternal( 'TextureIntMode' );
            internal[ this.uuid ].mode.setInternalScope( internal );

        }

        if ( !internal[ this.uuid ].mode ) {

            Logger.warn( 'NWE.fw.DynamicGroup.setup(): incorrect mode named ' + this.mode + '.' );

        }

    };

    DynamicGroup.prototype.addInstance = function ( params ) {

        var instance = new GroupInstance( params.type, params.position, params.rotation, params.scale );

        if ( ! instance ) {

            return false;

        }

        if ( this.instanceMaxCount === internal[ this.uuid ].instanceTypes[ params.type ].array.length ) {

            Logger.warn( 'NWE.fw.DynamicGroup.addInstance(): runtime recreation not supported yet. Set larger instance max count on Group creation.' );
            return false;

        }

        instance.id = internal[ this.uuid ].instanceTypes[ params.type ].array.length;
        instance.group = this;

        internal[ this.uuid ].instanceTypes[ params.type ].array.push( instance );
        this.instances.push( instance );

        internal[ this.uuid ].mode.add.call( this, instance );

        return instance;

    };

    DynamicGroup.prototype.removeInstance = function ( params ) {

        return internal[ this.uuid ].mode.remove.call( this );

    };

    DynamicGroup.prototype.updateInstance = function ( instance ) {

        return internal[ this.uuid ].mode.updateInstance.call( this, instance );

    };

    DynamicGroup.prototype.update = function () {

        return internal[ this.uuid ].mode.update.call( this );

    };

    DynamicGroup.prototype.updateGeometry = function () {

        return internal[ this.uuid ].mode.updateGeometry.call( this );

    };

    DynamicGroup.prototype.addInstanceType = function ( name, model ) {

        if ( internal[ this.uuid ].instanceTypes[ name ] ) {

            Logger.warn( 'NWE.fw.DynamicGroup.addInstanceType(): already has instance type named ' + name + '.' );
            return false;

        }

        if ( internal[ this.uuid ].instanceTypes.length >= this.instanceTypeMaxCount ) {

            Logger.warn( 'NWE.fw.DynamicGroup.addInstanceType(): runtime recreation not supported yet. Set more instance types on DynamicGroup creation.' );
            return false;

        } else {

            internal[ this.uuid ].instanceTypes.length ++;

            internal[ this.uuid ].instanceTypes[ name ] = {

                id:         internal[ this.uuid ].instanceTypes.length - 1,
                model:      model,
                array:      []

            };

        }

        return true;

    };

    DynamicGroup.prototype.removeInstanceType = function ( name ) {

        if ( ! internal[ this.uuid ].instanceTypes[ name ] ) {

            Logger.warn( 'NWE.fw.DynamicGroup.removeInstanceType(): already does not have instance type named ' + name + '.' );
            return false;

        }

        // todo: remove instances

        internal[ this.uuid ].instanceTypes[ name ] = null;

        return true;

    };

    DynamicGroup.prototype.setBlockSize = function ( size ) {

        internal[ this.uuid ].mode.setBlockSize.call( this, size );

    };

    DynamicGroup.prototype.setAtlasTexture = function ( texture ) {

        internal[ this.uuid ].mesh.material.uniforms.atlasTexture.value = texture;
        internal[ this.uuid ].mesh.material.uniforms.atlasTexture.value.needsUpdate = true;

    };

    DynamicGroup.prototype.clone = function () {

        // todo

    };

    DynamicGroup.prototype.dispose = function () {

        // todo

    };


    Scene.registerObject( 'DynamicGroup', function ( object ) {

        object.getInternal( 'mesh' ).visible = object.visible;

        this.add( object.getInternal( 'mesh' ) );

    }, function ( object ) {

        // todo

    });

    DynamicGroup.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    DynamicGroup.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    DynamicGroup.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    DynamicGroup.setInternal = function ( name, value ) { internal[ name ] = value; };
    DynamicGroup.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof DynamicGroup === 'function' ) {
        var t = {}, p = {};
        for ( var i in DynamicGroup ) t[i] = DynamicGroup[i];
        for ( var i in DynamicGroup.prototype ) try { p[i] = DynamicGroup.prototype[i] } catch(e) {};
        scope.DynamicGroup = DynamicGroup.bind( scope );
    } else {
        scope.DynamicGroup = DynamicGroup;
    }
    internal['constructor'] = DynamicGroup;
    scope.DynamicGroup.prototype = DynamicGroup.prototype;
    for ( var i in t ) scope.DynamicGroup[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DynamicGroup.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DynamicGroup ) {
        for ( var i = 0, il = scope.__DynamicGroup.length; i < il; i ++ ) scope.__DynamicGroup[ i ]( DynamicGroup );
        delete scope.__DynamicGroup;
    }

}) ( NWE.fw );


// src/framework/group/StaticGroup.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var LayoutBufferGeometry = NWE.gfx.LayoutBufferGeometry;
    if ( !LayoutBufferGeometry ) { NWE.gfx.__LayoutBufferGeometry = (NWE.gfx.__LayoutBufferGeometry || []); NWE.gfx.__LayoutBufferGeometry.push( function ( obj ) { LayoutBufferGeometry = obj; } ); }

    var StaticGroupMaterial = NWE.gfx.StaticGroupMaterial;
    if ( !StaticGroupMaterial ) { NWE.gfx.__StaticGroupMaterial = (NWE.gfx.__StaticGroupMaterial || []); NWE.gfx.__StaticGroupMaterial.push( function ( obj ) { StaticGroupMaterial = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Mesh = NWE.gfx.Mesh;
    if ( !Mesh ) { NWE.gfx.__Mesh = (NWE.gfx.__Mesh || []); NWE.gfx.__Mesh.push( function ( obj ) { Mesh = obj; } ); }

    var Scene = NWE.gfx.Scene;
    if ( !Scene ) { NWE.gfx.__Scene = (NWE.gfx.__Scene || []); NWE.gfx.__Scene.push( function ( obj ) { Scene = obj; } ); }

    var Quaternion = NWE.Quaternion;
    if ( !Quaternion ) { NWE.__Quaternion = (NWE.__Quaternion || []); NWE.__Quaternion.push( function ( obj ) { Quaternion = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var Sphere = NWE.Sphere;
    if ( !Sphere ) { NWE.__Sphere = (NWE.__Sphere || []); NWE.__Sphere.push( function ( obj ) { Sphere = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var Group = NWE.fw.Group;
    if ( !Group ) { NWE.fw.__Group = (NWE.fw.__Group || []); NWE.fw.__Group.push( function ( obj ) { Group = obj; } ); }

    var GroupInstance = NWE.fw.GroupInstance;
    if ( !GroupInstance ) { NWE.fw.__GroupInstance = (NWE.fw.__GroupInstance || []); NWE.fw.__GroupInstance.push( function ( obj ) { GroupInstance = obj; } ); }


    var StaticGroup = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Group.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        //

        this.geometry = params.geometry || new LayoutBufferGeometry();
        this.material = params.material || new StaticGroupMaterial();

        this.material.uniforms.ambient.value = new Color( 0xffffff );
        this.material.uniforms.ambient.needsUpdate = true;

        //

        internal[ this.uuid ].attributes.push({ name: 'normal', size: 3 });
        internal[ this.uuid ].attributes.push({ name: 'uv', size: 2 });
        internal[ this.uuid ].attributes.push({ name: 'uvOffset', size: 2 });
        internal[ this.uuid ].attributes.push({ name: 'instance_index', size: 1 });

        //

        this.instanceof = 'StaticGroup';

    };

    StaticGroup.prototype = Object.create( Group.prototype );

    StaticGroup.prototype.addInstance = function ( params ) {

        var instance = new GroupInstance( params.type, params.position, params.rotation, params.scale, params.model, params.texturesID );

        if ( ! instance ) {

            return false;

        }

        this.updateInstance( instance );

        instance.id = this.instances.length;
        instance.group = this;

        this.instances.push( instance );

        if ( ! this.defferedUpdate ) {

            this.updateGeometry();

        }

        return instance;

    };

    StaticGroup.prototype.updateInstance = function ( instance ) {

        instance.matrix = new Matrix4();
        instance.matrix = instance.matrix.compose( instance.position, new Quaternion().setFromEuler( instance.rotation ), instance.scale );

    };

    StaticGroup.prototype.updateGeometry = function () {

        // compute vertex and face count

        var geometry,
            totalVertices = 0,
            totalTriangles = 0;

        for ( var i = 0, il = this.instances.length; i < il; i ++ ) {

            if ( ! this.instances[ i ].active ) {

                continue;

            }

            totalVertices += this.instances[i].model.vertices;
            totalTriangles += this.instances[i].model.triangles;

        }

        if ( ! totalVertices ) {

            return;

        }

        //

        geometry = new LayoutBufferGeometry({ vertCount: totalVertices, trisCount: totalTriangles });

        // add attributes

        var attribute;

        for ( var i in internal[ this.uuid ].attributes ) {

            attribute = internal[ this.uuid ].attributes[i];

            if ( attribute.name === 'index' ) {

                attribute.size = 3 * totalTriangles;
                geometry.addAttribute( attribute.name, attribute.size, Const.Uint32 );

            } else {

                geometry.addAttribute( attribute.name, attribute.size );

            }

        }

        geometry.bindArrays();

        // add parts

        for ( var i = 0, il = this.instances.length; i < il; i ++ ) {

            if ( ! this.instances[ i ].active ) {

                continue;

            }

            geometry.addPart(
                this.instances[ i ].model,
                {
                    id: i,
                    aIndexOffset: 1000 * this.instances[i].id,
                    texturesID: this.instances[i].texturesID,
                    matrix: this.instances[i].matrix,
                    atlasTextureItemsPerRow: this.material.uniforms.atlasTextureItemsPerRow.value || 1
                }
            );

        }

        geometry.computeChunkOffsets();

        // add bounding params

        geometry.boundingSphere = new Sphere();
        geometry.boundingSphere.center.set( 0, 0, 0 );
        geometry.boundingSphere.radius = 25000;

        //

        this.geometry = geometry;
        internal[ this.uuid ].mesh = new Mesh( this.geometry, this.material );
        internal[ this.uuid ].mesh.parent = this;

    };

    StaticGroup.prototype.clone = function () {

        // todo

    };

    StaticGroup.prototype.dispose = function () {

        // todo

    };

    Scene.registerObject( 'StaticGroup', function ( object ) {

        object.getInternal( 'mesh' ).visible = object.visible;

        this.add( object.getInternal( 'mesh' ) );

    }, function ( object ) {

        // todo

    });

    StaticGroup.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    StaticGroup.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    StaticGroup.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    StaticGroup.setInternal = function ( name, value ) { internal[ name ] = value; };
    StaticGroup.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof StaticGroup === 'function' ) {
        var t = {}, p = {};
        for ( var i in StaticGroup ) t[i] = StaticGroup[i];
        for ( var i in StaticGroup.prototype ) try { p[i] = StaticGroup.prototype[i] } catch(e) {};
        scope.StaticGroup = StaticGroup.bind( scope );
    } else {
        scope.StaticGroup = StaticGroup;
    }
    internal['constructor'] = StaticGroup;
    scope.StaticGroup.prototype = StaticGroup.prototype;
    for ( var i in t ) scope.StaticGroup[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.StaticGroup.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__StaticGroup ) {
        for ( var i = 0, il = scope.__StaticGroup.length; i < il; i ++ ) scope.__StaticGroup[ i ]( StaticGroup );
        delete scope.__StaticGroup;
    }

}) ( NWE.fw );


// src/framework/group/FlexibleGroup.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var FlexibleGroup = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Group.call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        //

        this.geometry = param.geometry || new LayoutBufferGeometry();
        this.material = param.material || new MeshBasicMaterial();

        //

        this.instanceof = 'FlexibleGroup';

    };

    FlexibleGroup.prototype = {};

    FlexibleGroup.prototype.clone = function () {

        // todo

    };

    FlexibleGroup.prototype.dispose = function () {

        // todo

    };

    FlexibleGroup.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    FlexibleGroup.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    FlexibleGroup.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    FlexibleGroup.setInternal = function ( name, value ) { internal[ name ] = value; };
    FlexibleGroup.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof FlexibleGroup === 'function' ) {
        var t = {}, p = {};
        for ( var i in FlexibleGroup ) t[i] = FlexibleGroup[i];
        for ( var i in FlexibleGroup.prototype ) try { p[i] = FlexibleGroup.prototype[i] } catch(e) {};
        scope.FlexibleGroup = FlexibleGroup.bind( scope );
    } else {
        scope.FlexibleGroup = FlexibleGroup;
    }
    internal['constructor'] = FlexibleGroup;
    scope.FlexibleGroup.prototype = FlexibleGroup.prototype;
    for ( var i in t ) scope.FlexibleGroup[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.FlexibleGroup.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__FlexibleGroup ) {
        for ( var i = 0, il = scope.__FlexibleGroup.length; i < il; i ++ ) scope.__FlexibleGroup[ i ]( FlexibleGroup );
        delete scope.__FlexibleGroup;
    }

}) ( NWE.fw );


// src/framework/group/GroupInstance.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Euler = NWE.Euler;
    if ( !Euler ) { NWE.__Euler = (NWE.__Euler || []); NWE.__Euler.push( function ( obj ) { Euler = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var GroupInstance = function ( type, position, rotation, scale, model, texturesID ) {

        if ( ! type ) {

            Logger.error( 'NWE.fw.GroupInstance: parameter \'type\' is empty.' );
            return false;

        }

        this.id = -1;
        this.type = type;
        this.active = true;

        this.group = false;

        this.position = position || new Vec3();
        this.rotation = rotation || new Euler();
        this.scale = scale || new Vec3( 1, 1, 1 );
        this.texturesID = texturesID || {};

        this.model = model || null;

    };

    GroupInstance.prototype.setPosition = function ( value, deferredUpdate ) {

        this.position.set( value.x, value.y, value.z );

        if ( this.group ) {

            this.group.updateInstance( this );

            if ( ! deferredUpdate ) {

                this.group.update();

            }

        }

    };

    GroupInstance.prototype.setRotation = function ( value, deferredUpdate ) {

        this.rotation.set( value.x, value.y, value.z );

        if ( this.group ) {

            this.group.updateInstance( this );

            if ( ! deferredUpdate ) {

                this.group.update();

            }

        }

    };

    GroupInstance.prototype.update = function () {

        if ( this.group ) {

            this.group.updateInstance( this );

        }

    };

    GroupInstance.prototype.clone = function () {

        // todo

    };

    if ( typeof GroupInstance === 'function' ) {
        var t = {}, p = {};
        for ( var i in GroupInstance ) t[i] = GroupInstance[i];
        for ( var i in GroupInstance.prototype ) try { p[i] = GroupInstance.prototype[i] } catch(e) {};
        scope.GroupInstance = GroupInstance.bind( scope );
    } else {
        scope.GroupInstance = GroupInstance;
    }
    scope.GroupInstance.prototype = GroupInstance.prototype;
    for ( var i in t ) scope.GroupInstance[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.GroupInstance.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__GroupInstance ) {
        for ( var i = 0, il = scope.__GroupInstance.length; i < il; i ++ ) scope.__GroupInstance[ i ]( GroupInstance );
        delete scope.__GroupInstance;
    }

}) ( NWE.fw );


// src/framework/group/modes/TextureIntMode.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var LayoutBufferGeometry = NWE.gfx.LayoutBufferGeometry;
    if ( !LayoutBufferGeometry ) { NWE.gfx.__LayoutBufferGeometry = (NWE.gfx.__LayoutBufferGeometry || []); NWE.gfx.__LayoutBufferGeometry.push( function ( obj ) { LayoutBufferGeometry = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }


    var Sphere = NWE.Sphere;
    if ( !Sphere ) { NWE.__Sphere = (NWE.__Sphere || []); NWE.__Sphere.push( function ( obj ) { Sphere = obj; } ); }


    var DynamicGroup = NWE.fw.DynamicGroup;
    if ( !DynamicGroup ) { NWE.fw.__DynamicGroup = (NWE.fw.__DynamicGroup || []); NWE.fw.__DynamicGroup.push( function ( obj ) { DynamicGroup = obj; } ); }


    var TextureIntMode = {

        generateGeometry: function () {

            var geometry,
                totalVertices = 0,
                totalTriangles = 0;

            // get total triangles & vertices count

            var instanceTypes = internal[ this.uuid ].instanceTypes;

            for ( var i in instanceTypes ) {

                if ( i === 'length' ) continue;

                totalTriangles += this.instanceMaxCount * instanceTypes[i].model.triangles;
                totalVertices  += this.instanceMaxCount * instanceTypes[i].model.vertices;

            }

            //

            geometry = new LayoutBufferGeometry({ vertCount: totalVertices, trisCount: totalTriangles });

            // add attributes

            var attribute;

            for ( var i in internal[ this.uuid ].attributes ) {

                attribute = internal[ this.uuid ].attributes[i];

                if ( attribute.name === 'index' ) {

                    attribute.size = 3 * totalTriangles;
                    geometry.addAttribute( attribute.name, attribute.size, Const.Uint32 );

                } else {

                    geometry.addAttribute( attribute.name, attribute.size );

                }

            }

            geometry.bindArrays();

            // add parts

            for ( var i in instanceTypes ) {

                if ( i === 'length' ) continue;

                for ( var j = 0, jl = instanceTypes[i].array.length; j < jl; j ++ ) {

                    geometry.addPart(
                        instanceTypes[i].model,
                        {
                            id: j + instanceTypes[i].id * this.instanceMaxCount,
                            aIndexOffset: 1000 * instanceTypes[i].id,
                            texturesID: instanceTypes[i].texturesID
                        }
                    );

                }

            }

            //

            geometry.computeChunkOffsets();

            // add bounding params

            geometry.boundingSphere = new Sphere();
            geometry.boundingSphere.center.set( 0, 0, 0 );
            geometry.boundingSphere.radius = 25000;

            return geometry;

        },

        add: function ( instance ) {

            var x = instance.position.x;
            var y = instance.position.y;
            var z = instance.position.z;

            var rotation = instance.rotation.y;
            var scale = instance.scale.y;

            // compute new geometry

            if ( ! this.defferedUpdate ) {

                internal[ this.uuid ].mesh.geometry = TextureIntMode.generateGeometry.call( this );
                this.geometry = internal[ this.uuid ].mesh.geometry;

            }

            // update __paramsTexture cells

            this.updateInstance( instance );

        },

        updateInstance: function ( instance ) {

            var x = instance.position.x + this.material.uniforms['BLOCK_SIZE'].value / 2;
            var y = instance.position.y + this.material.uniforms['BLOCK_SIZE'].value / 2;
            var z = instance.position.z + this.material.uniforms['BLOCK_SIZE'].value / 2;

            var rotation = instance.rotation.y;
            var scale = instance.scale.y;

            // update __paramsTexture cells

            var instanceType = internal[ this.uuid ].instanceTypes[ instance.type ];
            var instanceParams = internal[ this.uuid ].instanceParams.data;
            var offset;

            offset = 4 * ( instance.id + this.instanceMaxCount * this.paramsPerInstance * instanceType.id );

            // instance position [part2]
            instanceParams[ offset + 0 ] = window.Math.min( x, 255 );
            instanceParams[ offset + 1 ] = window.Math.min( y, 255 );
            instanceParams[ offset + 2 ] = window.Math.min( z, 255 );

            offset += 4 * this.instanceMaxCount;

            // instance position [part2]
            instanceParams[ offset + 0 ] = ( x > 255 ) ? x % 255 : 0;
            instanceParams[ offset + 1 ] = ( y > 255 ) ? y % 255 : 0;
            instanceParams[ offset + 2 ] = ( z > 255 ) ? z % 255 : 0;

            offset += 4 * this.instanceMaxCount;

            // instance params
            instanceParams[ offset + 0 ] = 255 * rotation / ( 2 * Math.PI );    // rotation Y
            instanceParams[ offset + 1 ] = scale;                               // scale
            instanceParams[ offset + 2 ] = 0;                                   // ?

            this.needsUpdate = true;

        },

        remove: function ( instance ) {

            // todo

        },

        setBlockSize: function ( size ) {

            this.material.uniforms['BLOCK_SIZE'].value = size;
            this.material.uniforms['BLOCK_SIZE'].needsUpdate = true;

        },

        updateGeometry: function () {

            internal[ this.uuid ].mesh.geometry = TextureIntMode.generateGeometry.call( this );
            this.geometry = internal[ this.uuid ].mesh.geometry;

        },

        update: function () {

            if ( this.needsUpdate ) {

                this.material.uniforms.instanceParamsTexture.needsUpdate = true;
                this.material.uniforms.instanceParamsTexture.value.needsUpdate = true;

                this.needsUpdate = false;

            }

        },

        setInternalScope: function ( scope ) {

            internal = scope;

        }

    };

    DynamicGroup.setInternal( 'TextureIntMode', TextureIntMode );

}) ( NWE.fw );


// src/framework/group/handlers/AnimationHandler.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var DataTexture = NWE.gfx.DataTexture;
    if ( !DataTexture ) { NWE.gfx.__DataTexture = (NWE.gfx.__DataTexture || []); NWE.gfx.__DataTexture.push( function ( obj ) { DataTexture = obj; } ); }

    var Group = NWE.fw.Group;
    if ( !Group ) { NWE.fw.__Group = (NWE.fw.__Group || []); NWE.fw.__Group.push( function ( obj ) { Group = obj; } ); }

    var GroupInstance = NWE.fw.GroupInstance;
    if ( !GroupInstance ) { NWE.fw.__GroupInstance = (NWE.fw.__GroupInstance || []); NWE.fw.__GroupInstance.push( function ( obj ) { GroupInstance = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    Group.prototype.setupAnimation = function ( params ) {

        // need:
        // get max vertex count
        // think: animation frame count ? same per instance type or unique ?

        this.setInternal( 'instanceAnimationTexture', new DataTexture( null, 0, 0 ) );
        // this.setInternal( 'instanceAnimation', internal[ this.uuid ].instanceAnimationTexture.image );

        //

        this.setInternal( 'instanceAnimationParamsTexture', new DataTexture( null, 0, 0 ) );
        // this.setInternal( 'instanceAnimationParams', internal[ this.uuid ].instanceAnimationParamsTexture.image );

        // todo

        Logger.warn( 'sorry. not done yet.' );

    };

    Group.prototype.setAnimation = function ( instanceId, start, end, duration ) {

        // todo

    };

    Group.prototype.stopAnimation = function ( instanceId ) {

        // todo

    };

    Group.prototype.playAnimation = function ( instanceId ) {

        // todo

    };

    //

    GroupInstance.prototype.animation = (function () {

        var animation = {};

        animation.loop = false;
        animation.play = false;

        //

        var currentFrame = 0;
        var nextFrame = 0;

        //

        animation.set = function ( start, end, duration ) {

            // todo

        };

        animation.play = function () {

            // todo

        };

        animation.stop = function () {

            // todo

        };

        return animation;

    }) ();

}) ( NWE.fw.Group );


// src/framework/group/handlers/MovementHandler.js

( function ( scope ) {

    /**
     * @author ohmed
     */

    var Group = NWE.fw.Group;
    if ( !Group ) { NWE.fw.__Group = (NWE.fw.__Group || []); NWE.fw.__Group.push( function ( obj ) { Group = obj; } ); }

    var GroupInstance = NWE.fw.GroupInstance;
    if ( !GroupInstance ) { NWE.fw.__GroupInstance = (NWE.fw.__GroupInstance || []); NWE.fw.__GroupInstance.push( function ( obj ) { GroupInstance = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    Group.prototype.setupMovement = function () {

        // todo

        Logger.warn( 'sorry. not done yet.' );

    };

    Group.prototype.setMovement = function () {

        // todo

    };

    Group.prototype.stopMovement = function () {

        // todo

    };

    Group.prototype.playMovement = function () {

        // todo

    };

    //

    GroupInstance.prototype.movement = (function () {

        var movement = {};

        movement.set = function () {

            // todo

        };

        movement.play = function () {

            // todo

        };

        movement.stop = function () {

            // todo

        };

        return movement;

    }) ();

}) ( NWE.fw.Group );


// src/framework/controls/TrackballControls.js

( function ( scope ) {

    /**
     * @author Eberhard Graether / http://egraether.com/
     * trackball controls
     */



    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Quaternion = NWE.Quaternion;
    if ( !Quaternion ) { NWE.__Quaternion = (NWE.__Quaternion || []); NWE.__Quaternion.push( function ( obj ) { Quaternion = obj; } ); }

    var EventDispatcher = NWE.EventDispatcher;
    if ( !EventDispatcher ) { NWE.__EventDispatcher = (NWE.__EventDispatcher || []); NWE.__EventDispatcher.push( function ( obj ) { EventDispatcher = obj; } ); }


    var TrackballControls = function ( object, domElement, objInternal ) {

        this.uuid = Math.generateUUID();

        objInternal = objInternal || {};
        internal[ this.uuid ] = objInternal;

        var _this = this;
        var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM: 4, TOUCH_PAN: 5 };

        this.object = object;
        this.domElement = ( domElement !== undefined ) ? domElement : document;

        // API

        this.enabled = true;

        this.screen = { left: 0, top: 0, width: 0, height: 0 };

        this.rotateSpeed = 1.0;
        this.zoomSpeed = 1.2;
        this.panSpeed = 0.3;

        this.noRotate = false;
        this.noZoom = false;
        this.noPan = false;
        this.noRoll = false;

        this.staticMoving = false;
        this.dynamicDampingFactor = 0.2;

        this.minDistance = 0;
        this.maxDistance = Infinity;

        this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];

        // internals

        this.target = new Vec3();

        var lastPosition = new Vec3();

        var _state = STATE.NONE,
        _prevState = STATE.NONE,

        _eye = new Vec3(),

        _rotateStart = new Vec3(),
        _rotateEnd = new Vec3(),

        _zoomStart = new Vec2(),
        _zoomEnd = new Vec2(),

        _touchZoomDistanceStart = 0,
        _touchZoomDistanceEnd = 0,

        _panStart = new Vec2(),
        _panEnd = new Vec2();

        // for reset

        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.up0 = this.object.up.clone();

        // events

        var changeEvent = { type: 'change' };

        // methods

        this.handleResize = function () {

            if ( this.domElement === document ) {

                this.screen.left = 0;
                this.screen.top = 0;
                this.screen.width = window.innerWidth;
                this.screen.height = window.innerHeight;

            } else {

                this.screen = this.domElement.getBoundingClientRect();

            }

        };

        this.handleEvent = function ( event ) {

            if ( typeof this[ event.type ] == 'function' ) {

                this[ event.type ]( event );

            }

        };

        this.getMouseOnScreen = function ( clientX, clientY ) {

            return new Vec2(
                ( clientX - _this.screen.left ) / _this.screen.width,
                ( clientY - _this.screen.top ) / _this.screen.height
            );

        };

        this.getMouseProjectionOnBall = function ( clientX, clientY ) {

            var mouseOnBall = new Vec3(
                ( clientX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*.5),
                ( _this.screen.height * 0.5 + _this.screen.top - clientY ) / (_this.screen.height*.5),
                0.0
            );

            var length = mouseOnBall.length();

            if ( _this.noRoll ) {

                if ( length < window.Math.SQRT1_2 ) {

                    mouseOnBall.z = window.Math.sqrt( 1.0 - length*length );

                } else {

                    mouseOnBall.z = .5 / length;
                    
                }

            } else if ( length > 1.0 ) {

                mouseOnBall.normalize();

            } else {

                mouseOnBall.z = window.Math.sqrt( 1.0 - length * length );

            }

            _eye.copy( _this.object.position ).sub( _this.target );

            var projection = _this.object.up.clone().setLength( mouseOnBall.y );
            projection.add( _this.object.up.clone().cross( _eye ).setLength( mouseOnBall.x ) );
            projection.add( _eye.setLength( mouseOnBall.z ) );

            return projection;

        };

        this.rotateCamera = function () {

            var angle = window.Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );

            if ( angle ) {

                var axis = ( new Vec3() ).crossVectors( _rotateStart, _rotateEnd ).normalize(),
                    quaternion = new Quaternion();

                angle *= _this.rotateSpeed;

                quaternion.setFromAxisAngle( axis, -angle );

                _eye.applyQuaternion( quaternion );
                _this.object.up.applyQuaternion( quaternion );

                _rotateEnd.applyQuaternion( quaternion );

                if ( _this.staticMoving ) {

                    _rotateStart.copy( _rotateEnd );

                } else {

                    quaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );
                    _rotateStart.applyQuaternion( quaternion );

                }

            }

        };

        this.zoomCamera = function () {

            if ( _state === STATE.TOUCH_ZOOM ) {

                var factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
                _touchZoomDistanceStart = _touchZoomDistanceEnd;
                _eye.multiplyScalar( factor );

            } else {

                var factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;

                if ( factor !== 1.0 && factor > 0.0 ) {

                    _eye.multiplyScalar( factor );

                    if ( _this.staticMoving ) {

                        _zoomStart.copy( _zoomEnd );

                    } else {

                        _zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;

                    }

                }

            }

        };

        this.panCamera = function () {

            var mouseChange = _panEnd.clone().sub( _panStart );

            if ( mouseChange.lengthSq() ) {

                mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

                var pan = _eye.clone().cross( _this.object.up ).setLength( mouseChange.x );
                pan.add( _this.object.up.clone().setLength( mouseChange.y ) );

                _this.object.position.add( pan );
                _this.target.add( pan );

                if ( _this.staticMoving ) {

                    _panStart = _panEnd;

                } else {

                    _panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

                }

            }

        };

        this.checkDistances = function () {

            if ( !_this.noZoom || !_this.noPan ) {

                if ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {

                    _this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );

                }

                if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {

                    _this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );

                }

            }

        };

        this.update = function () {

            _eye.subVectors( _this.object.position, _this.target );

            if ( !_this.noRotate ) {

                _this.rotateCamera();

            }

            if ( !_this.noZoom ) {

                _this.zoomCamera();

            }

            if ( !_this.noPan ) {

                _this.panCamera();

            }

            _this.object.position.addVectors( _this.target, _eye );

            _this.checkDistances();

            _this.object.lookAt( _this.target );

            if ( lastPosition.distanceToSquared( _this.object.position ) > 0 ) {

                _this.dispatchEvent( changeEvent );

                lastPosition.copy( _this.object.position );

            }

        };

        this.reset = function () {

            _state = STATE.NONE;
            _prevState = STATE.NONE;

            _this.target.copy( _this.target0 );
            _this.object.position.copy( _this.position0 );
            _this.object.up.copy( _this.up0 );

            _eye.subVectors( _this.object.position, _this.target );

            _this.object.lookAt( _this.target );

            _this.dispatchEvent( changeEvent );

            lastPosition.copy( _this.object.position );

        };

        // listeners

        function keydown( event ) {

            if ( _this.enabled === false ) return;

            window.removeEventListener( 'keydown', keydown );

            _prevState = _state;

            if ( _state !== STATE.NONE ) {

                return;

            } else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {

                _state = STATE.ROTATE;

            } else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom ) {

                _state = STATE.ZOOM;

            } else if ( event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan ) {

                _state = STATE.PAN;

            }

        }

        function keyup( event ) {

            if ( _this.enabled === false ) return;

            _state = _prevState;

            window.addEventListener( 'keydown', keydown, false );

        }

        function mousedown( event ) {

            if ( _this.enabled === false ) return;

            event.preventDefault();
            event.stopPropagation();

            if ( _state === STATE.NONE ) {

                _state = event.button;

            }

            if ( _state === STATE.ROTATE && !_this.noRotate ) {

                _rotateStart = _this.getMouseProjectionOnBall( event.clientX, event.clientY );
                _rotateEnd.copy(_rotateStart)

            } else if ( _state === STATE.ZOOM && !_this.noZoom ) {

                _zoomStart = _this.getMouseOnScreen( event.clientX, event.clientY );
                _zoomEnd.copy(_zoomStart);

            } else if ( _state === STATE.PAN && !_this.noPan ) {

                _panStart = _this.getMouseOnScreen( event.clientX, event.clientY );
                _panEnd.copy(_panStart)

            }

            document.addEventListener( 'mousemove', mousemove, false );
            document.addEventListener( 'mouseup', mouseup, false );

        }

        function mousemove( event ) {

            if ( _this.enabled === false ) return;

            event.preventDefault();
            event.stopPropagation();

            if ( _state === STATE.ROTATE && !_this.noRotate ) {

                _rotateEnd = _this.getMouseProjectionOnBall( event.clientX, event.clientY );

            } else if ( _state === STATE.ZOOM && !_this.noZoom ) {

                _zoomEnd = _this.getMouseOnScreen( event.clientX, event.clientY );

            } else if ( _state === STATE.PAN && !_this.noPan ) {

                _panEnd = _this.getMouseOnScreen( event.clientX, event.clientY );

            }

        }

        function mouseup( event ) {

            if ( _this.enabled === false ) return;

            event.preventDefault();
            event.stopPropagation();

            _state = STATE.NONE;

            document.removeEventListener( 'mousemove', mousemove );
            document.removeEventListener( 'mouseup', mouseup );

        }

        function mousewheel( event ) {

            if ( _this.enabled === false ) return;

            event.preventDefault();
            event.stopPropagation();

            var delta = 0;

            if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

                delta = event.wheelDelta / 40;

            } else if ( event.detail ) { // Firefox

                delta = - event.detail / 3;

            }

            _zoomStart.y += delta * 0.01;

        }

        function touchstart( event ) {

            if ( _this.enabled === false ) return;

            switch ( event.touches.length ) {

                case 1:
                    _state = STATE.TOUCH_ROTATE;
                    _rotateStart = _rotateEnd = _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                case 2:
                    _state = STATE.TOUCH_ZOOM;
                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                    _touchZoomDistanceEnd = _touchZoomDistanceStart = window.Math.sqrt( dx * dx + dy * dy );
                    break;

                case 3:
                    _state = STATE.TOUCH_PAN;
                    _panStart = _panEnd = _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                default:
                    _state = STATE.NONE;

            }

        }

        function touchmove( event ) {

            if ( _this.enabled === false ) return;

            event.preventDefault();
            event.stopPropagation();

            switch ( event.touches.length ) {

                case 1:
                    _rotateEnd = _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                case 2:
                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                    _touchZoomDistanceEnd = window.Math.sqrt( dx * dx + dy * dy )
                    break;

                case 3:
                    _panEnd = _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                default:
                    _state = STATE.NONE;

            }

        }

        function touchend( event ) {

            if ( _this.enabled === false ) return;

            switch ( event.touches.length ) {

                case 1:
                    _rotateStart = _rotateEnd = _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                case 2:
                    _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;
                    break;

                case 3:
                    _panStart = _panEnd = _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

            }

            _state = STATE.NONE;

        }

        this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

        this.domElement.addEventListener( 'mousedown', mousedown, false );

        this.domElement.addEventListener( 'mousewheel', mousewheel, false );
        this.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox

        this.domElement.addEventListener( 'touchstart', touchstart, false );
        this.domElement.addEventListener( 'touchend', touchend, false );
        this.domElement.addEventListener( 'touchmove', touchmove, false );

        window.addEventListener( 'keydown', keydown, false );
        window.addEventListener( 'keyup', keyup, false );

        this.handleResize();

    };

    TrackballControls.prototype = Object.create( EventDispatcher.prototype );

    TrackballControls.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    TrackballControls.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    TrackballControls.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    TrackballControls.setInternal = function ( name, value ) { internal[ name ] = value; };
    TrackballControls.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof TrackballControls === 'function' ) {
        var t = {}, p = {};
        for ( var i in TrackballControls ) t[i] = TrackballControls[i];
        for ( var i in TrackballControls.prototype ) try { p[i] = TrackballControls.prototype[i] } catch(e) {};
        scope.TrackballControls = TrackballControls.bind( scope );
    } else {
        scope.TrackballControls = TrackballControls;
    }
    internal['constructor'] = TrackballControls;
    scope.TrackballControls.prototype = TrackballControls.prototype;
    for ( var i in t ) scope.TrackballControls[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.TrackballControls.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__TrackballControls ) {
        for ( var i = 0, il = scope.__TrackballControls.length; i < il; i ++ ) scope.__TrackballControls[ i ]( TrackballControls );
        delete scope.__TrackballControls;
    }

}) ( NWE.fw.controls );


// src/framework/controls/MapControls.js

( function ( scope ) {

    /*
     * @author ohmed
     * map controls
     */



    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var MapControls = function ( object, domElement ) {

        var self = this;

        this.object = object;
        this.rotation = 0;

        this.domElement = ( domElement !== undefined ) ? domElement : document;
        if ( domElement ) this.domElement.setAttribute( 'tabindex', -1 );

        // API

        this.movementSpeed = 1.0;
        this.maxZoomSpeed = 2.0;
        this.rollSpeed = 0.005;

        this.maxMoveSpeed = 15.0;

        // internals

        var fInterval = false;
        var sInterval = false;
        var zInterval = false;
        var rInterval = false;
        var zoomInterval = false;

        var activeMovmentForward = false;
        var activeMovmentSide = false;

        var forwardSpeed = 0;
        var sideSpeed = 0;
        var zoomSpeed = 0;

        var lookAtVector = new Vec3();

        this.keydown = function ( event ) {

            if ( event.altKey ) {

                return;

            }

            // event.preventDefault();

            switch ( event.keyCode ) {

                case 16: /* shift */ self.movementSpeedMultiplier = 0.1; break;

                case 87: /*W*/ self.moveForward(-1); break;
                case 83: /*S*/ self.moveForward( 1); break;

                case 65: /*A*/ self.moveSide(-1); break;
                case 68: /*D*/ self.moveSide( 1); break;

                // case 82: /*R*/ this.moveState.up = 1; break;
                // case 70: /*F*/ this.moveState.down = 1; break;

                case 38: /*up*/ self.moveForward(-1); break;
                case 40: /*down*/ self.moveForward( 1); break;

                case 37: /*left*/ self.moveSide(-1); break;
                case 39: /*right*/ self.moveSide( 1); break;

                // case 81: /*Q*/ this.moveState.rollLeft = 1; break;
                // case 69: /*E*/ this.moveState.rollRight = 1; break;

                case 107: /*+*/ self.zoom(-2); break;
                case 109: /*-*/ self.zoom( 2); break;

            }

        };

        this.keyup = function ( event ) {

            switch ( event.keyCode ) {

                case 16: /* shift */ this.movementSpeedMultiplier = 1; break;

                case 87: /*W*/ self.stopForward(); break;
                case 83: /*S*/ self.stopForward(); break;

                case 65: /*A*/ self.stopSide(); break;
                case 68: /*D*/ self.stopSide(); break;

                // case 82: /*R*/ this.moveState.up = 0; break;
                // case 70: /*F*/ this.moveState.down = 0; break;

                case 38: /*up*/ self.stopForward(); break;
                case 40: /*down*/ self.stopForward(); break;

                case 37: /*left*/ self.stopSide(); break;
                case 39: /*right*/ self.stopSide(); break;

                // case 81: /*Q*/ this.moveState.rollLeft = 0; break;
                // case 69: /*E*/ this.moveState.rollRight = 0; break;

                // case 107: /*+*/ break;
                // case 109: /*-*/ break;

            }

        };

        this.moveForward = function ( dirrection ) { // direction = 1 | -1

            if ( activeMovmentForward ) return;

            clearInterval( fInterval );
            activeMovmentForward = true;

            fInterval = setInterval( function () {

                var delta = ( dirrection * self.maxMoveSpeed ) - forwardSpeed;

                forwardSpeed += delta / 5;
                if ( Math.abs( delta ) < 0.4 ) clearInterval( fInterval );

            }, 40 );

        };

        this.stopForward = function ( stopSpeed ) {

            stopSpeed = stopSpeed || 5;

            if ( ! activeMovmentForward ) return;

            clearInterval( fInterval );
            activeMovmentForward = false;

            fInterval = setInterval( function () {

                forwardSpeed -= forwardSpeed / stopSpeed;
                if ( Math.abs( forwardSpeed - 0 ) < 0.2 ) {

                    clearInterval( fInterval );
                    forwardSpeed = 0;

                }

            }, 40 );

        };

        this.moveSide = function ( dirrection ) { // direction = 1 | -1

            if ( activeMovmentSide ) return;

            clearInterval( sInterval );
            activeMovmentSide = true;

            sInterval = setInterval( function () {

                var delta = ( dirrection * self.maxMoveSpeed ) - sideSpeed;

                sideSpeed += delta / 5;
                if ( Math.abs( delta ) < 0.2 ) clearInterval( sInterval );

            }, 40 );

        };

        this.stopSide = function ( stopSpeed ) {

            stopSpeed = stopSpeed || 5;

            if ( ! activeMovmentSide ) return;

            clearInterval( sInterval );
            activeMovmentSide = false;

            sInterval = setInterval( function () {

                sideSpeed -= sideSpeed / stopSpeed;
                if ( Math.abs( sideSpeed - 0 ) < 0.4 ) {

                    clearInterval( sInterval );
                    sideSpeed = 0;

                }

            }, 40 );

        };

        this.zoom = function ( deltaZoom ) {

            clearInterval( zInterval );

            zInterval = setInterval( function () {

                var delta = deltaZoom - zoomSpeed;

                zoomSpeed += delta / 4;

                zoomSpeed = window.Math.min( zoomSpeed, self.maxZoomSpeed );

                if ( Math.abs( delta ) < 0.2 ) {

                    if ( deltaZoom !== 0 ) {

                        self.zoom(0);

                    } else {

                        zoomSpeed = 0;
                        clearInterval( zInterval );

                    }

                }

            }, 40 );

        };

        //

        this.update = function ( delta ) {

            var pos = this.object.position;
            var rotY = this.rotation;

            // move object

            pos.x += 30 * delta * (  forwardSpeed * window.Math.sin( rotY ) + sideSpeed    * window.Math.cos( rotY ) );
            pos.y += zoomSpeed;
            pos.z += 30 * delta * ( -sideSpeed    * window.Math.sin( rotY ) + forwardSpeed * window.Math.cos( rotY ) );

            pos.y = window.Math.max( pos.y, 10 );

            lookAtVector.set( pos.x - 160 * window.Math.sin( rotY ), 0.4 * pos.y - 20, pos.z - 160 * window.Math.cos( rotY ) );
            object.lookAt( lookAtVector );

        };

        window.addEventListener( 'keydown', this.keydown, false );
        window.addEventListener( 'keyup', this.keyup, false );

    };

    MapControls.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    MapControls.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    MapControls.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    MapControls.setInternal = function ( name, value ) { internal[ name ] = value; };
    MapControls.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof MapControls === 'function' ) {
        var t = {}, p = {};
        for ( var i in MapControls ) t[i] = MapControls[i];
        for ( var i in MapControls.prototype ) try { p[i] = MapControls.prototype[i] } catch(e) {};
        scope.MapControls = MapControls.bind( scope );
    } else {
        scope.MapControls = MapControls;
    }
    internal['constructor'] = MapControls;
    scope.MapControls.prototype = MapControls.prototype;
    for ( var i in t ) scope.MapControls[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.MapControls.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__MapControls ) {
        for ( var i = 0, il = scope.__MapControls.length; i < il; i ++ ) scope.__MapControls[ i ]( MapControls );
        delete scope.__MapControls;
    }

}) ( NWE.fw.controls );


// src/framework/terrain/Terrain.js

( function ( scope ) {

    /*
     * @author ohmed
    */



    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }


    var Terrain = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        this.uuid = Math.generateUUID();
        internal[ this.uuid ] = objInternal;

        this.id = NWE.fw.TerrainIdCount ++;
        this.name = params.name || '';

        this.parent = undefined;

        //

        this.width = params.width || 0;
        this.height = params.height || 0;

        this.zoom = params.zoom || 1;

        var position = params.position || new Vec3( 0, 0, 0, true );
        var rotation = params.rotation || new Vec3( 0, 0, 0, true );

        Object.defineProperties( this, {

            position: {
                enumerable: true,
                value: position
            },
            rotation: {
                enumerable: true,
                value: rotation
            }

        });

        //

        this.instanceof = 'Terrain';

    };

    Terrain.prototype = {

        constructor: Terrain

    };

    Terrain.prototype.init = function () {}; // reloads

    Terrain.prototype.clone = function () {

        // todo

    };

    Terrain.prototype.dispose = function () {

        // todo

    };

    NWE.fw.TerrainIdCount = 0;

    Terrain.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Terrain.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Terrain.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Terrain.setInternal = function ( name, value ) { internal[ name ] = value; };
    Terrain.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Terrain === 'function' ) {
        var t = {}, p = {};
        for ( var i in Terrain ) t[i] = Terrain[i];
        for ( var i in Terrain.prototype ) try { p[i] = Terrain.prototype[i] } catch(e) {};
        scope.Terrain = Terrain.bind( scope );
    } else {
        scope.Terrain = Terrain;
    }
    internal['constructor'] = Terrain;
    scope.Terrain.prototype = Terrain.prototype;
    for ( var i in t ) scope.Terrain[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Terrain.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Terrain ) {
        for ( var i = 0, il = scope.__Terrain.length; i < il; i ++ ) scope.__Terrain[ i ]( Terrain );
        delete scope.__Terrain;
    }

}) ( NWE.fw );


// src/framework/terrain/DynamicTerrain.js

( function ( scope ) {

    /*
     * @author ohmed
    */



    var Terrain = NWE.fw.Terrain;
    if ( !Terrain ) { NWE.fw.__Terrain = (NWE.fw.__Terrain || []); NWE.fw.__Terrain.push( function ( obj ) { Terrain = obj; } ); }


    var Mesh = NWE.gfx.Mesh;
    if ( !Mesh ) { NWE.gfx.__Mesh = (NWE.gfx.__Mesh || []); NWE.gfx.__Mesh.push( function ( obj ) { Mesh = obj; } ); }

    var PlaneGeometry = NWE.gfx.PlaneGeometry;
    if ( !PlaneGeometry ) { NWE.gfx.__PlaneGeometry = (NWE.gfx.__PlaneGeometry || []); NWE.gfx.__PlaneGeometry.push( function ( obj ) { PlaneGeometry = obj; } ); }

    var DynamicTerrainMaterial = NWE.gfx.DynamicTerrainMaterial;
    if ( !DynamicTerrainMaterial ) { NWE.gfx.__DynamicTerrainMaterial = (NWE.gfx.__DynamicTerrainMaterial || []); NWE.gfx.__DynamicTerrainMaterial.push( function ( obj ) { DynamicTerrainMaterial = obj; } ); }

    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }

    var Scene = NWE.gfx.Scene;
    if ( !Scene ) { NWE.gfx.__Scene = (NWE.gfx.__Scene || []); NWE.gfx.__Scene.push( function ( obj ) { Scene = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Sphere = NWE.Sphere;
    if ( !Sphere ) { NWE.__Sphere = (NWE.__Sphere || []); NWE.__Sphere.push( function ( obj ) { Sphere = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }


    var DynamicTerrain = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Terrain.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        // prepare canvas for mapping texture

        internal[ this.uuid ].mesh = null;
        internal[ this.uuid ].geometry = null;

        internal[ this.uuid ].mappingTextureCanvas = document.createElement('canvas');
        internal[ this.uuid ].mappingTextureCanvas.width = internal[ this.uuid ].mappingTextureCanvas.height = 1024;
        internal[ this.uuid ].mappingTextureCanvasCtx = internal[ this.uuid ].mappingTextureCanvas.getContext('2d');

        internal[ this.uuid ].material = new DynamicTerrainMaterial();
        internal[ this.uuid ].material.uniforms.mapping.value = new Texture( internal[ this.uuid ].mappingTextureCanvas );
        internal[ this.uuid ].material.uniforms.focusPoint.value = new Vec2();
        internal[ this.uuid ].material.uniforms.terrainSize.value = new Vec2( this.width, this.height );
        internal[ this.uuid ].material.uniforms.ambient.value = new Color( 0xffffff );

        //

        this.gridWidthNodeCount = params.gridWidthNodeCount || 2;
        this.gridHeightNodeCount = params.gridHeightNodeCount || 2;
        this.visiblePartSize = params.visiblePartSize || 600;

        //

        var visible;

        Object.defineProperty( this, 'visible', {

            get: function () {

                return visible;

            },

            set: function ( value ) {

                if ( internal[ this.uuid ].mesh ) {

                    internal[ this.uuid ].mesh.visible = value;

                }

                visible = value;

            },

            enumerable: true

        });

        //

        this.needsUpdate = true;

        //

        this.instanceof = 'DynamicTerrain';

    };

    DynamicTerrain.prototype = Object.create( Terrain.prototype );

    DynamicTerrain.prototype.init = function () {

        var size = this.visiblePartSize;
        var nodeCountW = this.gridWidthNodeCount;
        var nodeCountH = this.gridHeightNodeCount;

        var geometry;

        geometry = new PlaneGeometry( size, size, nodeCountW, nodeCountH );    
        geometry.applyMatrix( new Matrix4().makeRotationX( - Math.PI / 2 ) );

        geometry.boundingSphere = new Sphere();
        geometry.boundingSphere.center.set( 0, 0, 0 );
        geometry.boundingSphere.radius = window.Math.max( this.width, this.height );

        internal[ this.uuid ].mesh = new Mesh( geometry, internal[ this.uuid ].material );
        internal[ this.uuid ].mesh.parent = this;

        internal[ this.uuid ].geometry = geometry;

    };

    DynamicTerrain.prototype.setSize = function ( width, height ) {

        this.width = width;
        this.height = height;

        internal[ this.uuid ].material.uniforms.terrainSize.value.set( width, height );

    };

    DynamicTerrain.prototype.setAtlasTexture = function ( texture, density ) {

        if ( ! ( texture instanceof Texture ) ) {

            Logger.warn( 'NWE.fw.DynamicTerrain.setAtlasTexture(): atlasTexute needs to be Texture type.' );
            return;

        }

        density = density || 1;
        internal[ this.uuid ].material.uniforms.atlasTextureItemsPerRow.value = density;

        internal[ this.uuid ].material.uniforms.atlasTexute.value = texture;
        internal[ this.uuid ].material.uniforms.atlasTexute.needsUpdate = true;

    };

    DynamicTerrain.prototype.setMapping = function ( mapping ) {

        if ( ! ( mapping instanceof Image || mapping.nodeName === 'CANVAS' ) ) {

            Logger.warn( 'NWE.fw.DynamicTerrain.setMapping(): mapping needs to be Image type.' );
            return;

        }

        internal[ this.uuid ].material.uniforms.mapping.value = new Texture( mapping );
        internal[ this.uuid ].material.uniforms.mapping.needsUpdate = true;

    };

    DynamicTerrain.prototype.updateMapping = function () {

        internal[ this.uuid ].material.uniforms.mapping.needsUpdate = true;
        internal[ this.uuid ].material.uniforms.mapping.value.needsUpdate = true;

    };

    DynamicTerrain.prototype.setZoom = function ( value ) {

        internal[ this.uuid ].material.uniforms.zoom.value = value;

    };

    DynamicTerrain.prototype.update = function ( scene, camera ) {

        var x = camera.position.x - this.position.x;
        var y = camera.position.y - this.position.y;
        var z = camera.position.z - this.position.z;

        var camRotation = camera.rotation;

        var focus = internal[ this.uuid ].material.uniforms.focusPoint.value;
        var zoom = internal[ this.uuid ].material.uniforms.zoom.value;
        var realVisiblePartSize = zoom * this.visiblePartSize;

        var kW = realVisiblePartSize / ( this.gridWidthNodeCount - 1 );
        var kH = realVisiblePartSize / ( this.gridHeightNodeCount - 1 );

        focus.set(
            kW * window.Math.floor(   ( x - 150 * window.Math.sin( camRotation.y ) ) / kW ),
            kH * window.Math.floor( - ( z - 150 * window.Math.cos( camRotation.y ) ) / kH )
        );

        focus.x = window.Math.max( focus.x, -1 * ( this.width / 2 - realVisiblePartSize / 2 ) );
        focus.y = window.Math.max( focus.y, -1 * ( this.height / 2 - realVisiblePartSize / 2 ) );

        focus.x = window.Math.min( focus.x,  1 * ( this.width / 2 - realVisiblePartSize / 2 ) );
        focus.y = window.Math.min( focus.y,  1 * ( this.height / 2 - realVisiblePartSize / 2 ) );

        if ( internal[ this.uuid ].mesh ) {

            internal[ this.uuid ].mesh.position.set( this.position.x, this.position.y, this.position.z );

        }

    };

    DynamicTerrain.prototype.clone = function () {

        // todo

    };

    DynamicTerrain.prototype.dispose = function () {

        // todo

    };

    Scene.registerObject( 'DynamicTerrain', function ( object ) {

        object.init();

        object.getInternal( 'mesh' ).visible = object.visible;

        this.add( object.getInternal( 'mesh' ) );

    }, function ( object ) {

        // todo

    });

    DynamicTerrain.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    DynamicTerrain.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    DynamicTerrain.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    DynamicTerrain.setInternal = function ( name, value ) { internal[ name ] = value; };
    DynamicTerrain.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof DynamicTerrain === 'function' ) {
        var t = {}, p = {};
        for ( var i in DynamicTerrain ) t[i] = DynamicTerrain[i];
        for ( var i in DynamicTerrain.prototype ) try { p[i] = DynamicTerrain.prototype[i] } catch(e) {};
        scope.DynamicTerrain = DynamicTerrain.bind( scope );
    } else {
        scope.DynamicTerrain = DynamicTerrain;
    }
    internal['constructor'] = DynamicTerrain;
    scope.DynamicTerrain.prototype = DynamicTerrain.prototype;
    for ( var i in t ) scope.DynamicTerrain[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DynamicTerrain.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DynamicTerrain ) {
        for ( var i = 0, il = scope.__DynamicTerrain.length; i < il; i ++ ) scope.__DynamicTerrain[ i ]( DynamicTerrain );
        delete scope.__DynamicTerrain;
    }

}) ( NWE.fw );


// src/framework/terrain/StaticTerrain.js

( function ( scope ) {

    /*
     * @author ohmed
    */



    var Terrain = NWE.fw.Terrain;
    if ( !Terrain ) { NWE.fw.__Terrain = (NWE.fw.__Terrain || []); NWE.fw.__Terrain.push( function ( obj ) { Terrain = obj; } ); }


    var Mesh = NWE.gfx.Mesh;
    if ( !Mesh ) { NWE.gfx.__Mesh = (NWE.gfx.__Mesh || []); NWE.gfx.__Mesh.push( function ( obj ) { Mesh = obj; } ); }

    var Geometry = NWE.gfx.Geometry;
    if ( !Geometry ) { NWE.gfx.__Geometry = (NWE.gfx.__Geometry || []); NWE.gfx.__Geometry.push( function ( obj ) { Geometry = obj; } ); }

    var PlaneGeometry = NWE.gfx.PlaneGeometry;
    if ( !PlaneGeometry ) { NWE.gfx.__PlaneGeometry = (NWE.gfx.__PlaneGeometry || []); NWE.gfx.__PlaneGeometry.push( function ( obj ) { PlaneGeometry = obj; } ); }

    var StaticTerrainMaterial = NWE.gfx.StaticTerrainMaterial;
    if ( !StaticTerrainMaterial ) { NWE.gfx.__StaticTerrainMaterial = (NWE.gfx.__StaticTerrainMaterial || []); NWE.gfx.__StaticTerrainMaterial.push( function ( obj ) { StaticTerrainMaterial = obj; } ); }

    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }

    var LOD = NWE.gfx.LOD;
    if ( !LOD ) { NWE.gfx.__LOD = (NWE.gfx.__LOD || []); NWE.gfx.__LOD.push( function ( obj ) { LOD = obj; } ); }

    var Camera = NWE.gfx.Camera;
    if ( !Camera ) { NWE.gfx.__Camera = (NWE.gfx.__Camera || []); NWE.gfx.__Camera.push( function ( obj ) { Camera = obj; } ); }

    var Scene = NWE.gfx.Scene;
    if ( !Scene ) { NWE.gfx.__Scene = (NWE.gfx.__Scene || []); NWE.gfx.__Scene.push( function ( obj ) { Scene = obj; } ); }


    var Sphere = NWE.Sphere;
    if ( !Sphere ) { NWE.__Sphere = (NWE.__Sphere || []); NWE.__Sphere.push( function ( obj ) { Sphere = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Vec2 = NWE.Vec2;
    if ( !Vec2 ) { NWE.__Vec2 = (NWE.__Vec2 || []); NWE.__Vec2.push( function ( obj ) { Vec2 = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var StaticTerrain = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Terrain.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.blocksXCount = params.blocksXCount || 0;
        this.blocksYCount = params.blocksYCount || 0;

        this.blocks = [];

        //

        var visible;

        Object.defineProperty( this, 'visible', {

            get: function () {

                return visible;

            },

            set: function ( value ) {

                for ( var i = 0, il = this.blocks.length; i < il; i ++ ) {

                    this.blocks[ i ].object.visible = value;

                }

                visible = value;

            },

            enumerable: true

        });

        //

        this.instanceof = 'StaticTerrain';

    };

    StaticTerrain.prototype = Object.create( Terrain.prototype );

    StaticTerrain.prototype.setup = function () {

        var block;
        var blockWidth = this.zoom * this.width / this.blocksXCount;
        var blockHeight = this.zoom * this.height / this.blocksYCount;

        var startPosition = new Vec3( - this.zoom * this.width / 2  + 0.5 * blockWidth, 0, - this.zoom * this.height / 2 + 0.5 * blockHeight );
        var position = new Vec3();

        for ( var i = 0; i < this.blocksYCount; i ++ ) {

            for ( var j = 0; j < this.blocksXCount; j ++ ) {

                position.x = startPosition.x + j * blockWidth;
                position.z = startPosition.z + i * blockHeight;

                block = this.addBlock({
                    width: blockWidth,
                    height: blockHeight,
                    zoom: this.zoom,
                    position: position.clone(),
                    parent: this
                });

            }

        }

        var self = this;

        this.position.onUpdate = function ( dx, dy, dz ) {

            for ( var i = 0, il = self.blocks.length; i < il; i ++ ) {

                self.blocks[ i ].position.x += dx;
                self.blocks[ i ].position.y += dy;
                self.blocks[ i ].position.z += dz;

            }

        };

        this.rotation.onUpdate = function () {

            for ( var i = 0, il = self.blocks.length; i < il; i ++ ) {

                // todo

            }

        };

    };

    StaticTerrain.prototype.init = function () {

        for ( var i = 0, il = this.blocks.length; i < il; i ++ ) {

            this.blocks[ i ].init();

        }

    };

    StaticTerrain.prototype.addBlock = function ( params ) {

        var block = new StaticTerrainBlock( params );
        this.blocks.push( block );

        return block;

    };

    StaticTerrain.prototype.setSize = function ( width, height ) {

        this.width = width;
        this.height = height;

        internal[ this.uuid ].material.uniforms.terrainSize.value.set( width, height );

    };

    StaticTerrain.prototype.update = function ( camera ) {

        if ( ! ( camera instanceof Camera ) ) {

            Logger.warn( 'NWE.fw.StaticTerrain.update(): camera needs to be Camera type.' );
            return;

        }

        for ( var i = 0, il = this.blocks.length; i < il; i ++ ) {

            this.blocks[ i ].object.update( camera );

        }

    };

    StaticTerrain.prototype.matchEdges = function () {

        for ( var j = 0; j < this.blocksYCount; j ++ ) {

            for ( var i = 1; i < this.blocksXCount; i ++ ) {

                var block1Geo = this.blocks[ i - 1 + this.blocksXCount * j ];
                var block2Geo = this.blocks[ i + this.blocksXCount * j ];

                if ( block1Geo.enabled === false || block2Geo.enabled === false ) continue;

                block1Geo = block1Geo.object.objects[ 0 ].object.geometry;
                block2Geo = block2Geo.object.objects[ 0 ].object.geometry;

                for ( var k = 0, kl = block1Geo.attributes.position.array.length; k < kl; k += block1Geo.blockSize ) {

                    if ( block1Geo.attributes.position.array[ k ] < 1000 ) continue;

                    for ( var p = 0, pl = block2Geo.attributes.position.array.length; p < pl; p += block1Geo.blockSize ) {

                        if ( block2Geo.attributes.position.array[ p ] > -990 ) continue;

                        if ( window.Math.abs( block2Geo.attributes.position.array[ p     ] - block1Geo.attributes.position.array[ k     ] + 2033 ) < 5 &&
                             window.Math.abs( block1Geo.attributes.position.array[ k + 2 ] - block2Geo.attributes.position.array[ p + 2 ] ) < 5
                         ) {

                            block1Geo.attributes.position.array[ k + 0 ] = 2033 + block2Geo.attributes.position.array[ p + 0 ];
                            block1Geo.attributes.position.array[ k + 1 ] = block2Geo.attributes.position.array[ p + 1 ];
                            block1Geo.attributes.position.array[ k + 2 ] = block2Geo.attributes.position.array[ p + 2 ];

                            block1Geo.attributes.normal.array[ k + 0 ] = block2Geo.attributes.normal.array[ p + 0 ];
                            block1Geo.attributes.normal.array[ k + 1 ] = block2Geo.attributes.normal.array[ p + 1 ];
                            block1Geo.attributes.normal.array[ k + 2 ] = block2Geo.attributes.normal.array[ p + 2 ];

                        }

                    }

                }

            }

        }

        //

        for ( var i = 0; i < this.blocksXCount; i ++ ) {

            for ( var j = 1; j < this.blocksYCount; j ++ ) {

                var block1Geo = this.blocks[ i + this.blocksXCount * (j - 1) ];
                var block2Geo = this.blocks[ i + this.blocksXCount * j       ];

                if ( block1Geo.enabled === false || block2Geo.enabled === false ) continue;

                block1Geo = block1Geo.object.objects[ 0 ].object.geometry;
                block2Geo = block2Geo.object.objects[ 0 ].object.geometry;

                for ( var k = 0, kl = block1Geo.attributes.position.array.length; k < kl; k += block1Geo.blockSize ) {

                    if ( block1Geo.attributes.position.array[ k + 2 ] < 1000 ) continue;

                    for ( var p = 0, pl = block2Geo.attributes.position.array.length; p < pl; p += block1Geo.blockSize ) {

                        if ( block2Geo.attributes.position.array[ p + 2 ] > -990 ) continue;

                        if ( window.Math.abs( block2Geo.attributes.position.array[ p + 2 ] - block1Geo.attributes.position.array[ k + 2 ] + 2033 ) < 10 &&
                             window.Math.abs( block1Geo.attributes.position.array[ k     ] - block2Geo.attributes.position.array[ p     ] ) < 10
                         ) {

                            block1Geo.attributes.position.array[ k + 0 ] = block2Geo.attributes.position.array[ p + 0 ];
                            block1Geo.attributes.position.array[ k + 1 ] = block2Geo.attributes.position.array[ p + 1 ];
                            block1Geo.attributes.position.array[ k + 2 ] = 2033 + block2Geo.attributes.position.array[ p + 2 ];

                            block1Geo.attributes.normal.array[ k + 0 ] = block2Geo.attributes.normal.array[ p + 0 ];
                            block1Geo.attributes.normal.array[ k + 1 ] = block2Geo.attributes.normal.array[ p + 1 ];
                            block1Geo.attributes.normal.array[ k + 2 ] = block2Geo.attributes.normal.array[ p + 2 ];

                        }

                    }

                }

            }

        }

    };

    //

    var StaticTerrainBlock = function ( params ) {

        params = params || {};

        this.uuid = Math.generateUUID();

        internal[ this.uuid ] = {};

        this.width = params.width || 100;
        this.height = params.height || 100;
        this.zoom = params.zoom || 1;

        this.position = params.position || new Vec3();

        this.parent = params.parent || null;

        this.enabled = true;

        //

        this.object = new LOD();
        this.object.parent = this;

        this.material = new StaticTerrainMaterial();
        this.material.uniforms.ambient.value = new Color( 0xcccccc );
        this.material.uniforms.terrainSize.value = new Vec2( this.width, this.height );

        //

        this.instanceof = 'StaticTerrainBlock';

    };

    StaticTerrainBlock.prototype = {};

    StaticTerrainBlock.prototype.init = function () {

        this.object.position = this.position;

        if ( ! this.object.objects.length && this.enabled === true ) {

            this.setGeometryLevel( undefined, 800 );

        }

    };

    StaticTerrainBlock.prototype.setAtlasTexture = function ( texture, density ) {

        if ( ! ( texture instanceof Texture ) ) {

            Logger.warn( 'NWE.fw.StaticTerrain StaticTerrainBlock.setAtlasTexture(): atlasTexute needs to be Texture type.' );
            return;

        }

        density = density || 1;
        this.material.uniforms.atlasTextureItemsPerRow.value = density;

        this.material.uniforms.atlasTexute.value = texture;
        this.material.uniforms.atlasTexute.needsUpdate = true;

    };

    StaticTerrainBlock.prototype.useMappingTexture = function ( mapping ) {

        if ( ! ( mapping instanceof Image ) ) {

            Logger.warn( 'NWE.fw.StaticTerrain StaticTerrainBlock.useMappingTexture(): mapping needs to be Image type.' );
            return;

        }

        this.material.uniforms.globalTexture.value = null;

        this.material.uniforms.mapping.value = new Texture( mapping );
        this.material.uniforms.mapping.needsUpdate = true;

        this.material.uniforms.useGlobalTexture.value = 0;
        this.material.uniforms.useGlobalTexture.needsUpdate = true;

    };

    StaticTerrainBlock.prototype.setTextureRepeat = function ( value ) {

        this.material.uniforms.textureRepeatCoef.value = value;

    };

    StaticTerrainBlock.prototype.useStretchedTexture = function ( texture ) {

        if ( ! ( texture instanceof Texture ) ) {

            Logger.warn( 'NWE.fw.StaticTerrain StaticTerrainBlock.globalTexture(): texture needs to be Texture type.' );
            return;

        }

        this.material.uniforms.mapping.value = null;

        this.material.uniforms.globalTexture.value = texture;
        this.material.uniforms.globalTexture.needsUpdate = true;

        this.material.uniforms.useGlobalTexture.value = 1;

    };

    StaticTerrainBlock.prototype.setGeometryLevel = function ( geometry, distance ) {

        if ( ! ( geometry instanceof Geometry ) && geometry !== undefined ) {

            Logger.warn( 'NWE.fw.StaticTerrain StaticTerrainBlock.setGeometryLevel(): geometry needs to be Geometry type.' );
            return;

        }

        if ( ! geometry ) {

            geometry = new PlaneGeometry( this.width / this.zoom, this.height / this.zoom, 2, 2 );    
            geometry.applyMatrix( new Matrix4().makeRotationX( - window.Math.PI / 2 ) );

        }

        geometry.boundingSphere = new Sphere();
        geometry.boundingSphere.center.set( 0, 0, 0 );
        geometry.boundingSphere.radius = window.Math.max( this.width, this.height );

        var mesh = new Mesh( geometry, this.material );
        mesh.scale.set( this.zoom );

        this.object.addLevel( mesh, distance );

    };

    StaticTerrain.prototype.clone = function () {

        // todo

    };

    StaticTerrain.prototype.dispose = function () {

        // todo

    };

    Scene.registerObject( 'StaticTerrain', function ( object ) {

        object.init();

        for ( var i = 0, il = object.blocks.length; i < il; i ++ ) {

            object.blocks[ i ].object.visible = object.visible;

            this.add( object.blocks[ i ].object );

        }

    }, function ( object ) {

        // todo

    });

    StaticTerrain.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    StaticTerrain.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    StaticTerrain.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    StaticTerrain.setInternal = function ( name, value ) { internal[ name ] = value; };
    StaticTerrain.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof StaticTerrain === 'function' ) {
        var t = {}, p = {};
        for ( var i in StaticTerrain ) t[i] = StaticTerrain[i];
        for ( var i in StaticTerrain.prototype ) try { p[i] = StaticTerrain.prototype[i] } catch(e) {};
        scope.StaticTerrain = StaticTerrain.bind( scope );
    } else {
        scope.StaticTerrain = StaticTerrain;
    }
    internal['constructor'] = StaticTerrain;
    scope.StaticTerrain.prototype = StaticTerrain.prototype;
    for ( var i in t ) scope.StaticTerrain[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.StaticTerrain.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__StaticTerrain ) {
        for ( var i = 0, il = scope.__StaticTerrain.length; i < il; i ++ ) scope.__StaticTerrain[ i ]( StaticTerrain );
        delete scope.__StaticTerrain;
    }

}) ( NWE.fw );


// src/framework/materials/DynamicGroupMaterial.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var DynamicGroupMaterial = function ( params, objInternal ) {

        params = params || {};

        this.shaderID = 'DynamicGroup';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.setValues( params );

        this.instanceof = 'DynamicGroupMaterial';

    };

    DynamicGroupMaterial.prototype = Object.create( Material.prototype );

    DynamicGroupMaterial.prototype.clone = function () {

        var material = new DynamicGroupMaterial();

        Material.prototype.clone.call( this, material );

        return material;

    };

    DynamicGroupMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    DynamicGroupMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    DynamicGroupMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    DynamicGroupMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    DynamicGroupMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof DynamicGroupMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in DynamicGroupMaterial ) t[i] = DynamicGroupMaterial[i];
        for ( var i in DynamicGroupMaterial.prototype ) try { p[i] = DynamicGroupMaterial.prototype[i] } catch(e) {};
        scope.DynamicGroupMaterial = DynamicGroupMaterial.bind( scope );
    } else {
        scope.DynamicGroupMaterial = DynamicGroupMaterial;
    }
    internal['constructor'] = DynamicGroupMaterial;
    scope.DynamicGroupMaterial.prototype = DynamicGroupMaterial.prototype;
    for ( var i in t ) scope.DynamicGroupMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DynamicGroupMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DynamicGroupMaterial ) {
        for ( var i = 0, il = scope.__DynamicGroupMaterial.length; i < il; i ++ ) scope.__DynamicGroupMaterial[ i ]( DynamicGroupMaterial );
        delete scope.__DynamicGroupMaterial;
    }

}) ( NWE.gfx );


// src/framework/materials/StaticGroupMaterial.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var StaticGroupMaterial = function ( params, objInternal ) {

        params = params || {};

        this.shaderID = 'StaticGroup';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.setValues( params );

        this.instanceof = 'StaticGroupMaterial';

    };

    StaticGroupMaterial.prototype = Object.create( Material.prototype );

    StaticGroupMaterial.prototype.clone = function () {

        var material = new StaticGroupMaterial();

        Material.prototype.clone.call( this, material );

        return material;

    };

    StaticGroupMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    StaticGroupMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    StaticGroupMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    StaticGroupMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    StaticGroupMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof StaticGroupMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in StaticGroupMaterial ) t[i] = StaticGroupMaterial[i];
        for ( var i in StaticGroupMaterial.prototype ) try { p[i] = StaticGroupMaterial.prototype[i] } catch(e) {};
        scope.StaticGroupMaterial = StaticGroupMaterial.bind( scope );
    } else {
        scope.StaticGroupMaterial = StaticGroupMaterial;
    }
    internal['constructor'] = StaticGroupMaterial;
    scope.StaticGroupMaterial.prototype = StaticGroupMaterial.prototype;
    for ( var i in t ) scope.StaticGroupMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.StaticGroupMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__StaticGroupMaterial ) {
        for ( var i = 0, il = scope.__StaticGroupMaterial.length; i < il; i ++ ) scope.__StaticGroupMaterial[ i ]( StaticGroupMaterial );
        delete scope.__StaticGroupMaterial;
    }

}) ( NWE.gfx );


// src/framework/materials/DynamicTerrainMaterial.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var DynamicTerrainMaterial = function ( params, objInternal ) {

        params = params || {};

        this.shaderID = 'DynamicTerrain';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.setValues( params );

        this.instanceof = 'DynamicTerrainMaterial';

    };

    DynamicTerrainMaterial.prototype = Object.create( Material.prototype );

    DynamicTerrainMaterial.prototype.clone = function () {

        var material = new DynamicTerrainMaterial();

        Material.prototype.clone.call( this, material );

        return material;

    };

    DynamicTerrainMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    DynamicTerrainMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    DynamicTerrainMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    DynamicTerrainMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    DynamicTerrainMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof DynamicTerrainMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in DynamicTerrainMaterial ) t[i] = DynamicTerrainMaterial[i];
        for ( var i in DynamicTerrainMaterial.prototype ) try { p[i] = DynamicTerrainMaterial.prototype[i] } catch(e) {};
        scope.DynamicTerrainMaterial = DynamicTerrainMaterial.bind( scope );
    } else {
        scope.DynamicTerrainMaterial = DynamicTerrainMaterial;
    }
    internal['constructor'] = DynamicTerrainMaterial;
    scope.DynamicTerrainMaterial.prototype = DynamicTerrainMaterial.prototype;
    for ( var i in t ) scope.DynamicTerrainMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DynamicTerrainMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DynamicTerrainMaterial ) {
        for ( var i = 0, il = scope.__DynamicTerrainMaterial.length; i < il; i ++ ) scope.__DynamicTerrainMaterial[ i ]( DynamicTerrainMaterial );
        delete scope.__DynamicTerrainMaterial;
    }

}) ( NWE.gfx );


// src/framework/materials/StaticTerrainMaterial.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var StaticTerrainMaterial = function ( params, objInternal ) {

        params = params || {};

        this.shaderID = 'StaticTerrain';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.setValues( params );

        this.instanceof = 'StaticTerrainMaterial';

    };

    StaticTerrainMaterial.prototype = Object.create( Material.prototype );

    StaticTerrainMaterial.prototype.clone = function () {

        var material = new StaticTerrainMaterial();

        Material.prototype.clone.call( this, material );

        return material;

    };

    StaticTerrainMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    StaticTerrainMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    StaticTerrainMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    StaticTerrainMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    StaticTerrainMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof StaticTerrainMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in StaticTerrainMaterial ) t[i] = StaticTerrainMaterial[i];
        for ( var i in StaticTerrainMaterial.prototype ) try { p[i] = StaticTerrainMaterial.prototype[i] } catch(e) {};
        scope.StaticTerrainMaterial = StaticTerrainMaterial.bind( scope );
    } else {
        scope.StaticTerrainMaterial = StaticTerrainMaterial;
    }
    internal['constructor'] = StaticTerrainMaterial;
    scope.StaticTerrainMaterial.prototype = StaticTerrainMaterial.prototype;
    for ( var i in t ) scope.StaticTerrainMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.StaticTerrainMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__StaticTerrainMaterial ) {
        for ( var i = 0, il = scope.__StaticTerrainMaterial.length; i < il; i ++ ) scope.__StaticTerrainMaterial[ i ]( StaticTerrainMaterial );
        delete scope.__StaticTerrainMaterial;
    }

}) ( NWE.gfx );


// src/framework/materials/SnowMaterial.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }


    var SnowMaterial = function ( params, objInternal ) {

        params = params || {};

        this.shaderID = 'Snow';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.setValues( params );

        this.uniforms['size'].value = params.size || this.uniforms['size'].value;
        this.uniforms['scale'].value = params.scale || this.uniforms['scale'].value;
        this.uniforms['speed'].value = params.speed || this.uniforms['speed'].value;
        this.uniforms['map'].value = params.map || this.uniforms['map'].value;

        this.programId = Infinity;

        this.instanceof = 'SnowMaterial';

    };

    SnowMaterial.prototype = Object.create( Material.prototype );

    SnowMaterial.prototype.clone = function () {

        var material = new SnowMaterial();

        Material.prototype.clone.call( this, material );

        return material;

    };

    SnowMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    SnowMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    SnowMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    SnowMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    SnowMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof SnowMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in SnowMaterial ) t[i] = SnowMaterial[i];
        for ( var i in SnowMaterial.prototype ) try { p[i] = SnowMaterial.prototype[i] } catch(e) {};
        scope.SnowMaterial = SnowMaterial.bind( scope );
    } else {
        scope.SnowMaterial = SnowMaterial;
    }
    internal['constructor'] = SnowMaterial;
    scope.SnowMaterial.prototype = SnowMaterial.prototype;
    for ( var i in t ) scope.SnowMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.SnowMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__SnowMaterial ) {
        for ( var i = 0, il = scope.__SnowMaterial.length; i < il; i ++ ) scope.__SnowMaterial[ i ]( SnowMaterial );
        delete scope.__SnowMaterial;
    }

}) ( NWE.gfx );


// src/framework/materials/MirrorMaterial.js

( function ( scope ) {

    /**
     * @author ohmed
     */



    var Material = NWE.gfx.Material;
    if ( !Material ) { NWE.gfx.__Material = (NWE.gfx.__Material || []); NWE.gfx.__Material.push( function ( obj ) { Material = obj; } ); }

    var Const = NWE.gfx.Const;
    if ( !Const ) { NWE.gfx.__Const = (NWE.gfx.__Const || []); NWE.gfx.__Const.push( function ( obj ) { Const = obj; } ); }

    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }


    var MirrorMaterial = function ( params, objInternal ) {

        params = params || {};

        this.shaderID = 'Mirror';

        objInternal = objInternal || {};
        Material.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.setValues( params );

        this.uniforms['textureMatrix'].value = new Matrix4();
        this.uniforms['mirrorColor'].value = params.mirrorColor || new Color( 0x7F7F7F );

        this.instanceof = 'MirrorMaterial';

    };

    MirrorMaterial.prototype = Object.create( Material.prototype );

    MirrorMaterial.prototype.clone = function () {

        var material = new MirrorMaterial();

        Material.prototype.clone.call( this, material );

        return material;

    };

    MirrorMaterial.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    MirrorMaterial.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    MirrorMaterial.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    MirrorMaterial.setInternal = function ( name, value ) { internal[ name ] = value; };
    MirrorMaterial.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof MirrorMaterial === 'function' ) {
        var t = {}, p = {};
        for ( var i in MirrorMaterial ) t[i] = MirrorMaterial[i];
        for ( var i in MirrorMaterial.prototype ) try { p[i] = MirrorMaterial.prototype[i] } catch(e) {};
        scope.MirrorMaterial = MirrorMaterial.bind( scope );
    } else {
        scope.MirrorMaterial = MirrorMaterial;
    }
    internal['constructor'] = MirrorMaterial;
    scope.MirrorMaterial.prototype = MirrorMaterial.prototype;
    for ( var i in t ) scope.MirrorMaterial[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.MirrorMaterial.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__MirrorMaterial ) {
        for ( var i = 0, il = scope.__MirrorMaterial.length; i < il; i ++ ) scope.__MirrorMaterial[ i ]( MirrorMaterial );
        delete scope.__MirrorMaterial;
    }

}) ( NWE.gfx );


// src/framework/shaders/DynamicGroupShader.js

( function ( scope ) {

    /**
     * @author ohmed
     * dynamic group shader
     */

    var DynamicGroup = function () {

        this.defines = {

        };

        this.attributes = {

            'position': { type: 'v3' },
            'normal':   { type: 'v3' },
            'uv':       { type: 'v2' },

            'vertex_index':     { type: 'f' },
            'instance_index':   { type: 'f' },
            'texture_index':    { type: 'f' }

        };

        this.uniforms = {

            'INSTANCES_PER_BLOCK':  { type: 'f', value: 0 },
            'PARAM_TEXTURE_W_DEF':  { type: 'f', value: 0 },
            'PARAM_TEXTURE_H_DEF':  { type: 'f', value: 0 },
            'BLOCK_SIZE':           { type: 'f', value: 0 },

            'instanceParamsTexture':    { type: 't', value: null },
            'atlasTexture':             { type: 't', value: null },
            'atlasTextureItemsPerRow':  { type: 'f', value: 1 },

            'modelViewMatrix':  { type: 'm4', value: null, global: 2 },
            'projectionMatrix': { type: 'm4', value: null, global: 2 }

        };

        this.varyings = {

            'vUv':          { type: 'v2' },
            'vNormal':      { type: 'v3' },
            'textureIndex': { type: 'f' },

        };

        this.vertexShader = {

            manipulateVertex: [

                'vec3 rotatePoint ( vec3 pos, float alpha ) {',

                '   return vec3( pos.x * cos(-alpha) - pos.z * sin(-alpha), pos.y, pos.x * sin(-alpha) + pos.z * cos(-alpha) );',

                '}',

                'void manipuldateVertex () {',

                '   vUv = uv;',
                '   vNormal = normal;',

                '   textureIndex = mod( instance_index, 1000.0 );',
                '   float instance_type = floor( instance_index / 1000.0 );',

                '   // instance ID',

                '   float instanceID = mod( instance_index, INSTANCES_PER_BLOCK );',
                '   float offset = 1.0 - 3.0 * PARAM_TEXTURE_H_DEF * instance_type - PARAM_TEXTURE_H_DEF / 2.0;',

                '   //',

                '   float u = PARAM_TEXTURE_W_DEF * ( instanceID + 0.5 );',
                '   vec3 posDataPart1 = texture2D( instanceParamsTexture, vec2( u, offset ) ).rgb;',
                '   vec3 posDataPart2 = texture2D( instanceParamsTexture, vec2( u, offset - PARAM_TEXTURE_H_DEF ) ).rgb;',
                '   vec4 stateData    = texture2D( instanceParamsTexture, vec2( u, offset - 2.0 * PARAM_TEXTURE_H_DEF ) ).rgba;',

                '   vec3 pos = BLOCK_SIZE * ( posDataPart1 + posDataPart2 ) - BLOCK_SIZE;',

                '   float rotationY = 2.0 * 3.14 * stateData[0];',

                '   // set rotation for normals',
                '   vNormal = rotatePoint( vNormal, rotationY );',

                '   vec3 newPosition = position;',

                '   float scale = 255.0 * stateData[1];',

                '   newPosition = scale * rotatePoint( newPosition, rotationY ) + pos;',

                '   gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );',

                '}'

            ].join('\n'),

            main: [

                'void main () {',
                '   manipuldateVertex();',
                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            manipulatePixel: [

                'void manipulatePixel () {',

                '   if ( textureIndex < 0.0 ) {',

                '       discard;',

                '   }',

                '   // texturing',
                '   float fTextureIndex = floor( textureIndex + 0.5 );',
                '   vec2 offset = vec2( mod( fTextureIndex, atlasTextureItemsPerRow ), floor( fTextureIndex / atlasTextureItemsPerRow ) );',

                '   vec2 uv = mod( vUv - 50.0, 1.0 );',
                '   uv = ( vec2( 0.03 + 0.94 * min( uv, 1.0 - uv ) ) + offset ) / atlasTextureItemsPerRow;',
                '   gl_FragColor = texture2D( atlasTexture, uv ).rgba;',

                '   if ( gl_FragColor[3] < 0.1 ) {',

                '       discard;',

                '   }',

                '}'

            ].join('\n'),

            main: [

                'void main () {',
                '    manipulatePixel();',
                '}'

            ].join('\n')

        };

    };

    if ( typeof DynamicGroup === 'function' ) {
        var t = {}, p = {};
        for ( var i in DynamicGroup ) t[i] = DynamicGroup[i];
        for ( var i in DynamicGroup.prototype ) try { p[i] = DynamicGroup.prototype[i] } catch(e) {};
        scope.DynamicGroup = DynamicGroup.bind( scope );
    } else {
        scope.DynamicGroup = DynamicGroup;
    }
    scope.DynamicGroup.prototype = DynamicGroup.prototype;
    for ( var i in t ) scope.DynamicGroup[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DynamicGroup.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DynamicGroup ) {
        for ( var i = 0, il = scope.__DynamicGroup.length; i < il; i ++ ) scope.__DynamicGroup[ i ]( DynamicGroup );
        delete scope.__DynamicGroup;
    }

}) ( NWE.gfx.ShaderLib );


// src/framework/shaders/StaticGroupShader.js

( function ( scope ) {

    /**
     * @author ohmed
     * static group shader
     */

    var StaticGroup = function () {

        this.defines = {

            'USE_SHADOWMAP': '1',
            'MAX_SHADOWS':   '1'

        };

        this.attributes = {

            'position': { type: 'v3' },
            'normal':   { type: 'v3' },
            'uv':       { type: 'v2' },
            'uvOffset': { type: 'v2' }

        };

        this.uniforms = {

            'ambientLightColor':    { type: 'c', value: null, global: 2 },
            'ambient':              { type: 'c', value: null, global: -1 },

            'alphaTest':            { type: 'f', value: 0, global: -1 },

            'atlasTexture':             { type: 't', value: null, global: -1 },
            'atlasTextureItemsPerRow':  { type: 'f', value: 1, global: -1 },

            'fogDensity':           { type: 'f', value: 0.00025, global: 2 },
            'fogNear':              { type: 'f', value: 1, global: 2 },
            'fogFar':               { type: 'f', value: 2000, global: 2 },
            'fogColor':             { type: 'c', value: null, global: 2 },

            'modelViewMatrix':  { type: 'm4', value: null, global: -1 },
            'projectionMatrix': { type: 'm4', value: null, global: -1 },
            'modelMatrix':      { type: 'm4', value: null, global: -1 },

            'shadowMatrix':     { type: 'm4v', value: [], size: 5, global: -1 },

            'shadowMap':        { type: 'tv', value: [], size: 5, global: -1 },
            'shadowMapSize':    { type: 'v2v', value: [], size: 5, global: -1 },

            'shadowDarkness':   { type: 'fv1', value: [], size: 5, global: -1 },
            'shadowBias':       { type: 'fv1', value: [], size: 5, global: -1 }

        };

        this.varyings = {

            'vUv':          { type: 'v2' },
            'vNormal':      { type: 'v3' },
            'vShadowCoord': { type: 'v4', size: 5 }

        };

        this.vertexShader = {

            manipulateVertex: [

                'void manipuldateVertex () {',

                '    vUv = vec2( 0.03 / atlasTextureItemsPerRow + 0.94 * mod( uv, 1.0 ) + uvOffset );',
                '    vNormal = normal;',

                '    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

                '}'

            ].join('\n'),

            main: [

                'void main () {',

                '    manipuldateVertex();',

                '    #ifdef USE_SHADOWMAP',

                '        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',

                '        for ( int i = 0; i < MAX_SHADOWS; i ++ ) {',

                '            vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;',

                '        }',

                '    #endif',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            unpackDepth: [

                'float unpackDepth ( const in vec4 rgba_depth ) {',

                '    const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );',
                '    float depth = dot( rgba_depth, bit_shift );',
                '    return depth;',

                '}'

            ].join('\n'),

            inputToLinear: [
                
                'vec3 inputToLinear ( in vec3 a ) {',

                '    #ifdef GAMMA_INPUT',

                '        return pow( a, vec3( float( GAMMA_FACTOR ) ) );',

                '     #else',

                '        return a;',

                '    #endif',

                '}'

            ].join('\n'),

            manipulatePixel: [

                'void manipulatePixel () {',

                '    vec3 sunDirrection = vec3( 0.5, 0.5, 0.5 );',

                '    // texturing',
                '    gl_FragColor = texture2D( atlasTexture, vUv ).rgba;',

                '    #ifdef ALPHATEST',

                '        if ( gl_FragColor[3] < alphaTest ) {',

                '            discard;',

                '        }',

                '    #endif',

                '    vec3 light = vec3( min( 1.0, max( 0.0, dot( vNormal, normalize(sunDirrection) ) ) ) ) * ambientLightColor * ambient + ambientLightColor * ambient * 0.5;',
                '    gl_FragColor = vec4( gl_FragColor.rgb * light, gl_FragColor.a );',

                '    #ifdef USE_FOG',

                '        float depth = gl_FragCoord.z / gl_FragCoord.w;',

                '        #ifdef FOG_EXP2',

                '            const float LOG2 = 1.442695;',
                '            float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
                '            fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

                '         #else',

                '             float fogFactor = smoothstep( fogNear, fogFar, depth );',

                '         #endif',

                '         gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

                '     #endif',

                '}'

            ].join('\n'),

            main: [

                'void main () {',

                '    manipulatePixel();',

                // shadow

                '    vec3 outgoingLight = gl_FragColor.rgb;',

                '    #ifdef USE_SHADOWMAP',

                '        float fDepth;',
                '        vec3 shadowColor = vec3( 1.0 );',

                '        for ( int i = 0; i < MAX_SHADOWS; i ++ ) {',

                '            vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;',

                '            // if ( something && something ) breaks ATI OpenGL shader compiler',
                '            // if ( all( something, something ) ) using this instead',

                '            bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );',
                '            bool inFrustum = all( inFrustumVec );',

                '            // don\'t shadow pixels outside of light frustum',
                '            // use just first frustum (for cascades)',
                '            // don\'t shadow pixels behind far plane of light frustum',

                '            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );',

                '            bool frustumTest = all( frustumTestVec );',

                '            if ( frustumTest ) {',

                '                shadowCoord.z += shadowBias[ i ];',

                '                vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );',
                '                float fDepth = unpackDepth( rgbaDepth );',

                '                if ( fDepth < shadowCoord.z / 1.01 ) {',

                '                    // spot with multiple shadows is darker',

                '                    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );',

                '                    // spot with multiple shadows has the same color as single shadow spot',
                '                    // shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );',

                '                }',

                '            }',

                '        }',

                '        // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014',
                '        shadowColor = inputToLinear( shadowColor );',

                '        outgoingLight = outgoingLight * shadowColor;',

                '    #endif',

                '    gl_FragColor = vec4( outgoingLight, gl_FragColor.a );',

                '    #ifdef USE_FOG',

                '       float depth = gl_FragCoord.z / gl_FragCoord.w;',

                '       #ifdef FOG_EXP2',

                '           const float LOG2 = 1.442695;',
                '           float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
                '           fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

                '        #else',

                '            float fogFactor = smoothstep( fogNear, fogFar, depth );',

                '        #endif',

                '        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

                '    #endif',

                '}'

            ].join('\n')

        };

    };

    if ( typeof StaticGroup === 'function' ) {
        var t = {}, p = {};
        for ( var i in StaticGroup ) t[i] = StaticGroup[i];
        for ( var i in StaticGroup.prototype ) try { p[i] = StaticGroup.prototype[i] } catch(e) {};
        scope.StaticGroup = StaticGroup.bind( scope );
    } else {
        scope.StaticGroup = StaticGroup;
    }
    scope.StaticGroup.prototype = StaticGroup.prototype;
    for ( var i in t ) scope.StaticGroup[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.StaticGroup.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__StaticGroup ) {
        for ( var i = 0, il = scope.__StaticGroup.length; i < il; i ++ ) scope.__StaticGroup[ i ]( StaticGroup );
        delete scope.__StaticGroup;
    }

}) ( NWE.gfx.ShaderLib );


// src/framework/shaders/DynamicTerrainShader.js

( function ( scope ) {

    /**
     * @author ohmed
     * dynamic terrain shader
     */

    var DynamicTerrain = function () {

        this.defines = {

            'MAP_EDITOR_MODE': '',

        };

        this.attributes = {

            'position': { type: 'v3' },
            'uv':       { type: 'v2' },
            'normal':   { type: 'v3' }

        };

        this.uniforms = {

            'noiseTexture': { type: 't', value: null, global: 1 },

            'useCliffTexture': { type: 'i', value: 0, global: 1 },

            'mapping':      { type: 't', value: null, global: -1 },
            'atlasTexute':  { type: 't', value: null, global: 1 },

            'atlasTextureItemsPerRow': { type: 'f', value: 1, global: -1 },

            'terrainSize':  { type: 'v2', value: null },
            'zoom':         { type: 'f', value: 3 },

            'marker':       { type: 'v3', value: null, global: -1 },

            'focusPoint':   { type: 'v2', value: null, global: -1 },

            'ambientLightColor':    { type: 'c', value: null, global: 2 },
            'ambient':              { type: 'c', value: null },

            'fogDensity':   { type: 'f', value: 0, global: 2 },
            'fogNear':      { type: 'f', value: 1, global: 2 },
            'fogFar':       { type: 'f', value: 2000000, global: 2 },
            'fogColor':     { type: 'c', value: null, global: 2 },

            'modelViewMatrix':  { type: 'm4', value: null, global: 2 },
            'projectionMatrix': { type: 'm4', value: null, global: 2 }

        };

        this.varyings = {

            'vPosition':    { type: 'v3' },
            'vNormal':      { type: 'v3' },
            'vUv':          { type: 'v2' },

        };

        this.vertexShader = {

            countNormal: [

                'vec3 countNormal ( float x, float z, float vH ) {',

                '    float k1 = 4.0 / 512.0;',
                '    float k = 1.0 - 2.0 * k1;',

                '    vec3 p1 = vec3( x, vH, z );',
                '    vec3 p2 = vec3( x + 2.5, 0.0, z );',
                '    p2.y = 255.0 * ( texture2D( mapping, vec2( k * 0.5 * vUv.s + 0.5 + k1 * 0.5 + 0.0009765, k * 0.5 * vUv.t + 0.5 * k1 ) ).b - 0.5 );',
                '    vec3 p3 = vec3( x, 0.0, z + 2.5 );',
                '    p3.y = 255.0 * ( texture2D( mapping, vec2( k * 0.5 * vUv.s + 0.5 + k1 * 0.5            , k * 0.5 * vUv.t + 0.5 * k1 + 0.0009765 ) ).b - 0.5 );',

                '    return -normalize( cross( p2 - p1, p3 - p1 ) );',

                '}',

            ].join('\n'),

            main: [

                '// 0.0009765625 = 1 / 1024',

                'void main () {',

                '    vec3 positionNEW = zoom * position.xyz;',

                '    positionNEW.x = positionNEW.x + focusPoint.x;',
                '    positionNEW.z = positionNEW.z - focusPoint.y;',

                '    vUv.s = positionNEW.x / terrainSize[0] + 0.5;',
                '    vUv.t = 1.0 - ( positionNEW.z / terrainSize[1] + 0.5 );',

                '    float k1 = 4.0 / 512.0;',
                '    float k = 1.0 - 2.0 * k1;',

                '    float H = 255.0 * ( texture2D( mapping, vec2( k * 0.5 * vUv.s + 0.5 + k1 * 0.5, k * 0.5 * vUv.t + k1 * 0.5 ) ).b - 0.5 );',

                '    positionNEW.y = H;',

                '    vNormal = countNormal( positionNEW.x, positionNEW.z, H );',

                '    vec4 vViewPos = modelViewMatrix * vec4( positionNEW, 1.0 );',
                '    vec4 mvPosition = projectionMatrix * vViewPos;',

                '    vPosition = positionNEW;',

                '    gl_Position = mvPosition;',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            main: [

                '// 0.0009765625 = 1 / 1024',

                'void main () {',

                '    vec3 sunDirrection = vec3( 0.5, 0.5, 0.5 );',

                '    // variables declaration',
                '    vec2 position = vUv;',

                '    float textureRepeatCoef = 100.0;',

                '    vec2 uvXZ = mod( vPosition.xz / ( 2.0 * textureRepeatCoef ), 1.0 );',
                '    uvXZ = vec2( 0.03 + 0.94 * 2.0 * min( uvXZ, 1.0 - uvXZ ) ) / atlasTextureItemsPerRow;',

                '    float k1 = 4.0 / 512.0;',
                '    float k = 1.0 - 2.0 * k1;',

                '    vec3 Map1 = texture2D( mapping, vec2( k * 0.5 * vUv.s + 0.5 * k1, k * 0.5 * vUv.t + 0.5 + 0.5 * k1 ) ).rgb;',
                '    vec3 Map2 = texture2D( mapping, vec2( k * 0.5 * vUv.s + 0.5 + 0.5 * k1, k * 0.5 * vUv.t + 0.5 + 0.5 * k1 ) ).rgb;',

                '    vec2 dU = vec2( 1.0 / atlasTextureItemsPerRow, 0.0 );',
                '    vec2 dV = vec2( 0.0, 1.0 / atlasTextureItemsPerRow );',

                '    vec3 ground01 = texture2D( atlasTexute, uvXZ + 1.0 * dU ).rgb;',
                '    vec3 grass01  = texture2D( atlasTexute, uvXZ + 2.0 * dU ).rgb;',
                '    vec3 grass02  = texture2D( atlasTexute, uvXZ + 3.0 * dU ).rgb;',
                '    vec3 stone01  = texture2D( atlasTexute, uvXZ + 0.0 * dU + 1.0 * dV ).rgb;',
                '    vec3 iron01   = texture2D( atlasTexute, uvXZ + 1.0 * dU + 1.0 * dV ).rgb;',
                '    vec3 swamp01  = texture2D( atlasTexute, uvXZ + 2.0 * dU + 1.0 * dV ).rgb;',

                '    float tileValue1 = Map1.r;',
                '    float tileValue2 = Map1.g;',
                '    float tileValue3 = Map1.b;',
                '    float tileValue4 = Map2.r;',
                '    float tileValue5 = Map2.g;',
                '    float tileValue6 = Map2.b;',

                '    float sum = tileValue1 + tileValue2 + tileValue3 + tileValue4 + tileValue5 + tileValue6;',

                '    gl_FragColor = vec4( ( tileValue1 * ground01 + tileValue2 * grass01 + tileValue3 * grass02 + tileValue4 * stone01 + tileValue5 * iron01 + tileValue6 * swamp01 ) / sum, 1.0 );',

                //

                '        vec2 uvXZ1 = mod( vPosition.xz / ( 500.0 ), 1.0 );',

                '        vec3 rockyGround = texture2D( atlasTexute, uvXZ + 3.0 * dU + 1.0 * dV ).rgb;',
                '        vec3 noise = texture2D( noiseTexture, uvXZ1 ).rgb;',
                '        float noiseValue = 1.5 * noise.r * noise.r;',
                '        gl_FragColor = vec4( (1.0 - noiseValue) * gl_FragColor.rgb + noiseValue * rockyGround, 1.0 );',

                //

                '    // in case of cliff',
                '    vec3 blend = abs( vNormal );',

                '    blend = max( ( blend - 0.2 ) * 0.2, 0.0 );',
                '    blend /= vec3( blend.x + blend.y + blend.z ).xxx;',

                '    float steepnes = dot( vNormal, vec3( 0.0, -1.0, 0.0 ) );',

                '    vec3 cliff01XZ = texture2D( atlasTexute, uvXZ + 0.0 * dU ).rgb;',

                '    if ( useCliffTexture == 1 ) {',

                '        vec2 uvZY = mod( vPosition.zy / textureRepeatCoef, 1.0 ) / atlasTextureItemsPerRow;',
                '        vec2 uvXY = mod( vPosition.xy / textureRepeatCoef, 1.0 ) / atlasTextureItemsPerRow;',

                '        vec3 cliff01XY = texture2D( atlasTexute, uvXY + 0.0 * dU ).rgb;',
                '        vec3 cliff01ZY = texture2D( atlasTexute, uvZY + 0.0 * dU ).rgb;',

                '        gl_FragColor = mix( gl_FragColor, vec4( cliff01ZY * blend.xxx + cliff01XZ * blend.yyy + cliff01XY * blend.zzz, 1.0 ), max( 0.0, 1.0 - 0.9 * pow( steepnes, 2.0 ) ) );',

                '    } else {',

                '        gl_FragColor = mix( gl_FragColor, vec4( cliff01XZ, 1.0 ), max( 0.0, 1.0 - pow( steepnes, 2.0 ) ) );',

                '    }',

                '    vec3 light = vec3( min( 1.0, max( 0.0, dot( vNormal, normalize(sunDirrection) ) ) ) ) * ambientLightColor * ambient + ambientLightColor * ambient / 2.0;',
                '    gl_FragColor = vec4( gl_FragColor.rgb * light, 1.0 );',

                '    #ifdef USE_FOG',

                '        // count fog params',
                '        float depth = gl_FragCoord.z / gl_FragCoord.w;',
                '        float fogFactor = smoothstep( fogNear, fogFar, depth );',

                '        // fog apply',
                '        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

                '    #endif',

                '    #ifdef MAP_EDITOR_MODE',

                '        // marker',
                '        vec2 offset = vUv - vec2( marker[0], marker[1] );',
                '        float radius = length( offset );',

                '        if ( radius < marker[2] / terrainSize.x ) {',

                '            gl_FragColor[2] = gl_FragColor[2] + 0.8; // - min( 1.3 * terrainSize.x * radius, 0.8 );',

                '        }',

                '    #endif',

                '}'

            ].join('\n')

        };

    };

    if ( typeof DynamicTerrain === 'function' ) {
        var t = {}, p = {};
        for ( var i in DynamicTerrain ) t[i] = DynamicTerrain[i];
        for ( var i in DynamicTerrain.prototype ) try { p[i] = DynamicTerrain.prototype[i] } catch(e) {};
        scope.DynamicTerrain = DynamicTerrain.bind( scope );
    } else {
        scope.DynamicTerrain = DynamicTerrain;
    }
    scope.DynamicTerrain.prototype = DynamicTerrain.prototype;
    for ( var i in t ) scope.DynamicTerrain[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.DynamicTerrain.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__DynamicTerrain ) {
        for ( var i = 0, il = scope.__DynamicTerrain.length; i < il; i ++ ) scope.__DynamicTerrain[ i ]( DynamicTerrain );
        delete scope.__DynamicTerrain;
    }

}) ( NWE.gfx.ShaderLib );


// src/framework/shaders/StaticTerrainShader.js

( function ( scope ) {

    /**
     * @author ohmed
     * static terrain shader
     */

    var StaticTerrain = function () {

        this.defines = {

            'USING_TEXTURES': '3',
            'USE_HEIGHT_MAP': '0',

            'USE_SHADOWMAP': '1',
            'MAX_SHADOWS':   '1',

            'STATIC_UV': '0'

        };

        this.attributes = {

            'position': { type: 'v3' },
            'normal':   { type: 'v3' },
            'uv':       { type: 'v2' }

        };

        this.uniforms = {

            'noiseTexture':     { type: 't', value: null, global: 1 },

            'useCliffTexture':  { type: 'i', value: 0, global: 1 },

            'atlasTexute':              { type: 't', value: null, global: -1 },
            'atlasTextureItemsPerRow':  { type: 'f', value: 1, global: -1 },

            'terrainSize':          { type: 'v2', value: null, global: -1 },

            'ambientLightColor':    { type: 'c', value: null, global: 2 },
            'ambient':              { type: 'c', value: null, global: -1 },

            'focusPoint':           { type: 'v2', value: null, global: -1 },

            'fogDensity':           { type: 'f', value: 0.00025, global: 2 },
            'fogNear':              { type: 'f', value: 1, global: 2 },
            'fogFar':               { type: 'f', value: 2000, global: 2 },
            'fogColor':             { type: 'c', value: null, global: 2 },

            'modelMatrix':      { type: 'm4', value: null, global: -1 },
            'modelViewMatrix':  { type: 'm4', value: null, global: -1 },
            'projectionMatrix': { type: 'm4', value: null, global: -1 },
            'viewMatrix':       { type: 'm4', value: null, global: -1 },
            'normalMatrix':     { type: 'm3', value: null, global: -1 },
            'cameraPosition':   { type: 'v3', value: null, global: -1 },

            'globalTexture':        { type: 't', value: null, global: -1 },
            'mapping':              { type: 't', value: null, global: -1 },

            'useGlobalTexture':     { type: 'i', value: 0, global: -1 },

            'textureRepeatCoef':    { type: 'f', value: 60, global: -1 },


            'shadowMatrix':     { type: 'm4v', value: [], size: 5, global: -1 },

            'shadowMap':        { type: 'tv', value: [], size: 5, global: -1 },
            'shadowMapSize':    { type: 'v2v', value: [], size: 5, global: -1 },

            'shadowDarkness':   { type: 'fv1', value: [], size: 5, global: -1 },
            'shadowBias':       { type: 'fv1', value: [], size: 5, global: -1 }

        };

        this.varyings = {

            'vPosition':    { type: 'v3' },
            'vNormal':      { type: 'v3' },
            'vUv':          { type: 'v2' },
            'rnd':          { type: 'f' },
            'vShadowCoord': { type: 'v4', size: 5 }

        };

        this.vertexShader = {

            countNormal: [

                'vec3 countNormal ( float x, float z, float vH ) {',

                '    float k1 = 4.0 / 512.0;',
                '    float k = 1.0 - 2.0 * k1;',

                '    vec3 p1 = vec3( x, vH, z );',
                '    vec3 p2 = vec3( x + 2.5, 0.0, z );',
                '    p2.y = 255.0 * ( texture2D( mapping, vec2( k * 0.5 * vUv.s + 0.5 + k1 * 0.5 + 0.0009765, k * 0.5 * vUv.t + 0.5 * k1 ) ).b - 0.5 );',
                '    vec3 p3 = vec3( x, 0.0, z + 2.5 );',
                '    p3.y = 255.0 * ( texture2D( mapping, vec2( k * 0.5 * vUv.s + 0.5 + k1 * 0.5            , k * 0.5 * vUv.t + 0.5 * k1 + 0.0009765 ) ).b - 0.5 );',

                '    return -normalize( cross( p2 - p1, p3 - p1 ) );',

                '}',

            ].join('\n'),

            main: [

                'void main () {',

                '    vec3 newPosition = position;',

                '    #if ( USE_HEIGHT_MAP )',

                '        float k1 = 4.0 / 512.0;',
                '        float k = 1.0 - 2.0 * k1;',
                '        newPosition.y = 255.0 * ( texture2D( mapping, vec2( k * 0.5 * uv.s + 0.5 + k1 * 0.5, k * 0.5 * uv.t + k1 * 0.5 ) ).b - 0.5 );',

                '        vNormal = countNormal( newPosition.x, newPosition.z, newPosition.y );',

                '    #else',

                '        vNormal = normal;',

                '    #endif',

                '    #if ( STATIC_UV )',

                '        vUv = uv;',

                '    #else',

                '        vUv = vec2( position.x / 2033.0 + 0.5, - position.z / 2033.0 + 0.5 );',

                '    #endif',
                '    vPosition = newPosition;',

                '    vec4 vViewPos = modelViewMatrix * vec4( newPosition, 1.0 );',
                '    vec4 mvPosition = projectionMatrix * vViewPos;',

                '    gl_Position = mvPosition;',

                '    #ifdef USE_SHADOWMAP',

                '        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',

                '        for ( int i = 0; i < MAX_SHADOWS; i ++ ) {',

                '            vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;',

                '        }',

                '    #endif',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            unpackDepth: [

                'float unpackDepth ( const in vec4 rgba_depth ) {',

                '    const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );',
                '    float depth = dot( rgba_depth, bit_shift );',
                '    return depth;',

                '}'

            ].join('\n'),

            inputToLinear: [
                
                'vec3 inputToLinear ( in vec3 a ) {',

                '    #ifdef GAMMA_INPUT',

                '        return pow( a, vec3( float( GAMMA_FACTOR ) ) );',

                '     #else',

                '        return a;',

                '    #endif',

                '}'

            ].join('\n'),

            main: [

                'void main () {',

                '    vec3 sunDirrection = vec3( 0.5, 0.5, 0.5 );',

                '    float k1 = 4.0 / 512.0;',
                '    float k = 1.0 - 2.0 * k1;',

                '    if ( useGlobalTexture == 1 ) {',

                '       gl_FragColor = texture2D( globalTexture, vUv );',

                '    } else {',

                '        vec4 tData1, tData2;',
                '        float t1, t2, t3, t4;',
                '        float t5, t6, t7, t8;',
                '        vec3 tx1, tx2, tx3, tx4;',
                '        vec3 tx5, tx6, tx7, tx8;',
                '        float sum = 0.0;',
                '        vec3 result = vec3( 0.0 );',

                '        vec2 uvXZ = mod( vPosition.xz / ( 2.0 * textureRepeatCoef ), 1.0 );',
                '        uvXZ = vec2( 0.03 + 0.94 * 2.0 * min( uvXZ, 1.0 - uvXZ ) ) / atlasTextureItemsPerRow;',

                '        vec2 dU = vec2( 1.0 / atlasTextureItemsPerRow, 0.0 );',
                '        vec2 dV = vec2( 0.0, 1.0 / atlasTextureItemsPerRow );',

                '        tData1 = texture2D( mapping, vec2( k * 0.5 * vUv.s + 0.5 * k1, k * 0.5 * vUv.t + 0.5 + 0.5 * k1 ) ).rgba;',

                '        t1 = tData1.r / 2.0;',
                '        t2 = tData1.g * 1.5;',
                '        t3 = tData1.b;',
                '        t4 = tData1.a;',

                '        #if ( USING_TEXTURES > 4 )',

                '            tData2 = texture2D( mapping, vec2( 0.4992 * ( 1.0 - vUv.s ) + 0.5004, 0.4992 * vUv.t + 0.5004 ) ).rgba;',

                '            t5 = tData2.r;',
                '            t6 = tData2.g;',
                '            t7 = tData2.b;',
                '            t8 = tData2.a;',

                '        #endif',

                '        vec2 textureUV = vec2( 0.0 );',
                '        textureUV = mod( vPosition.xz / ( 2.0 * textureRepeatCoef ), 1.0 );',
                '        textureUV = vec2( 0.03 + 0.94 * 2.0 * min( textureUV, 1.0 - textureUV ) ) / atlasTextureItemsPerRow;',

                '        tx1 = texture2D( atlasTexute, textureUV + 1.0 * dU ).rgb;',
                '        tx2 = texture2D( atlasTexute, textureUV + 2.0 * dU ).rgb;',
                '        tx3 = texture2D( atlasTexute, textureUV + 3.0 * dU ).rgb;',
                // '        tx4 = texture2D( atlasTexute, textureUV + 3.0 * dU ).rgb;',

                '        result += vec3( t1 * tx1 + t2 * tx2 + t3 * tx3 );',

                '        sum = sum + t1 + t2 + t3;',

                '        #if ( USING_TEXTURES > 4 )',

                '            textureUV = textureUV + dV;',

                '            tx5 = texture2D( atlasTexute, textureUV + 0.0 * dU ).rgb;',
                '            tx6 = texture2D( atlasTexute, textureUV + 1.0 * dU ).rgb;',
                '            tx7 = texture2D( atlasTexute, textureUV + 2.0 * dU ).rgb;',
                '            tx8 = texture2D( atlasTexute, textureUV + 3.0 * dU ).rgb;',

                '            result += vec3( t5 * tx5 + t6 * tx6 + t7 * tx7 + t8 * tx8 );',

                '            sum = sum + t5 + t6 + t7 + t8;',

                '        #endif',

                '        gl_FragColor = vec4( result / sum, 1.0 );',

                //

                '        vec2 uvXZ1 = mod( vPosition.xz / ( 2033.0 ), 1.0 );',

                '        vec3 rockyGround = texture2D( atlasTexute, textureUV + 3.0 * dU + 1.0 * dV ).rgb;',
                '        vec3 noise = texture2D( noiseTexture, uvXZ1 ).rgb;',
                '        float noiseValue = 1.5 * noise.r * noise.r;',
                '        gl_FragColor = vec4( ( 1.0 - noiseValue ) * gl_FragColor.rgb + noiseValue * rockyGround, 1.0 );',

                //

                '        // in case of cliff',
                '        vec3 blend = abs( vNormal );',

                '        blend = max( ( blend - 0.2 ) * 0.2, 0.0 );',
                '        blend /= vec3( blend.x + blend.y + blend.z ).xxx;',

                '        float steepnes = dot( vNormal, vec3( 0.0, -1.0, 0.0 ) );',

                '        vec3 cliff01XZ = texture2D( atlasTexute, uvXZ + 0.0 * dU ).rgb;',

                '        if ( useCliffTexture == 1 ) {',

                '            vec2 uvZY = mod( vPosition.zy / textureRepeatCoef, 1.0 );',
                '            uvZY = vec2( 0.03 + 0.94 * 2.0 * min( uvZY, 1.0 - uvZY ) ) / atlasTextureItemsPerRow;',
                '            vec2 uvXY = mod( vPosition.xy / textureRepeatCoef, 1.0 );',
                '            uvXY = vec2( 0.03 + 0.94 * 2.0 * min( uvXY, 1.0 - uvXY ) ) / atlasTextureItemsPerRow;',

                '            vec3 cliff01XY = texture2D( atlasTexute, uvXY + 0.0 * dU ).rgb;',
                '            vec3 cliff01ZY = texture2D( atlasTexute, uvZY + 0.0 * dU ).rgb;',

                '            gl_FragColor = mix( gl_FragColor, vec4( cliff01ZY * blend.xxx + cliff01XZ * blend.yyy + cliff01XY * blend.zzz, 1.0 ), max( 0.0, 1.0 - 0.9 * pow( steepnes, 2.0 ) ) );',

                '        } else {',

                '            gl_FragColor = mix( gl_FragColor, vec4( cliff01XZ, 1.0 ), max( 0.0, 1.0 - pow( steepnes, 2.0 ) ) );',

                '        }',

                '    }',

                '    vec3 light = vec3( min( 1.0, max( 0.0, dot( vNormal, normalize(sunDirrection) ) ) ) ) * ambientLightColor * ambient + ambientLightColor * ambient * 0.5;',
                '    gl_FragColor = vec4( gl_FragColor.rgb * light, 1.0 );',

                // shadow

                '    vec3 outgoingLight = gl_FragColor.rgb;',

                '    #ifdef USE_SHADOWMAP',

                '        float fDepth;',
                '        vec3 shadowColor = vec3( 1.0 );',

                '        for ( int i = 0; i < MAX_SHADOWS; i ++ ) {',

                '            vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;',

                '            // if ( something && something ) breaks ATI OpenGL shader compiler',
                '            // if ( all( something, something ) ) using this instead',

                '            bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );',
                '            bool inFrustum = all( inFrustumVec );',

                '            // don\'t shadow pixels outside of light frustum',
                '            // use just first frustum (for cascades)',
                '            // don\'t shadow pixels behind far plane of light frustum',

                '            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );',

                '            bool frustumTest = all( frustumTestVec );',

                '            if ( frustumTest ) {',

                '                shadowCoord.z += shadowBias[ i ];',

                '                vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );',
                '                float fDepth = unpackDepth( rgbaDepth );',

                '                if ( fDepth < shadowCoord.z / 1.01 ) {',

                '                    // spot with multiple shadows is darker',

                '                    shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );',

                '                    // spot with multiple shadows has the same color as single shadow spot',
                '                    // shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );',

                '                }',

                '            }',

                '        }',

                '        // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014',
                '        shadowColor = inputToLinear( shadowColor );',

                '        outgoingLight = outgoingLight * shadowColor;',

                '    #endif',

                '    gl_FragColor = vec4( outgoingLight, 1.0 );',

                '    #ifdef USE_FOG',

                '       float depth = gl_FragCoord.z / gl_FragCoord.w;',

                '       #ifdef FOG_EXP2',

                '           const float LOG2 = 1.442695;',
                '           float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
                '           fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

                '        #else',

                '            float fogFactor = smoothstep( fogNear, fogFar, depth );',

                '        #endif',

                '        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

                '    #endif',

                '}'

            ].join('\n')

        };

    };

    if ( typeof StaticTerrain === 'function' ) {
        var t = {}, p = {};
        for ( var i in StaticTerrain ) t[i] = StaticTerrain[i];
        for ( var i in StaticTerrain.prototype ) try { p[i] = StaticTerrain.prototype[i] } catch(e) {};
        scope.StaticTerrain = StaticTerrain.bind( scope );
    } else {
        scope.StaticTerrain = StaticTerrain;
    }
    scope.StaticTerrain.prototype = StaticTerrain.prototype;
    for ( var i in t ) scope.StaticTerrain[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.StaticTerrain.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__StaticTerrain ) {
        for ( var i = 0, il = scope.__StaticTerrain.length; i < il; i ++ ) scope.__StaticTerrain[ i ]( StaticTerrain );
        delete scope.__StaticTerrain;
    }

}) ( NWE.gfx.ShaderLib );


// src/framework/shaders/SnowShader.js

( function ( scope ) {

    /**
     * @author ohmed
     * snow particle shader [no light support]
     */

    var Snow = function () {

        this.defines = {

        };

        this.attributes = {

            'position':  { type: 'v3' },
            'tOffset':   { type: 'f' }

        };

        this.uniforms = {

            'startTime':    { type: 'f', value: 0 },
            'time':         { type: 'f', value: 0 },
            'speed':        { type: 'f', value: 0.01 },

            'map':          { type: 't', value: null },

            'opacity':      { type: 'f', value: 1 },
            'size':         { type: 'f', value: 1 },
            'scale':        { type: 'f', value: 1 },
            'psColor':      { type: 'c', value: null },

            'fogDensity':   { type: 'f', value: 0.00025, global: 2 },
            'fogNear':      { type: 'f', value: 1, global: 2 },
            'fogFar':       { type: 'f', value: 2000, global: 2 },
            'fogColor':     { type: 'c', value: null, global: 2 },

            'modelViewMatrix':  { type: 'm4', value: null, global: 2 },
            'projectionMatrix': { type: 'm4', value: null, global: 2 }

        };

        this.varyings = {},

        this.vertexShader = {

            main: [

                'void main () {',

                '    vec3 newPosition = position;',
                '    newPosition.y = newPosition.y - speed * mod( time - tOffset, 10000.0 );',

                '    vec4 mvPosition = modelViewMatrix * vec4( newPosition, 1.0 );',

                '    gl_PointSize = size * ( scale / length( mvPosition.xyz ) );',
                '    gl_Position = projectionMatrix * mvPosition;',

                '}'

            ].join('\n')

        };

        this.fragmentShader = {

            main: [

                'void main () {',

                '    vec4 outColor = texture2D( map, gl_PointCoord );',

                '    gl_FragColor = outColor;',

                '    #ifdef USE_FOG',

                '       float depth = gl_FragCoord.z / gl_FragCoord.w;',

                '       #ifdef FOG_EXP2',

                '           const float LOG2 = 1.442695;',
                '           float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
                '           fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

                '        #else',

                '            float fogFactor = smoothstep( fogNear, fogFar, depth );',

                '        #endif',

                '        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

                '    #endif',

                '}'

            ].join('\n')

        };

    };

    if ( typeof Snow === 'function' ) {
        var t = {}, p = {};
        for ( var i in Snow ) t[i] = Snow[i];
        for ( var i in Snow.prototype ) try { p[i] = Snow.prototype[i] } catch(e) {};
        scope.Snow = Snow.bind( scope );
    } else {
        scope.Snow = Snow;
    }
    scope.Snow.prototype = Snow.prototype;
    for ( var i in t ) scope.Snow[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Snow.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Snow ) {
        for ( var i = 0, il = scope.__Snow.length; i < il; i ++ ) scope.__Snow[ i ]( Snow );
        delete scope.__Snow;
    }

}) ( NWE.gfx.ShaderLib );


// src/framework/shaders/MirrorShader.js

( function ( scope ) {

    /**
     * @author Slayvin / http://slayvin.net
     * @author ohmed
     * mirror reflection shader
     */

    var Mirror = function () {

        this.defines = {

        };

        this.attributes = {

            'position':  { type: 'v3' }

        };

        this.uniforms = {

            'mirrorColor':   { type: 'c', value: null },
            'mirrorSampler': { type: 't', value: null },
            'textureMatrix': { type: 'm4', value: null },

            'modelViewMatrix':  { type: 'm4', value: null, global: 2 },
            'projectionMatrix': { type: 'm4', value: null, global: 2 },
            'modelMatrix':      { type: 'm4', value: null, global: 2 }

        };

        this.varyings = {

            'mirrorCoord': { type: 'v4' }

        };

        this.vertexShader = {

            main: [

                'void main () {',

                '    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
                '    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
                '    mirrorCoord = textureMatrix * worldPosition;',

                '    gl_Position = projectionMatrix * mvPosition;',

                '}'

            ].join('\n'),

        };

        this.fragmentShader = {

            main: [

                'float blendOverlay ( float base, float blend ) {',

                '    return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',

                '}',

                'void main () {',

                '    vec4 color = texture2DProj( mirrorSampler, mirrorCoord );',
                '    color = vec4( blendOverlay( mirrorColor.r, color.r ), blendOverlay( mirrorColor.g, color.g ), blendOverlay( mirrorColor.b, color.b ), 1.0 );',

                '    gl_FragColor = color;',

                '}'

            ].join('\n')

        };

    };

    if ( typeof Mirror === 'function' ) {
        var t = {}, p = {};
        for ( var i in Mirror ) t[i] = Mirror[i];
        for ( var i in Mirror.prototype ) try { p[i] = Mirror.prototype[i] } catch(e) {};
        scope.Mirror = Mirror.bind( scope );
    } else {
        scope.Mirror = Mirror;
    }
    scope.Mirror.prototype = Mirror.prototype;
    for ( var i in t ) scope.Mirror[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Mirror.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Mirror ) {
        for ( var i = 0, il = scope.__Mirror.length; i < il; i ++ ) scope.__Mirror[ i ]( Mirror );
        delete scope.__Mirror;
    }

}) ( NWE.gfx.ShaderLib );


// src/framework/effects/Effect.js

( function ( scope ) {

    /**
     * @author ohmed
     * effect base object
     */



    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Box3 = NWE.Box3;
    if ( !Box3 ) { NWE.__Box3 = (NWE.__Box3 || []); NWE.__Box3.push( function ( obj ) { Box3 = obj; } ); }


    var Object3D = NWE.gfx.Object3D;
    if ( !Object3D ) { NWE.gfx.__Object3D = (NWE.gfx.__Object3D || []); NWE.gfx.__Object3D.push( function ( obj ) { Object3D = obj; } ); }


    var Effect = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Object3D.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.id = NWE.fw.EffectIdCount ++;
        this.name = params.name || '';

        this.parent = undefined;

        //

        this.position = params.position || new Vec3();
        this.rotation = params.rotation || new Vec3();
        this.box = params.box || new Box3();

        this.visible = true;

        //

        this.instanceof = 'Effect';

    };

    Effect.prototype = Object.create( Object3D.prototype );

    Effect.prototype.clone = function () {

        // todo

    };

    Effect.prototype.dispose = function () {

        // todo

    };

    NWE.fw.EffectIdCount = 0;

    Effect.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Effect.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Effect.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Effect.setInternal = function ( name, value ) { internal[ name ] = value; };
    Effect.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Effect === 'function' ) {
        var t = {}, p = {};
        for ( var i in Effect ) t[i] = Effect[i];
        for ( var i in Effect.prototype ) try { p[i] = Effect.prototype[i] } catch(e) {};
        scope.Effect = Effect.bind( scope );
    } else {
        scope.Effect = Effect;
    }
    internal['constructor'] = Effect;
    scope.Effect.prototype = Effect.prototype;
    for ( var i in t ) scope.Effect[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Effect.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Effect ) {
        for ( var i = 0, il = scope.__Effect.length; i < il; i ++ ) scope.__Effect[ i ]( Effect );
        delete scope.__Effect;
    }

}) ( NWE.fw );


// src/framework/effects/SnowMachine.js

( function ( scope ) {

    /**
     * @author ohmed
     * snow effect machine
     */



    var Effect = NWE.fw.Effect;
    if ( !Effect ) { NWE.fw.__Effect = (NWE.fw.__Effect || []); NWE.fw.__Effect.push( function ( obj ) { Effect = obj; } ); }

    var SnowMaterial = NWE.gfx.SnowMaterial;
    if ( !SnowMaterial ) { NWE.gfx.__SnowMaterial = (NWE.gfx.__SnowMaterial || []); NWE.gfx.__SnowMaterial.push( function ( obj ) { SnowMaterial = obj; } ); }


    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }

    var Scene = NWE.gfx.Scene;
    if ( !Scene ) { NWE.gfx.__Scene = (NWE.gfx.__Scene || []); NWE.gfx.__Scene.push( function ( obj ) { Scene = obj; } ); }

    var PointCloud = NWE.gfx.PointCloud;
    if ( !PointCloud ) { NWE.gfx.__PointCloud = (NWE.gfx.__PointCloud || []); NWE.gfx.__PointCloud.push( function ( obj ) { PointCloud = obj; } ); }


    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var SnowMachine = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Effect.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        //

        this.speed = params.speed || 0.5;
        this.strength = params.strength || 1;

        this.autoUpdate = true;
        this.enabled = true;

        this.flakesSize = {
            width: 1,
            height: 1
        };

        this.particleSystem = null;

        //

        if ( ! params.map ) {

            var canvas = document.createElement( 'canvas' );
            canvas.width = 32;
            canvas.height = 32;

            var context = canvas.getContext( '2d' );
            var gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );
            gradient.addColorStop( 0.1, 'rgba(255, 255, 255, 1)' );
            gradient.addColorStop( 1, 'rgba(255, 255, 255, 0)' );

            context.fillStyle = gradient;
            context.fillRect( 0, 0, canvas.width, canvas.height );

            params.map = new Texture( canvas );

        }

        internal[ this.uuid ].material = new SnowMaterial({ size: 12, scale: 100, map: params.map, transparent: true });

        //

        this.instanceof = 'SnowMachine';

    };

    SnowMachine.prototype = Object.create( Effect.prototype );

    SnowMachine.prototype.prepare = function () {

        var flakesCount = 500000 * this.strength;

        var geometry = new NWE.gfx.BufferGeometry({ vertCount: flakesCount, pointsCount: flakesCount });

        var positions = geometry.addAttribute( 'position', 3 ).array;
        var tOffset = geometry.addAttribute( 'tOffset', 1 ).array;

        var h;
        var abs = window.Math.abs;

        for ( var i = 0, il = 3 * flakesCount; i < il; i += 3 ) {

            // positions

            positions[ i ]     = window.Math.random() * ( this.box.max.x - this.box.min.x ) - abs( this.box.min.x );
            positions[ i + 1 ] = this.box.max.y;
            positions[ i + 2 ] = window.Math.random() * ( this.box.max.z - this.box.min.z ) - abs( this.box.min.z );

            // tOffset

            tOffset[ i / 3 ] = Date.now() % 20000000 - 17000 * window.Math.random();

        }

        geometry.computeChunkOffsets();
        geometry.computeBoundingSphere();

        //

        this.particleSystem = new PointCloud( geometry, internal[ this.uuid ].material );
        this.particleSystem.positions = this.position;
        this.particleSystem.rotation = this.rotation;
        this.particleSystem.parent = this;

    };

    SnowMachine.prototype.setSnowFlakeSize = function ( width, height ) {

        this.flakesSize.width = width;
        this.flakesSize.height = height;

        for ( var i = 0, il = this.sprites.length; i < il; i ++ ) {

            this.sprites[ i ].scale.set( width, height, 1 );

        }

    };

    SnowMachine.prototype.setSnowFlakeTexture = function ( texture ) {

        if ( ! ( texture instanceof Texture ) ) {

            Logger.warn( 'NWE.fw.SnowMachine.setSnowFlakeTexture(): texture needs to be Texture type.' );
            return;

        }

        internal[ this.uuid ].material.uniforms.map.value = texture;
        internal[ this.uuid ].material.uniforms.map.needsUpdate = true;

    };

    SnowMachine.prototype.start = function () {

        // todo

    };

    SnowMachine.prototype.stop = function () {

        // todo

    };

    SnowMachine.prototype.enable = function () {

        this.particleSystem.visible = true;
        this.enabled = true;

    };

    SnowMachine.prototype.disable = function () {

        this.particleSystem.visible = false;
        this.enabled = false;

    };

    SnowMachine.prototype.update = function ( delta ) {

        if ( ! this.enabled || ! this.autoUpdate ) return;

        internal[ this.uuid ].material.uniforms.time.value = Date.now() % 20000000;

    };

    SnowMachine.prototype.clone = function () {

        // todo

    };

    SnowMachine.prototype.dispose = function () {

        // todo

    };

    Scene.registerObject( 'SnowMachine', function ( object ) {

        object.prepare();
        this.add( object.particleSystem );

    }, function ( object ) {

        // todo

    });

    SnowMachine.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    SnowMachine.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    SnowMachine.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    SnowMachine.setInternal = function ( name, value ) { internal[ name ] = value; };
    SnowMachine.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof SnowMachine === 'function' ) {
        var t = {}, p = {};
        for ( var i in SnowMachine ) t[i] = SnowMachine[i];
        for ( var i in SnowMachine.prototype ) try { p[i] = SnowMachine.prototype[i] } catch(e) {};
        scope.SnowMachine = SnowMachine.bind( scope );
    } else {
        scope.SnowMachine = SnowMachine;
    }
    internal['constructor'] = SnowMachine;
    scope.SnowMachine.prototype = SnowMachine.prototype;
    for ( var i in t ) scope.SnowMachine[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.SnowMachine.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__SnowMachine ) {
        for ( var i = 0, il = scope.__SnowMachine.length; i < il; i ++ ) scope.__SnowMachine[ i ]( SnowMachine );
        delete scope.__SnowMachine;
    }

}) ( NWE.fw );


// src/framework/effects/WindMachine.js

( function ( scope ) {

    /**
     * @author ohmed
     * wind effect machine
     */



    var Uniform = NWE.gfx.Uniform;
    if ( !Uniform ) { NWE.gfx.__Uniform = (NWE.gfx.__Uniform || []); NWE.gfx.__Uniform.push( function ( obj ) { Uniform = obj; } ); }

    var Effect = NWE.fw.Effect;
    if ( !Effect ) { NWE.fw.__Effect = (NWE.fw.__Effect || []); NWE.fw.__Effect.push( function ( obj ) { Effect = obj; } ); }

    var Texture = NWE.gfx.Texture;
    if ( !Texture ) { NWE.gfx.__Texture = (NWE.gfx.__Texture || []); NWE.gfx.__Texture.push( function ( obj ) { Texture = obj; } ); }

    var Scene = NWE.gfx.Scene;
    if ( !Scene ) { NWE.gfx.__Scene = (NWE.gfx.__Scene || []); NWE.gfx.__Scene.push( function ( obj ) { Scene = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }


    var WindMachine = function ( params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Effect.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.speed = params.speed || 0.0005;

        //

        internal[ this.uuid ].windTexture = null;
        internal[ this.uuid ].dirrection = 1;
        internal[ this.uuid ].offset = new Uniform( 'windOffset', 'f', 0, 2 );

        //

        this.instanceof = 'WindMachine';

    };

    WindMachine.prototype = Object.create( Effect.prototype );

    WindMachine.prototype.setWindTexture = function ( texture ) {

        if ( ! ( texture instanceof Texture ) ) {

            Logger.warn( 'NWE.fw.WindMachine.setWindTexture(): texture needs to be Texture type.' );
            return;

        }

        internal[ this.uuid ].windTexture = texture;

    };

    WindMachine.prototype.start = function () {

        // todo

    };

    WindMachine.prototype.stop = function () {

        // todo

    };

    WindMachine.prototype.update = function () {

        // update wind

        if ( internal[ this.uuid ].offset.value > 1 ) internal[ this.uuid ].dirrection = -1;
        if ( internal[ this.uuid ].offset.value <= 0 ) internal[ this.uuid ].dirrection = 1;

        internal[ this.uuid ].offset.value += internal[ this.uuid ].dirrection * this.speed;

        // update time

        this.time.value = 1000 * view.globalTime.getElapsedTime();
        this.timeForBuildings.value = Math.round( ( 1000 * view.globalTime.getElapsedTime() % 25000 ) / 100 );

    };

    WindMachine.prototype.clone = function () {

        // todo

    };

    WindMachine.prototype.dispose = function () {

        // todo

    };

    Scene.registerObject( 'WindMachine', function ( object ) {

        // todo

    }, function ( object ) {

        // todo

    });

    WindMachine.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    WindMachine.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    WindMachine.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    WindMachine.setInternal = function ( name, value ) { internal[ name ] = value; };
    WindMachine.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof WindMachine === 'function' ) {
        var t = {}, p = {};
        for ( var i in WindMachine ) t[i] = WindMachine[i];
        for ( var i in WindMachine.prototype ) try { p[i] = WindMachine.prototype[i] } catch(e) {};
        scope.WindMachine = WindMachine.bind( scope );
    } else {
        scope.WindMachine = WindMachine;
    }
    internal['constructor'] = WindMachine;
    scope.WindMachine.prototype = WindMachine.prototype;
    for ( var i in t ) scope.WindMachine[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.WindMachine.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__WindMachine ) {
        for ( var i = 0, il = scope.__WindMachine.length; i < il; i ++ ) scope.__WindMachine[ i ]( WindMachine );
        delete scope.__WindMachine;
    }

}) ( NWE.fw );


// src/framework/effects/Mirror.js

( function ( scope ) {

    /*
     * @author Slayvin / http://slayvin.net
     * @author ohmed
    */



    var Effect = NWE.fw.Effect;
    if ( !Effect ) { NWE.fw.__Effect = (NWE.fw.__Effect || []); NWE.fw.__Effect.push( function ( obj ) { Effect = obj; } ); }


    var Color = NWE.Color;
    if ( !Color ) { NWE.__Color = (NWE.__Color || []); NWE.__Color.push( function ( obj ) { Color = obj; } ); }

    var Plane = NWE.Plane;
    if ( !Plane ) { NWE.__Plane = (NWE.__Plane || []); NWE.__Plane.push( function ( obj ) { Plane = obj; } ); }

    var Vec3 = NWE.Vec3;
    if ( !Vec3 ) { NWE.__Vec3 = (NWE.__Vec3 || []); NWE.__Vec3.push( function ( obj ) { Vec3 = obj; } ); }

    var Vec4 = NWE.Vec4;
    if ( !Vec4 ) { NWE.__Vec4 = (NWE.__Vec4 || []); NWE.__Vec4.push( function ( obj ) { Vec4 = obj; } ); }

    var Matrix4 = NWE.Matrix4;
    if ( !Matrix4 ) { NWE.__Matrix4 = (NWE.__Matrix4 || []); NWE.__Matrix4.push( function ( obj ) { Matrix4 = obj; } ); }

    var Logger = NWE.Logger;
    if ( !Logger ) { NWE.__Logger = (NWE.__Logger || []); NWE.__Logger.push( function ( obj ) { Logger = obj; } ); }

    var Math = NWE.Math;
    if ( !Math ) { NWE.__Math = (NWE.__Math || []); NWE.__Math.push( function ( obj ) { Math = obj; } ); }


    var PerspectiveCamera = NWE.gfx.PerspectiveCamera;
    if ( !PerspectiveCamera ) { NWE.gfx.__PerspectiveCamera = (NWE.gfx.__PerspectiveCamera || []); NWE.gfx.__PerspectiveCamera.push( function ( obj ) { PerspectiveCamera = obj; } ); }

    var WebGLRenderTarget = NWE.gfx.WebGLRenderTarget;
    if ( !WebGLRenderTarget ) { NWE.gfx.__WebGLRenderTarget = (NWE.gfx.__WebGLRenderTarget || []); NWE.gfx.__WebGLRenderTarget.push( function ( obj ) { WebGLRenderTarget = obj; } ); }

    var MirrorMaterial = NWE.gfx.MirrorMaterial;
    if ( !MirrorMaterial ) { NWE.gfx.__MirrorMaterial = (NWE.gfx.__MirrorMaterial || []); NWE.gfx.__MirrorMaterial.push( function ( obj ) { MirrorMaterial = obj; } ); }


    var Mirror = function ( renderer, camera, scene, params, objInternal ) {

        params = params || {};

        objInternal = objInternal || {};
        Effect.getInternal('constructor').call( this, params, objInternal );
        internal[ this.uuid ] = objInternal;

        this.matrixNeedsUpdate = true;

        var width = ( params.textureWidth !== undefined ) ? params.textureWidth : 512;
        var height = ( params.textureHeight !== undefined ) ? params.textureHeight : 512;

        this.clipBias = ( params.clipBias !== undefined ) ? params.clipBias : 0.0;

        var mirrorColor = ( params.color !== undefined ) ? new Color( params.color ) : new Color( 0x7F7F7F );

        this.renderer = renderer;
        this.mirrorPlane = new Plane();
        this.normal = new Vec3( 0, 0, 1 );
        this.mirrorWorldPosition = new Vec3();
        this.cameraWorldPosition = new Vec3();
        this.rotationMatrix = new Matrix4();
        this.lookAtPosition = new Vec3( 0, 0, -1 );
        this.clipPlane = new Vec4();
        
        // For debug only, show the normal and plane of the mirror
        var debugMode = ( params.debugMode !== undefined ) ? params.debugMode : false;

        // if ( debugMode ) {

        //     var arrow = new THREE.ArrowHelper( new Vec3( 0, 0, 1 ), new Vec3( 0, 0, 0 ), 10, 0xffff80 );
        //     var planeGeometry = new THREE.Geometry();
        //     planeGeometry.vertices.push( new Vec3( -10, -10, 0 ) );
        //     planeGeometry.vertices.push( new Vec3( 10, -10, 0 ) );
        //     planeGeometry.vertices.push( new Vec3( 10, 10, 0 ) );
        //     planeGeometry.vertices.push( new Vec3( -10, 10, 0 ) );
        //     planeGeometry.vertices.push( planeGeometry.vertices[0] );
        //     var plane = new THREE.Line( planeGeometry, new THREE.LineBasicMaterial( { color: 0xffff80 } ) );

        //     this.add(arrow);
        //     this.add(plane);

        // }

        if ( camera.instanceof === 'PerspectiveCamera' ) {

            this.camera = camera;

        } else {

            this.camera = new PerspectiveCamera();
            Logger.warn( 'NWE.fw.Mirror(): camera is not a Perspective Camera!' );

        }

        this.scene = scene;

        this.textureMatrix = new Matrix4();

        this.mirrorCamera = this.camera.clone();

        this.texture = new WebGLRenderTarget( width, height );
        this.tempTexture = new WebGLRenderTarget( width, height );

        this.material = new MirrorMaterial();

        this.material.uniforms.mirrorSampler.value = this.texture;
        this.material.uniforms.mirrorColor.value = mirrorColor;
        this.material.uniforms.textureMatrix.value = this.textureMatrix;

        if ( ! Math.isPowerOfTwo( width ) || ! Math.isPowerOfTwo( height ) ) {

            this.texture.generateMipmaps = false;
            this.tempTexture.generateMipmaps = false;

        }

        this.updateTextureMatrix();
        this.render();

        //

        this.instanceof = 'Mirror';

    };

    Mirror.prototype = Object.create( Effect.prototype );

    Mirror.prototype.renderWithMirror = function ( otherMirror ) {

        // update the mirror matrix to mirror the current view
        this.updateTextureMatrix();
        this.matrixNeedsUpdate = false;

        // set the camera of the other mirror so the mirrored view is the reference view
        var tempCamera = otherMirror.camera;
        otherMirror.camera = this.mirrorCamera;

        // render the other mirror in temp texture
        otherMirror.renderTemp();

        // render the current mirror
        this.render();
        this.matrixNeedsUpdate = true;

        // restore material and camera of other mirror
        otherMirror.camera = tempCamera;

        // restore texture matrix of other mirror
        otherMirror.updateTextureMatrix();

    };

    Mirror.prototype.updateTextureMatrix = function () {

        this.updateMatrixWorld();
        this.camera.updateMatrixWorld();

        this.mirrorWorldPosition.setFromMatrixPosition( this.matrixWorld );
        this.cameraWorldPosition.setFromMatrixPosition( this.camera.matrixWorld );

        this.rotationMatrix.extractRotation( this.matrixWorld );

        this.normal.set( 0, 0, 1 );
        this.normal.applyMatrix4( this.rotationMatrix );

        var view = this.mirrorWorldPosition.clone().sub( this.cameraWorldPosition );
        view.reflect( this.normal ).negate();
        view.add( this.mirrorWorldPosition );

        this.rotationMatrix.extractRotation( this.camera.matrixWorld );

        this.lookAtPosition.set( 0, 0, -1 );
        this.lookAtPosition.applyMatrix4( this.rotationMatrix );
        this.lookAtPosition.add( this.cameraWorldPosition );

        var target = this.mirrorWorldPosition.clone().sub( this.lookAtPosition );
        target.reflect( this.normal ).negate();
        target.add( this.mirrorWorldPosition );

        this.up.set( 0, -1, 0 );
        this.up.applyMatrix4( this.rotationMatrix );
        this.up.reflect( this.normal ).negate();

        this.mirrorCamera.position.copy( view );
        this.mirrorCamera.up = this.up;
        this.mirrorCamera.lookAt( target );

        this.mirrorCamera.updateProjectionMatrix();
        this.mirrorCamera.updateMatrixWorld();
        this.mirrorCamera.matrixWorldInverse.getInverse( this.mirrorCamera.matrixWorld );

        // Update the texture matrix
        this.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,
                                0.0, 0.5, 0.0, 0.5,
                                0.0, 0.0, 0.5, 0.5,
                                0.0, 0.0, 0.0, 1.0 );
        this.textureMatrix.multiply( this.mirrorCamera.projectionMatrix );
        this.textureMatrix.multiply( this.mirrorCamera.matrixWorldInverse );

        // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
        // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
        this.mirrorPlane.setFromNormalAndCoplanarPoint( this.normal, this.mirrorWorldPosition );
        this.mirrorPlane.applyMatrix4( this.mirrorCamera.matrixWorldInverse );

        this.clipPlane.set( this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant );

        var q = new Vec4();
        var projectionMatrix = this.mirrorCamera.projectionMatrix;

        q.x = ( window.Math.sign( this.clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
        q.y = ( window.Math.sign( this.clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
        q.z = - 1.0;
        q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

        // Calculate the scaled plane vector
        var c = new Vec4();
        c = this.clipPlane.multiplyScalar( 2.0 / this.clipPlane.dot( q ) );

        // Replacing the third row of the projection matrix
        projectionMatrix.elements[  2 ] = c.x;
        projectionMatrix.elements[  6 ] = c.y;
        projectionMatrix.elements[ 10 ] = c.z + 1.0 - this.clipBias;
        projectionMatrix.elements[ 14 ] = c.w;

        this.material.uniforms.textureMatrix.needsUpdate = true;

    };

    Mirror.prototype.render = function () {

        if ( this.matrixNeedsUpdate ) this.updateTextureMatrix();

        this.matrixNeedsUpdate = true;

        // Render the mirrored view of the current scene into the target texture
        var scene = this.scene;

        if ( scene !== undefined && scene.instanceof === 'Scene' ) {

            this.renderer.render( scene, this.mirrorCamera, this.texture, true );

        }

        this.material.uniforms.mirrorSampler.value = this.texture;
        this.material.uniforms.mirrorSampler.needsUpdate = true;

    };

    Mirror.prototype.renderTemp = function () {

        if ( this.matrixNeedsUpdate ) this.updateTextureMatrix();

        this.matrixNeedsUpdate = true;

        // Render the mirrored view of the current scene into the target texture
        var scene = this.scene;

        if ( scene !== undefined && scene.instanceof === 'Scene' ) {

            this.renderer.render( scene, this.mirrorCamera, this.tempTexture, true );

        }

        this.material.uniforms.mirrorSampler.value = this.texture;
        this.material.uniforms.mirrorSampler.needsUpdate = true;

    };

    Mirror.prototype.setInternal = function ( name, value ) { internal[ this.uuid ][ name ] = value; };
    Mirror.prototype.getInternal = function ( name        ) { return internal[ this.uuid ][ name ]; };
    Mirror.prototype.removeInternal = function ( name     ) { delete internal[ this.uuid ][ name ]; };
    Mirror.setInternal = function ( name, value ) { internal[ name ] = value; };
    Mirror.getInternal = function ( name        ) { return internal[ name ]; };
    var internal = {};
    if ( typeof Mirror === 'function' ) {
        var t = {}, p = {};
        for ( var i in Mirror ) t[i] = Mirror[i];
        for ( var i in Mirror.prototype ) try { p[i] = Mirror.prototype[i] } catch(e) {};
        scope.Mirror = Mirror.bind( scope );
    } else {
        scope.Mirror = Mirror;
    }
    internal['constructor'] = Mirror;
    scope.Mirror.prototype = Mirror.prototype;
    for ( var i in t ) scope.Mirror[i] = t[i];
    for ( var i in p ) if ( typeof p[i] === 'function' ) scope.Mirror.prototype[i] = function ( id ) { return function () { return p[id].apply( this, arguments ); } }(i);
    if ( scope.__Mirror ) {
        for ( var i = 0, il = scope.__Mirror.length; i < il; i ++ ) scope.__Mirror[ i ]( Mirror );
        delete scope.__Mirror;
    }

}) ( NWE.fw );


// src/libs/jszip.js

( function ( scope ) {

/*
 * JSZip
 */

!function(a){"object"==typeof exports?module.exports=a():"function"==typeof define&&define.amd?define(a):"undefined"!=typeof window?window.JSZip=a():"undefined"!=typeof global?global.JSZip=a():"undefined"!=typeof self&&(self.JSZip=a())}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);throw new Error("Cannot find module '"+g+"'")}var j=c[g]={exports:{}};b[g][0].call(j.exports,function(a){var c=b[g][1][a];return e(c?c:a)},j,j.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a){for(var b,c,e,f,g,h,i,j="",k=0;k<a.length;)b=a.charCodeAt(k++),c=a.charCodeAt(k++),e=a.charCodeAt(k++),f=b>>2,g=(3&b)<<4|c>>4,h=(15&c)<<2|e>>6,i=63&e,isNaN(c)?h=i=64:isNaN(e)&&(i=64),j=j+d.charAt(f)+d.charAt(g)+d.charAt(h)+d.charAt(i);return j},c.decode=function(a){var b,c,e,f,g,h,i,j="",k=0;for(a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");k<a.length;)f=d.indexOf(a.charAt(k++)),g=d.indexOf(a.charAt(k++)),h=d.indexOf(a.charAt(k++)),i=d.indexOf(a.charAt(k++)),b=f<<2|g>>4,c=(15&g)<<4|h>>2,e=(3&h)<<6|i,j+=String.fromCharCode(b),64!=h&&(j+=String.fromCharCode(c)),64!=i&&(j+=String.fromCharCode(e));return j}},{}],2:[function(a,b){"use strict";function c(){this.compressedSize=0,this.uncompressedSize=0,this.crc32=0,this.compressionMethod=null,this.compressedContent=null}c.prototype={getContent:function(){return null},getCompressedContent:function(){return null}},b.exports=c},{}],3:[function(a,b,c){"use strict";c.STORE={magic:"\x00\x00",compress:function(a){return a},uncompress:function(a){return a},compressInputType:null,uncompressInputType:null},c.DEFLATE=a("./flate")},{"./flate":6}],4:[function(a,b){"use strict";function c(){this.data=null,this.length=0,this.index=0}var d=a("./utils");c.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<a||0>a)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return d.transformTo("string",this.readData(a))},readData:function(){},lastIndexOfSignature:function(){},readDate:function(){var a=this.readInt(4);return new Date((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1)}},b.exports=c},{"./utils":14}],5:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.date=null,c.compression=null},{}],6:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,e=a("pako");c.uncompressInputType=d?"uint8array":"array",c.compressInputType=d?"uint8array":"array",c.magic="\b\x00",c.compress=function(a){return e.deflateRaw(a)},c.uncompress=function(a){return e.inflateRaw(a)}},{pako:19}],7:[function(a,b){"use strict";function c(a,b){return this instanceof c?(this.files={},this.root="",a&&this.load(a,b),void(this.clone=function(){var a=new c;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a})):new c(a,b)}c.prototype=a("./object"),c.prototype.load=a("./load"),c.support=a("./support"),c.defaults=a("./defaults"),c.utils=a("./utils"),c.base64=a("./base64"),c.compressions=a("./compressions"),b.exports=c},{"./base64":1,"./compressions":3,"./defaults":5,"./load":8,"./object":9,"./support":12,"./utils":14}],8:[function(a,b){"use strict";var c=a("./base64"),d=a("./zipEntries");b.exports=function(a,b){var e,f,g,h;for(b=b||{},b.base64&&(a=c.decode(a)),f=new d(a,b),e=f.files,g=0;g<e.length;g++)h=e[g],this.file(h.fileName,h.decompressed,{binary:!0,optimizedBinaryString:!0,date:h.date,dir:h.dir});return this}},{"./base64":1,"./zipEntries":15}],9:[function(a,b){"use strict";var c,d,e=a("./support"),f=a("./utils"),g=a("./signature"),h=a("./defaults"),i=a("./base64"),j=a("./compressions"),k=a("./compressedObject"),l=a("./nodeBuffer");e.uint8array&&"function"==typeof TextEncoder&&"function"==typeof TextDecoder&&(c=new TextEncoder("utf-8"),d=new TextDecoder("utf-8"));var m=function(a){if(a._data instanceof k&&(a._data=a._data.getContent(),a.options.binary=!0,a.options.base64=!1,"uint8array"===f.getTypeOf(a._data))){var b=a._data;a._data=new Uint8Array(b.length),0!==b.length&&a._data.set(b,0)}return a._data},n=function(a){var b=m(a),d=f.getTypeOf(b);if("string"===d){if(!a.options.binary){if(c)return c.encode(b);if(e.nodebuffer)return l(b,"utf-8")}return a.asBinary()}return b},o=function(a){var b=m(this);return null===b||"undefined"==typeof b?"":(this.options.base64&&(b=i.decode(b)),b=a&&this.options.binary?A.utf8decode(b):f.transformTo("string",b),a||this.options.binary||(b=A.utf8encode(b)),b)},p=function(a,b,c){this.name=a,this._data=b,this.options=c};p.prototype={asText:function(){return o.call(this,!0)},asBinary:function(){return o.call(this,!1)},asNodeBuffer:function(){var a=n(this);return f.transformTo("nodebuffer",a)},asUint8Array:function(){var a=n(this);return f.transformTo("uint8array",a)},asArrayBuffer:function(){return this.asUint8Array().buffer}};var q=function(a,b){var c,d="";for(c=0;b>c;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},r=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c},s=function(a){return a=a||{},a.base64!==!0||null!==a.binary&&void 0!==a.binary||(a.binary=!0),a=r(a,h),a.date=a.date||new Date,null!==a.compression&&(a.compression=a.compression.toUpperCase()),a},t=function(a,b,c){var d=u(a),e=f.getTypeOf(b);if(d&&v.call(this,d),c=s(c),c.dir||null===b||"undefined"==typeof b)c.base64=!1,c.binary=!1,b=null;else if("string"===e)c.binary&&!c.base64&&c.optimizedBinaryString!==!0&&(b=f.string2binary(b));else{if(c.base64=!1,c.binary=!0,!(e||b instanceof k))throw new Error("The data of '"+a+"' is in an unsupported format !");"arraybuffer"===e&&(b=f.transformTo("uint8array",b))}var g=new p(a,b,c);return this.files[a]=g,g},u=function(a){"/"==a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},v=function(a){return"/"!=a.slice(-1)&&(a+="/"),this.files[a]||t.call(this,a,null,{dir:!0}),this.files[a]},w=function(a,b){var c,d=new k;return a._data instanceof k?(d.uncompressedSize=a._data.uncompressedSize,d.crc32=a._data.crc32,0===d.uncompressedSize||a.options.dir?(b=j.STORE,d.compressedContent="",d.crc32=0):a._data.compressionMethod===b.magic?d.compressedContent=a._data.getCompressedContent():(c=a._data.getContent(),d.compressedContent=b.compress(f.transformTo(b.compressInputType,c)))):(c=n(a),(!c||0===c.length||a.options.dir)&&(b=j.STORE,c=""),d.uncompressedSize=c.length,d.crc32=this.crc32(c),d.compressedContent=b.compress(f.transformTo(b.compressInputType,c))),d.compressedSize=d.compressedContent.length,d.compressionMethod=b.magic,d},x=function(a,b,c,d){var e,f,h=(c.compressedContent,this.utf8encode(b.name)),i=h!==b.name,j=b.options,k="",l="";e=j.date.getHours(),e<<=6,e|=j.date.getMinutes(),e<<=5,e|=j.date.getSeconds()/2,f=j.date.getFullYear()-1980,f<<=4,f|=j.date.getMonth()+1,f<<=5,f|=j.date.getDate(),i&&(l=q(1,1)+q(this.crc32(h),4)+h,k+="up"+q(l.length,2)+l);var m="";m+="\n\x00",m+=i?"\x00\b":"\x00\x00",m+=c.compressionMethod,m+=q(e,2),m+=q(f,2),m+=q(c.crc32,4),m+=q(c.compressedSize,4),m+=q(c.uncompressedSize,4),m+=q(h.length,2),m+=q(k.length,2);var n=g.LOCAL_FILE_HEADER+m+h+k,o=g.CENTRAL_FILE_HEADER+"\x00"+m+"\x00\x00\x00\x00\x00\x00"+(b.options.dir===!0?"\x00\x00\x00":"\x00\x00\x00\x00")+q(d,4)+h+k;return{fileRecord:n,dirRecord:o,compressedObject:c}},y=function(){this.data=[]};y.prototype={append:function(a){a=f.transformTo("string",a),this.data.push(a)},finalize:function(){return this.data.join("")}};var z=function(a){this.data=new Uint8Array(a),this.index=0};z.prototype={append:function(a){0!==a.length&&(a=f.transformTo("uint8array",a),this.data.set(a,this.index),this.index+=a.length)},finalize:function(){return this.data}};var A={load:function(){throw new Error("Load method is not defined. Is the file jszip-load.js included ?")},filter:function(a){var b,c,d,e,f=[];for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],e=new p(d.name,d._data,r(d.options)),c=b.slice(this.root.length,b.length),b.slice(0,this.root.length)===this.root&&a(c,e)&&f.push(e));return f},file:function(a,b,c){if(1===arguments.length){if(f.isRegExp(a)){var d=a;return this.filter(function(a,b){return!b.options.dir&&d.test(a)})}return this.filter(function(b,c){return!c.options.dir&&b===a})[0]||null}return a=this.root+a,t.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(f.isRegExp(a))return this.filter(function(b,c){return c.options.dir&&a.test(b)});var b=this.root+a,c=v.call(this,b),d=this.clone();return d.root=c.name,d},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!=a.slice(-1)&&(a+="/"),b=this.files[a]),b)if(b.options.dir)for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];else delete this.files[a];return this},generate:function(a){a=r(a||{},{base64:!0,compression:"STORE",type:"base64"}),f.checkSupport(a.type);var b,c,d=[],e=0,h=0;for(var k in this.files)if(this.files.hasOwnProperty(k)){var l=this.files[k],m=l.options.compression||a.compression.toUpperCase(),n=j[m];if(!n)throw new Error(m+" is not a valid compression method !");var o=w.call(this,l,n),p=x.call(this,k,l,o,e);e+=p.fileRecord.length+o.compressedSize,h+=p.dirRecord.length,d.push(p)}var s="";s=g.CENTRAL_DIRECTORY_END+"\x00\x00\x00\x00"+q(d.length,2)+q(d.length,2)+q(h,4)+q(e,4)+"\x00\x00";var t=a.type.toLowerCase();for(b="uint8array"===t||"arraybuffer"===t||"blob"===t||"nodebuffer"===t?new z(e+h+s.length):new y(e+h+s.length),c=0;c<d.length;c++)b.append(d[c].fileRecord),b.append(d[c].compressedObject.compressedContent);for(c=0;c<d.length;c++)b.append(d[c].dirRecord);b.append(s);var u=b.finalize();switch(a.type.toLowerCase()){case"uint8array":case"arraybuffer":case"nodebuffer":return f.transformTo(a.type.toLowerCase(),u);case"blob":return f.arrayBuffer2Blob(f.transformTo("arraybuffer",u));case"base64":return a.base64?i.encode(u):u;default:return u}},crc32:function(a,b){if("undefined"==typeof a||!a.length)return 0;var c="string"!==f.getTypeOf(a),d=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];"undefined"==typeof b&&(b=0);var e=0,g=0,h=0;b=-1^b;for(var i=0,j=a.length;j>i;i++)h=c?a[i]:a.charCodeAt(i),g=255&(b^h),e=d[g],b=b>>>8^e;return-1^b},utf8encode:function(a){if(c){var b=c.encode(a);return f.transformTo("string",b)}if(e.nodebuffer)return f.transformTo("string",l(a,"utf-8"));for(var d=[],g=0,h=0;h<a.length;h++){var i=a.charCodeAt(h);128>i?d[g++]=String.fromCharCode(i):i>127&&2048>i?(d[g++]=String.fromCharCode(i>>6|192),d[g++]=String.fromCharCode(63&i|128)):(d[g++]=String.fromCharCode(i>>12|224),d[g++]=String.fromCharCode(i>>6&63|128),d[g++]=String.fromCharCode(63&i|128))}return d.join("")},utf8decode:function(a){var b=[],c=0,g=f.getTypeOf(a),h="string"!==g,i=0,j=0,k=0,l=0;if(d)return d.decode(f.transformTo("uint8array",a));if(e.nodebuffer)return f.transformTo("nodebuffer",a).toString("utf-8");for(;i<a.length;)j=h?a[i]:a.charCodeAt(i),128>j?(b[c++]=String.fromCharCode(j),i++):j>191&&224>j?(k=h?a[i+1]:a.charCodeAt(i+1),b[c++]=String.fromCharCode((31&j)<<6|63&k),i+=2):(k=h?a[i+1]:a.charCodeAt(i+1),l=h?a[i+2]:a.charCodeAt(i+2),b[c++]=String.fromCharCode((15&j)<<12|(63&k)<<6|63&l),i+=3);return b.join("")}};b.exports=A},{"./base64":1,"./compressedObject":2,"./compressions":3,"./defaults":5,"./nodeBuffer":17,"./signature":10,"./support":12,"./utils":14}],10:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],11:[function(a,b){"use strict";function c(a,b){this.data=a,b||(this.data=e.string2binary(this.data)),this.length=this.data.length,this.index=0}var d=a("./dataReader"),e=a("./utils");c.prototype=new d,c.prototype.byteAt=function(a){return this.data.charCodeAt(a)},c.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)},c.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./dataReader":4,"./utils":14}],12:[function(a,b,c){var d=a("__browserify_process");if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer=!d.browser,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var e=new ArrayBuffer(0);try{c.blob=0===new Blob([e],{type:"application/zip"}).size}catch(f){try{var g=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,h=new g;h.append(e),c.blob=0===h.getBlob("application/zip").size}catch(f){c.blob=!1}}}},{__browserify_process:18}],13:[function(a,b){"use strict";function c(a){a&&(this.data=a,this.length=this.data.length,this.index=0)}var d=a("./dataReader");c.prototype=new d,c.prototype.byteAt=function(a){return this.data[a]},c.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f;return-1},c.prototype.readData=function(a){this.checkOffset(a);var b=this.data.subarray(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./dataReader":4}],14:[function(a,b,c){"use strict";function d(a){return a}function e(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function f(a){var b=65536,d=[],e=a.length,f=c.getTypeOf(a),g=0,h=!0;try{switch(f){case"uint8array":String.fromCharCode.apply(null,new Uint8Array(0));break;case"nodebuffer":String.fromCharCode.apply(null,j(0))}}catch(i){h=!1}if(!h){for(var k="",l=0;l<a.length;l++)k+=String.fromCharCode(a[l]);return k}for(;e>g&&b>1;)try{d.push("array"===f||"nodebuffer"===f?String.fromCharCode.apply(null,a.slice(g,Math.min(g+b,e))):String.fromCharCode.apply(null,a.subarray(g,Math.min(g+b,e)))),g+=b}catch(i){b=Math.floor(b/2)}return d.join("")}function g(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var h=a("./support"),i=a("./compressions"),j=a("./nodeBuffer");c.string2binary=function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(255&a.charCodeAt(c));return b},c.string2Uint8Array=function(a){return c.transformTo("uint8array",a)},c.uint8Array2String=function(a){return c.transformTo("string",a)},c.string2Blob=function(a){var b=c.transformTo("arraybuffer",a);return c.arrayBuffer2Blob(b)},c.arrayBuffer2Blob=function(a){c.checkSupport("blob");try{return new Blob([a],{type:"application/zip"})}catch(b){try{var d=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,e=new d;return e.append(a),e.getBlob("application/zip")}catch(b){throw new Error("Bug : can't construct the Blob.")}}};var k={};k.string={string:d,array:function(a){return e(a,new Array(a.length))},arraybuffer:function(a){return k.string.uint8array(a).buffer},uint8array:function(a){return e(a,new Uint8Array(a.length))},nodebuffer:function(a){return e(a,j(a.length))}},k.array={string:f,array:d,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(a)}},k.arraybuffer={string:function(a){return f(new Uint8Array(a))},array:function(a){return g(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:d,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(new Uint8Array(a))}},k.uint8array={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:d,nodebuffer:function(a){return j(a)}},k.nodebuffer={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return k.nodebuffer.uint8array(a).buffer},uint8array:function(a){return g(a,new Uint8Array(a.length))},nodebuffer:d},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=k[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":h.nodebuffer&&j.test(a)?"nodebuffer":h.uint8array&&a instanceof Uint8Array?"uint8array":h.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=h[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this browser")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(16>b?"0":"")+b.toString(16).toUpperCase();return d},c.findCompression=function(a){for(var b in i)if(i.hasOwnProperty(b)&&i[b].magic===a)return i[b];return null},c.isRegExp=function(a){return"[object RegExp]"===Object.prototype.toString.call(a)}},{"./compressions":3,"./nodeBuffer":17,"./support":12}],15:[function(a,b){"use strict";function c(a,b){this.files=[],this.loadOptions=b,a&&this.load(a)}var d=a("./stringReader"),e=a("./nodeBufferReader"),f=a("./uint8ArrayReader"),g=a("./utils"),h=a("./signature"),i=a("./zipEntry"),j=a("./support");c.prototype={checkSignature:function(a){var b=this.reader.readString(4);if(b!==a)throw new Error("Corrupted zip or bug : unexpected signature ("+g.pretty(b)+", expected "+g.pretty(a)+")")},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2),this.zipComment=this.reader.readString(this.zipCommentLength)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.versionMadeBy=this.reader.readString(2),this.versionNeeded=this.reader.readInt(2),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;d>e;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readString(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(h.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readString(4)===h.CENTRAL_FILE_HEADER;)a=new i({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(h.CENTRAL_DIRECTORY_END);if(-1===a)throw new Error("Corrupted zip : can't find end of central directory");if(this.reader.setIndex(a),this.checkSignature(h.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===g.MAX_VALUE_16BITS||this.diskWithCentralDirStart===g.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===g.MAX_VALUE_16BITS||this.centralDirRecords===g.MAX_VALUE_16BITS||this.centralDirSize===g.MAX_VALUE_32BITS||this.centralDirOffset===g.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR),-1===a)throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");this.reader.setIndex(a),this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}},prepareReader:function(a){var b=g.getTypeOf(a);this.reader="string"!==b||j.uint8array?"nodebuffer"===b?new e(a):new f(g.transformTo("uint8array",a)):new d(a,this.loadOptions.optimizedBinaryString)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=c},{"./nodeBufferReader":17,"./signature":10,"./stringReader":11,"./support":12,"./uint8ArrayReader":13,"./utils":14,"./zipEntry":16}],16:[function(a,b){"use strict";function c(a,b){this.options=a,this.loadOptions=b}var d=a("./stringReader"),e=a("./utils"),f=a("./compressedObject"),g=a("./object");c.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},prepareCompressedContent:function(a,b,c){return function(){var d=a.index;a.setIndex(b);var e=a.readData(c);return a.setIndex(d),e}},prepareContent:function(a,b,c,d,f){return function(){var a=e.transformTo(d.uncompressInputType,this.getCompressedContent()),b=d.uncompress(a);if(b.length!==f)throw new Error("Bug : uncompressed data size mismatch");return b}},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readString(this.fileNameLength),a.skip(c),-1==this.compressedSize||-1==this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");if(b=e.findCompression(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+e.pretty(this.compressionMethod)+" unknown (inner file : "+this.fileName+")");if(this.decompressed=new f,this.decompressed.compressedSize=this.compressedSize,this.decompressed.uncompressedSize=this.uncompressedSize,this.decompressed.crc32=this.crc32,this.decompressed.compressionMethod=this.compressionMethod,this.decompressed.getCompressedContent=this.prepareCompressedContent(a,a.index,this.compressedSize,b),this.decompressed.getContent=this.prepareContent(a,a.index,this.compressedSize,b,this.uncompressedSize),this.loadOptions.checkCRC32&&(this.decompressed=e.transformTo("string",this.decompressed.getContent()),g.crc32(this.decompressed)!==this.crc32))throw new Error("Corrupted zip : CRC32 mismatch")},readCentralPart:function(a){if(this.versionMadeBy=a.readString(2),this.versionNeeded=a.readInt(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4),this.fileNameLength=a.readInt(2),this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");this.fileName=a.readString(this.fileNameLength),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readString(this.fileCommentLength),this.dir=16&this.externalFileAttributes?!0:!1},parseZIP64ExtraField:function(){if(this.extraFields[1]){var a=new d(this.extraFields[1].value);this.uncompressedSize===e.MAX_VALUE_32BITS&&(this.uncompressedSize=a.readInt(8)),this.compressedSize===e.MAX_VALUE_32BITS&&(this.compressedSize=a.readInt(8)),this.localHeaderOffset===e.MAX_VALUE_32BITS&&(this.localHeaderOffset=a.readInt(8)),this.diskNumberStart===e.MAX_VALUE_32BITS&&(this.diskNumberStart=a.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index;for(this.extraFields=this.extraFields||{};a.index<e+this.extraFieldsLength;)b=a.readInt(2),c=a.readInt(2),d=a.readString(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){if(this.useUTF8())this.fileName=g.utf8decode(this.fileName),this.fileComment=g.utf8decode(this.fileComment);else{var a=this.findExtraFieldUnicodePath();null!==a&&(this.fileName=a)}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=new d(a.value);return 1!==b.readInt(1)?null:g.crc32(this.fileName)!==b.readInt(4)?null:g.utf8decode(b.readString(a.length-5))}return null}},b.exports=c},{"./compressedObject":2,"./object":9,"./stringReader":11,"./utils":14}],17:[function(){},{}],18:[function(a,b){var c=b.exports={};c.nextTick=function(){var a="undefined"!=typeof window&&window.setImmediate,b="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(a)return function(a){return window.setImmediate(a)};if(b){var c=[];return window.addEventListener("message",function(a){var b=a.source;if((b===window||null===b)&&"process-tick"===a.data&&(a.stopPropagation(),c.length>0)){var d=c.shift();d()}},!0),function(a){c.push(a),window.postMessage("process-tick","*")}}return function(a){setTimeout(a,0)}}(),c.title="browser",c.browser=!0,c.env={},c.argv=[],c.binding=function(){throw new Error("process.binding is not supported")},c.cwd=function(){return"/"},c.chdir=function(){throw new Error("process.chdir is not supported")}},{}],19:[function(a,b){"use strict";var c=a("./lib/utils/common").assign,d=a("./lib/deflate"),e=a("./lib/inflate"),f=a("./lib/zlib/constants"),g={};c(g,d,e,f),b.exports=g},{"./lib/deflate":20,"./lib/inflate":21,"./lib/utils/common":22,"./lib/zlib/constants":25}],20:[function(a,b,c){"use strict";function d(a,b){var c=new s(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function e(a,b){return b=b||{},b.raw=!0,d(a,b)}function f(a,b){return b=b||{},b.gzip=!0,d(a,b)}var g=a("./zlib/deflate.js"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/messages"),k=a("./zlib/zstream"),l=0,m=4,n=0,o=1,p=-1,q=0,r=8,s=function(a){this.options=h.assign({level:p,method:r,chunkSize:16384,windowBits:15,memLevel:8,strategy:q,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new k,this.strm.avail_out=0;var c=g.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==n)throw new Error(j[c]);b.header&&g.deflateSetHeader(this.strm,b.header)};s.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?m:l,e.input="string"==typeof a?i.string2buf(a):a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new h.Buf8(f),e.next_out=0,e.avail_out=f),c=g.deflate(e,d),c!==o&&c!==n)return this.onEnd(c),this.ended=!0,!1;(0===e.avail_out||0===e.avail_in&&d===m)&&this.onData("string"===this.options.to?i.buf2binstring(h.shrinkBuf(e.output,e.next_out)):h.shrinkBuf(e.output,e.next_out))}while((e.avail_in>0||0===e.avail_out)&&c!==o);return d===m?(c=g.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===n):!0},s.prototype.onData=function(a){this.chunks.push(a)},s.prototype.onEnd=function(a){a===n&&(this.result="string"===this.options.to?this.chunks.join(""):h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=s,c.deflate=d,c.deflateRaw=e,c.gzip=f},{"./utils/common":22,"./utils/strings":23,"./zlib/deflate.js":27,"./zlib/messages":32,"./zlib/zstream":34}],21:[function(a,b,c){"use strict";function d(a,b){var c=new m(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function e(a,b){return b=b||{},b.raw=!0,d(a,b)}var f=a("./zlib/inflate.js"),g=a("./utils/common"),h=a("./utils/strings"),i=a("./zlib/constants"),j=a("./zlib/messages"),k=a("./zlib/zstream"),l=a("./zlib/gzheader"),m=function(a){this.options=g.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new k,this.strm.avail_out=0;var c=f.inflateInit2(this.strm,b.windowBits);if(c!==i.Z_OK)throw new Error(j[c]);this.header=new l,f.inflateGetHeader(this.strm,this.header)};m.prototype.push=function(a,b){var c,d,e,j,k,l=this.strm,m=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?i.Z_FINISH:i.Z_NO_FLUSH,l.input="string"==typeof a?h.binstring2buf(a):a,l.next_in=0,l.avail_in=l.input.length;do{if(0===l.avail_out&&(l.output=new g.Buf8(m),l.next_out=0,l.avail_out=m),c=f.inflate(l,i.Z_NO_FLUSH),c!==i.Z_STREAM_END&&c!==i.Z_OK)return this.onEnd(c),this.ended=!0,!1;l.next_out&&(0===l.avail_out||c===i.Z_STREAM_END||0===l.avail_in&&d===i.Z_FINISH)&&("string"===this.options.to?(e=h.utf8border(l.output,l.next_out),j=l.next_out-e,k=h.buf2string(l.output,e),l.next_out=j,l.avail_out=m-j,j&&g.arraySet(l.output,l.output,e,j,0),this.onData(k)):this.onData(g.shrinkBuf(l.output,l.next_out)))
}while((l.avail_in>0||0===l.avail_out)&&c!==i.Z_STREAM_END);return c===i.Z_STREAM_END&&(d=i.Z_FINISH),d===i.Z_FINISH?(c=f.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===i.Z_OK):!0},m.prototype.onData=function(a){this.chunks.push(a)},m.prototype.onEnd=function(a){a===i.Z_OK&&(this.result="string"===this.options.to?this.chunks.join(""):g.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=m,c.inflate=d,c.inflateRaw=e,c.ungzip=d},{"./utils/common":22,"./utils/strings":23,"./zlib/constants":25,"./zlib/gzheader":28,"./zlib/inflate.js":30,"./zlib/messages":32,"./zlib/zstream":34}],22:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;c>b;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;c>b;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],23:[function(a,b,c){"use strict";var d=a("./common"),e=!0;try{String.fromCharCode.apply(null,[0])}catch(f){e=!1}for(var g=new d.Buf8(256),h=0;256>h;h++)g[h]=h>=252?6:h>=248?5:h>=240?4:h>=224?3:h>=192?2:1;g[254]=g[254]=1,c.string2buf=function(a){var b,c,e,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(e=a.charCodeAt(f+1),56320===(64512&e)&&(c=65536+(c-55296<<10)+(e-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=new d.Buf8(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(e=a.charCodeAt(f+1),56320===(64512&e)&&(c=65536+(c-55296<<10)+(e-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){if(e&&a.length<65537)return String.fromCharCode.apply(null,a);for(var b="",c=0,d=a.length;d>c;c++)b+=String.fromCharCode(a[c]);return b},c.binstring2buf=function(a){for(var b=new d.Buf8(a.length),c=0,e=b.length;e>c;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,f,h,i,j,k=b||a.length,l=new Array(2*k);for(h=0,f=0;k>f;)if(i=a[f++],128>i)l[h++]=i;else if(j=g[i],j>4)l[h++]=65533,f+=j-1;else{for(i&=2===j?31:3===j?15:7;j>1&&k>f;)i=i<<6|63&a[f++],j--;j>1?l[h++]=65533:65536>i?l[h++]=i:(i-=65536,l[h++]=55296|i>>10&1023,l[h++]=56320|1023&i)}if(e)return String.fromCharCode.apply(null,d.shrinkBuf(l,h));for(c="",f=0,k=h;k>f;f++)c+=String.fromCharCode(l[f]);return c},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+g[a[c]]>b?c:b}},{"./common":22}],24:[function(a,b){"use strict";function c(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=c},{}],25:[function(a,b){b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],26:[function(a,b){"use strict";function c(){for(var a,b=[],c=0;256>c;c++){a=c;for(var d=0;8>d;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function d(a,b,c,d){var f=e,g=d+c;a=-1^a;for(var h=d;g>h;h++)a=a>>>8^f[255&(a^b[h])];return-1^a}var e=c();b.exports=d},{}],27:[function(a,b,c){"use strict";function d(a,b){return a.msg=G[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(C.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){D._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,C.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=E(a.adler,b,e,c):2===a.state.wrap&&(a.adler=F(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-jb?a.strstart-(a.w_size-jb):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ib,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&m>f);if(d=ib-(m-f),f=m-ib,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-jb)){C.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=hb)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+hb-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<hb)););}while(a.lookahead<jb&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===H)return sb;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return sb;if(a.strstart-a.block_start>=a.w_size-jb&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?sb:sb}function o(a,b){for(var c,d;;){if(a.lookahead<jb){if(m(a),a.lookahead<jb&&b===H)return sb;if(0===a.lookahead)break}if(c=0,a.lookahead>=hb&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-jb&&(a.match_length=l(a,c)),a.match_length>=hb)if(d=D._tr_tally(a,a.strstart-a.match_start,a.match_length-hb),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=hb){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=a.strstart<hb-1?a.strstart:hb-1,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function p(a,b){for(var c,d,e;;){if(a.lookahead<jb){if(m(a),a.lookahead<jb&&b===H)return sb;if(0===a.lookahead)break}if(c=0,a.lookahead>=hb&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=hb-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-jb&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===S||a.match_length===hb&&a.strstart-a.match_start>4096)&&(a.match_length=hb-1)),a.prev_length>=hb&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-hb,d=D._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-hb),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=hb-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return sb}else if(a.match_available){if(d=D._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return sb}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=D._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<hb-1?a.strstart:hb-1,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ib){if(m(a),a.lookahead<=ib&&b===H)return sb;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=hb&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ib;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&f>e);a.match_length=ib-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=hb?(c=D._tr_tally(a,1,a.match_length-hb),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===H)return sb;break}if(a.match_length=0,c=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function s(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=B[a.level].max_lazy,a.good_match=B[a.level].good_length,a.nice_match=B[a.level].nice_length,a.max_chain_length=B[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=hb-1,a.match_available=0,a.ins_h=0}function t(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Y,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new C.Buf16(2*fb),this.dyn_dtree=new C.Buf16(2*(2*db+1)),this.bl_tree=new C.Buf16(2*(2*eb+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new C.Buf16(gb+1),this.heap=new C.Buf16(2*cb+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new C.Buf16(2*cb+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function u(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=X,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?lb:qb,a.adler=2===b.wrap?0:1,b.last_flush=H,D._tr_init(b),M):d(a,O)}function v(a){var b=u(a);return b===M&&s(a.state),b}function w(a,b){return a&&a.state?2!==a.state.wrap?O:(a.state.gzhead=b,M):O}function x(a,b,c,e,f,g){if(!a)return O;var h=1;if(b===R&&(b=6),0>e?(h=0,e=-e):e>15&&(h=2,e-=16),1>f||f>Z||c!==Y||8>e||e>15||0>b||b>9||0>g||g>V)return d(a,O);8===e&&(e=9);var i=new t;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+hb-1)/hb),i.window=new C.Buf8(2*i.w_size),i.head=new C.Buf16(i.hash_size),i.prev=new C.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new C.Buf8(i.pending_buf_size),i.d_buf=i.lit_bufsize>>1,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,v(a)}function y(a,b){return x(a,b,Y,$,_,W)}function z(a,b){var c,h,k,l;if(!a||!a.state||b>L||0>b)return a?d(a,O):O;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===rb&&b!==K)return d(a,0===a.avail_out?Q:O);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===lb)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=T||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=F(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=mb):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=T||h.level<2?4:0),i(h,wb),h.status=qb);else{var m=Y+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=T||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=kb),m+=31-m%31,h.status=qb,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===mb)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=nb)}else h.status=nb;if(h.status===nb)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=ob)}else h.status=ob;if(h.status===ob)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=pb)}else h.status=pb;if(h.status===pb&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=qb)):h.status=qb),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,M}else if(0===a.avail_in&&e(b)<=e(c)&&b!==K)return d(a,Q);if(h.status===rb&&0!==a.avail_in)return d(a,Q);if(0!==a.avail_in||0!==h.lookahead||b!==H&&h.status!==rb){var o=h.strategy===T?r(h,b):h.strategy===U?q(h,b):B[h.level].func(h,b);if((o===ub||o===vb)&&(h.status=rb),o===sb||o===ub)return 0===a.avail_out&&(h.last_flush=-1),M;if(o===tb&&(b===I?D._tr_align(h):b!==L&&(D._tr_stored_block(h,0,0,!1),b===J&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,M}return b!==K?M:h.wrap<=0?N:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?M:N)}function A(a){var b;return a&&a.state?(b=a.state.status,b!==lb&&b!==mb&&b!==nb&&b!==ob&&b!==pb&&b!==qb&&b!==rb?d(a,O):(a.state=null,b===qb?d(a,P):M)):O}var B,C=a("../utils/common"),D=a("./trees"),E=a("./adler32"),F=a("./crc32"),G=a("./messages"),H=0,I=1,J=3,K=4,L=5,M=0,N=1,O=-2,P=-3,Q=-5,R=-1,S=1,T=2,U=3,V=4,W=0,X=2,Y=8,Z=9,$=15,_=8,ab=29,bb=256,cb=bb+1+ab,db=30,eb=19,fb=2*cb+1,gb=15,hb=3,ib=258,jb=ib+hb+1,kb=32,lb=42,mb=69,nb=73,ob=91,pb=103,qb=113,rb=666,sb=1,tb=2,ub=3,vb=4,wb=3,xb=function(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e};B=[new xb(0,0,0,0,n),new xb(4,4,8,4,o),new xb(4,5,16,8,o),new xb(4,6,32,32,o),new xb(4,4,16,16,p),new xb(8,16,32,32,p),new xb(8,16,128,128,p),new xb(8,32,128,256,p),new xb(32,128,258,1024,p),new xb(32,258,258,4096,p)],c.deflateInit=y,c.deflateInit2=x,c.deflateReset=v,c.deflateResetKeep=u,c.deflateSetHeader=w,c.deflate=z,c.deflateEnd=A,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":22,"./adler32":24,"./crc32":26,"./messages":32,"./trees":33}],28:[function(a,b){"use strict";function c(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=c},{}],29:[function(a,b){"use strict";var c=30,d=12;b.exports=function(a,b){var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;e=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=e.dmax,l=e.wsize,m=e.whave,n=e.wnext,o=e.window,p=e.hold,q=e.bits,r=e.lencode,s=e.distcode,t=(1<<e.lenbits)-1,u=(1<<e.distbits)-1;a:do{15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){e.mode=d;break a}a.msg="invalid literal/length code",e.mode=c;break a}x=65535&v,w&=15,w&&(w>q&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",e.mode=c;break a}if(y=65535&v,w&=15,w>q&&(p+=B[f++]<<q,q+=8,w>q&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",e.mode=c;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&e.sane){a.msg="invalid distance too far back",e.mode=c;break a}if(z=0,A=o,0===n){if(z+=l-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(w>n){if(z+=l+n-w,w-=n,x>w){x-=w;do C[h++]=o[z++];while(--w);if(z=0,x>n){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(g>f&&j>h);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=g>f?5+(g-f):5-(f-g),a.avail_out=j>h?257+(j-h):257-(h-j),e.hold=p,e.bits=q}},{}],30:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new r.Buf16(320),this.work=new r.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=K,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new r.Buf32(ob),b.distcode=b.distdyn=new r.Buf32(pb),b.sane=1,b.back=-1,C):F}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):F}function h(a,b){var c,d;return a&&a.state?(d=a.state,0>b?(c=0,b=-b):(c=(b>>4)+1,48>b&&(b&=15)),b&&(8>b||b>15)?F:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):F}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==C&&(a.state=null),c):F}function j(a){return i(a,rb)}function k(a){if(sb){var b;for(p=new r.Buf32(512),q=new r.Buf32(32),b=0;144>b;)a.lens[b++]=8;for(;256>b;)a.lens[b++]=9;for(;280>b;)a.lens[b++]=7;for(;288>b;)a.lens[b++]=8;for(v(x,a.lens,0,288,p,0,a.work,{bits:9}),b=0;32>b;)a.lens[b++]=5;v(y,a.lens,0,32,q,0,a.work,{bits:5}),sb=!1}a.lencode=p,a.lenbits=9,a.distcode=q,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new r.Buf8(f.wsize)),d>=f.wsize?(r.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),r.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(r.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,ob,pb,qb,rb,sb,tb,ub,vb,wb,xb,yb,zb,Ab=0,Bb=new r.Buf8(4),Cb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return F;c=a.state,c.mode===V&&(c.mode=W),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xb=C;a:for(;;)switch(c.mode){case K:if(0===c.wrap){c.mode=W;break}for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0),m=0,n=0,c.mode=L;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=lb;break}if((15&m)!==J){a.msg="unknown compression method",c.mode=lb;break}if(m>>>=4,n-=4,wb=(15&m)+8,0===c.wbits)c.wbits=wb;else if(wb>c.wbits){a.msg="invalid window size",c.mode=lb;break}c.dmax=1<<wb,a.adler=c.check=1,c.mode=512&m?T:V,m=0,n=0;break;case L:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==J){a.msg="unknown compression method",c.mode=lb;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=lb;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0,c.mode=M;case M:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,Bb[2]=m>>>16&255,Bb[3]=m>>>24&255,c.check=t(c.check,Bb,4,0)),m=0,n=0,c.mode=N;case N:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0,c.mode=O;case O:if(1024&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=P;case P:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wb=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),r.arraySet(c.head.extra,e,g,q,wb)),512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=Q;case Q:if(2048&c.flags){if(0===i)break a;q=0;do wb=e[g+q++],c.head&&wb&&c.length<65536&&(c.head.name+=String.fromCharCode(wb));while(wb&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wb)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=R;case R:if(4096&c.flags){if(0===i)break a;q=0;do wb=e[g+q++],c.head&&wb&&c.length<65536&&(c.head.comment+=String.fromCharCode(wb));while(wb&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wb)break a}else c.head&&(c.head.comment=null);c.mode=S;case S:if(512&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=lb;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=V;break;case T:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=U;case U:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,E;a.adler=c.check=1,c.mode=V;case V:if(b===A||b===B)break a;case W:if(c.last){m>>>=7&n,n-=7&n,c.mode=ib;break}for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=X;break;case 1:if(k(c),c.mode=bb,b===B){m>>>=2,n-=2;break a}break;case 2:c.mode=$;break;case 3:a.msg="invalid block type",c.mode=lb}m>>>=2,n-=2;break;case X:for(m>>>=7&n,n-=7&n;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=lb;break}if(c.length=65535&m,m=0,n=0,c.mode=Y,b===B)break a;case Y:c.mode=Z;case Z:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;r.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=V;break;case $:for(;14>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=lb;break}c.have=0,c.mode=_;case _:for(;c.have<c.ncode;){for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Cb[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Cb[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,yb={bits:c.lenbits},xb=v(w,c.lens,0,19,c.lencode,0,c.work,yb),c.lenbits=yb.bits,xb){a.msg="invalid code lengths set",c.mode=lb;break}c.have=0,c.mode=ab;case ab:for(;c.have<c.nlen+c.ndist;){for(;Ab=c.lencode[m&(1<<c.lenbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(16>sb)m>>>=qb,n-=qb,c.lens[c.have++]=sb;else{if(16===sb){for(zb=qb+2;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qb,n-=qb,0===c.have){a.msg="invalid bit length repeat",c.mode=lb;break}wb=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sb){for(zb=qb+3;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qb,n-=qb,wb=0,q=3+(7&m),m>>>=3,n-=3}else{for(zb=qb+7;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qb,n-=qb,wb=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=lb;break}for(;q--;)c.lens[c.have++]=wb}}if(c.mode===lb)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=lb;break}if(c.lenbits=9,yb={bits:c.lenbits},xb=v(x,c.lens,0,c.nlen,c.lencode,0,c.work,yb),c.lenbits=yb.bits,xb){a.msg="invalid literal/lengths set",c.mode=lb;break}if(c.distbits=6,c.distcode=c.distdyn,yb={bits:c.distbits},xb=v(y,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,yb),c.distbits=yb.bits,xb){a.msg="invalid distances set",c.mode=lb;break}if(c.mode=bb,b===B)break a;case bb:c.mode=cb;case cb:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,u(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===V&&(c.back=-1);break}for(c.back=0;Ab=c.lencode[m&(1<<c.lenbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(rb&&0===(240&rb)){for(tb=qb,ub=rb,vb=sb;Ab=c.lencode[vb+((m&(1<<tb+ub)-1)>>tb)],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=tb+qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=tb,n-=tb,c.back+=tb}if(m>>>=qb,n-=qb,c.back+=qb,c.length=sb,0===rb){c.mode=hb;break}if(32&rb){c.back=-1,c.mode=V;break}if(64&rb){a.msg="invalid literal/length code",c.mode=lb;break}c.extra=15&rb,c.mode=db;case db:if(c.extra){for(zb=c.extra;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=eb;case eb:for(;Ab=c.distcode[m&(1<<c.distbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&rb)){for(tb=qb,ub=rb,vb=sb;Ab=c.distcode[vb+((m&(1<<tb+ub)-1)>>tb)],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=tb+qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=tb,n-=tb,c.back+=tb}if(m>>>=qb,n-=qb,c.back+=qb,64&rb){a.msg="invalid distance code",c.mode=lb;break}c.offset=sb,c.extra=15&rb,c.mode=fb;case fb:if(c.extra){for(zb=c.extra;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=lb;break}c.mode=gb;case gb:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=lb;break}q>c.wnext?(q-=c.wnext,ob=c.wsize-q):ob=c.wnext-q,q>c.length&&(q=c.length),pb=c.window}else pb=f,ob=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pb[ob++];while(--q);0===c.length&&(c.mode=cb);break;case hb:if(0===j)break a;f[h++]=c.length,j--,c.mode=cb;break;case ib:if(c.wrap){for(;32>n;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?t(c.check,f,p,h-p):s(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=lb;break}m=0,n=0}c.mode=jb;case jb:if(c.wrap&&c.flags){for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=lb;break}m=0,n=0}c.mode=kb;case kb:xb=D;break a;case lb:xb=G;break a;case mb:return H;case nb:default:return F}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<lb&&(c.mode<ib||b!==z))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=mb,H):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?t(c.check,f,p,a.next_out-p):s(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===V?128:0)+(c.mode===bb||c.mode===Y?256:0),(0===o&&0===p||b===z)&&xb===C&&(xb=I),xb)}function n(a){if(!a||!a.state)return F;var b=a.state;return b.window&&(b.window=null),a.state=null,C}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?F:(c.head=b,b.done=!1,C)):F}var p,q,r=a("../utils/common"),s=a("./adler32"),t=a("./crc32"),u=a("./inffast"),v=a("./inftrees"),w=0,x=1,y=2,z=4,A=5,B=6,C=0,D=1,E=2,F=-2,G=-3,H=-4,I=-5,J=8,K=1,L=2,M=3,N=4,O=5,P=6,Q=7,R=8,S=9,T=10,U=11,V=12,W=13,X=14,Y=15,Z=16,$=17,_=18,ab=19,bb=20,cb=21,db=22,eb=23,fb=24,gb=25,hb=26,ib=27,jb=28,kb=29,lb=30,mb=31,nb=32,ob=852,pb=592,qb=15,rb=qb,sb=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":22,"./adler32":24,"./crc32":26,"./inffast":29,"./inftrees":31}],31:[function(a,b){"use strict";var c=a("../utils/common"),d=15,e=852,f=592,g=0,h=1,i=2,j=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],k=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],l=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],m=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];
b.exports=function(a,b,n,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new c.Buf16(d+1),Q=new c.Buf16(d+1),R=null,S=0;for(D=0;d>=D;D++)P[D]=0;for(E=0;o>E;E++)P[b[n+E]]++;for(H=C,G=d;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;G>F&&0===P[F];F++);for(F>H&&(H=F),K=1,D=1;d>=D;D++)if(K<<=1,K-=P[D],0>K)return-1;if(K>0&&(a===g||1!==G))return-1;for(Q[1]=0,D=1;d>D;D++)Q[D+1]=Q[D]+P[D];for(E=0;o>E;E++)0!==b[n+E]&&(r[Q[b[n+E]]++]=E);switch(a){case g:N=R=r,y=19;break;case h:N=j,O-=257,R=k,S-=257,y=256;break;default:N=l,R=m,y=-1}if(M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===h&&L>e||a===i&&L>f)return 1;for(var T=0;;){T++,z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[n+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;G>I+J&&(K-=P[I+J],!(0>=K));)I++,K<<=1;if(L+=1<<I,a===h&&L>e||a===i&&L>f)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":22}],32:[function(a,b){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],33:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a){return 256>a?gb[a]:gb[256+(a>>>7)]}function f(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function g(a,b,c){a.bi_valid>V-c?(a.bi_buf|=b<<a.bi_valid&65535,f(a,a.bi_buf),a.bi_buf=b>>V-a.bi_valid,a.bi_valid+=c-V):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function h(a,b,c){g(a,c[2*b],c[2*b+1])}function i(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function j(a){16===a.bi_valid?(f(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function k(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;U>=f;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;T>c;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function l(a,b,c){var d,e,f=new Array(U+1),g=0;for(d=1;U>=d;d++)f[d]=g=g+c[d-1]<<1;for(e=0;b>=e;e++){var h=a[2*e+1];0!==h&&(a[2*e]=i(f[h]++,h))}}function m(){var a,b,c,d,e,f=new Array(U+1);for(c=0,d=0;O-1>d;d++)for(ib[d]=c,a=0;a<1<<_[d];a++)hb[c++]=d;for(hb[c-1]=d,e=0,d=0;16>d;d++)for(jb[d]=e,a=0;a<1<<ab[d];a++)gb[e++]=d;for(e>>=7;R>d;d++)for(jb[d]=e<<7,a=0;a<1<<ab[d]-7;a++)gb[256+e++]=d;for(b=0;U>=b;b++)f[b]=0;for(a=0;143>=a;)eb[2*a+1]=8,a++,f[8]++;for(;255>=a;)eb[2*a+1]=9,a++,f[9]++;for(;279>=a;)eb[2*a+1]=7,a++,f[7]++;for(;287>=a;)eb[2*a+1]=8,a++,f[8]++;for(l(eb,Q+1,f),a=0;R>a;a++)fb[2*a+1]=5,fb[2*a]=i(a,5);kb=new nb(eb,_,P+1,Q,U),lb=new nb(fb,ab,0,R,U),mb=new nb(new Array(0),bb,0,S,W)}function n(a){var b;for(b=0;Q>b;b++)a.dyn_ltree[2*b]=0;for(b=0;R>b;b++)a.dyn_dtree[2*b]=0;for(b=0;S>b;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*X]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function o(a){a.bi_valid>8?f(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function p(a,b,c,d){o(a),d&&(f(a,c),f(a,~c)),E.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function q(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function r(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&q(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!q(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function s(a,b,c){var d,f,i,j,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],f=a.pending_buf[a.l_buf+k],k++,0===d?h(a,f,b):(i=hb[f],h(a,i+P+1,b),j=_[i],0!==j&&(f-=ib[i],g(a,f,j)),d--,i=e(d),h(a,i,c),j=ab[i],0!==j&&(d-=jb[i],g(a,d,j)));while(k<a.last_lit);h(a,X,b)}function t(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=T,c=0;i>c;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=2>j?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)r(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],r(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,r(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],k(a,b),l(f,j,a.bl_count)}function u(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;c>=d;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(j>h?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*Y]++):10>=h?a.bl_tree[2*Z]++:a.bl_tree[2*$]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function v(a,b,c){var d,e,f=-1,i=b[1],j=0,k=7,l=4;for(0===i&&(k=138,l=3),d=0;c>=d;d++)if(e=i,i=b[2*(d+1)+1],!(++j<k&&e===i)){if(l>j){do h(a,e,a.bl_tree);while(0!==--j)}else 0!==e?(e!==f&&(h(a,e,a.bl_tree),j--),h(a,Y,a.bl_tree),g(a,j-3,2)):10>=j?(h(a,Z,a.bl_tree),g(a,j-3,3)):(h(a,$,a.bl_tree),g(a,j-11,7));j=0,f=e,0===i?(k=138,l=3):e===i?(k=6,l=3):(k=7,l=4)}}function w(a){var b;for(u(a,a.dyn_ltree,a.l_desc.max_code),u(a,a.dyn_dtree,a.d_desc.max_code),t(a,a.bl_desc),b=S-1;b>=3&&0===a.bl_tree[2*cb[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function x(a,b,c,d){var e;for(g(a,b-257,5),g(a,c-1,5),g(a,d-4,4),e=0;d>e;e++)g(a,a.bl_tree[2*cb[e]+1],3);v(a,a.dyn_ltree,b-1),v(a,a.dyn_dtree,c-1)}function y(a){var b,c=4093624447;for(b=0;31>=b;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return G;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return H;for(b=32;P>b;b++)if(0!==a.dyn_ltree[2*b])return H;return G}function z(a){pb||(m(),pb=!0),a.l_desc=new ob(a.dyn_ltree,kb),a.d_desc=new ob(a.dyn_dtree,lb),a.bl_desc=new ob(a.bl_tree,mb),a.bi_buf=0,a.bi_valid=0,n(a)}function A(a,b,c,d){g(a,(J<<1)+(d?1:0),3),p(a,b,c,!0)}function B(a){g(a,K<<1,3),h(a,X,eb),j(a)}function C(a,b,c,d){var e,f,h=0;a.level>0?(a.strm.data_type===I&&(a.strm.data_type=y(a)),t(a,a.l_desc),t(a,a.d_desc),h=w(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,e>=f&&(e=f)):e=f=c+5,e>=c+4&&-1!==b?A(a,b,c,d):a.strategy===F||f===e?(g(a,(K<<1)+(d?1:0),3),s(a,eb,fb)):(g(a,(L<<1)+(d?1:0),3),x(a,a.l_desc.max_code+1,a.d_desc.max_code+1,h+1),s(a,a.dyn_ltree,a.dyn_dtree)),n(a),d&&o(a)}function D(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(hb[c]+P+1)]++,a.dyn_dtree[2*e(b)]++),a.last_lit===a.lit_bufsize-1}var E=a("../utils/common"),F=4,G=0,H=1,I=2,J=0,K=1,L=2,M=3,N=258,O=29,P=256,Q=P+1+O,R=30,S=19,T=2*Q+1,U=15,V=16,W=7,X=256,Y=16,Z=17,$=18,_=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ab=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],bb=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],cb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],db=512,eb=new Array(2*(Q+2));d(eb);var fb=new Array(2*R);d(fb);var gb=new Array(db);d(gb);var hb=new Array(N-M+1);d(hb);var ib=new Array(O);d(ib);var jb=new Array(R);d(jb);var kb,lb,mb,nb=function(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length},ob=function(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b},pb=!1;c._tr_init=z,c._tr_stored_block=A,c._tr_flush_block=C,c._tr_tally=D,c._tr_align=B},{"../utils/common":22}],34:[function(a,b){"use strict";function c(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=c},{}]},{},[7])(7)});

}) ( false );



// src/libs/zlib.js

( function ( scope ) {

/*
 * Extracted from pdf.js
 * https://github.com/andreasgal/pdf.js
 */

window.DecodeStream=function(){function e(){this.pos=0,this.bufferLength=0,this.eof=!1,this.buffer=null}return e.prototype={ensureBuffer:function(e){var t=this.buffer,r=t?t.byteLength:0;if(r>e)return t;for(var i=512;e>i;)i<<=1;for(var s=new Uint8Array(i),f=0;r>f;++f)s[f]=t[f];return this.buffer=s},getByte:function(){for(var e=this.pos;this.bufferLength<=e;){if(this.eof)return null;this.readBlock()}return this.buffer[this.pos++]},getBytes:function(e){var t=this.pos;if(e){this.ensureBuffer(t+e);for(var r=t+e;!this.eof&&this.bufferLength<r;)this.readBlock();var i=this.bufferLength;r>i&&(r=i)}else{for(;!this.eof;)this.readBlock();var r=this.bufferLength}return this.pos=r,this.buffer.subarray(t,r)},lookChar:function(){for(var e=this.pos;this.bufferLength<=e;){if(this.eof)return null;this.readBlock()}return String.fromCharCode(this.buffer[this.pos])},getChar:function(){for(var e=this.pos;this.bufferLength<=e;){if(this.eof)return null;this.readBlock()}return String.fromCharCode(this.buffer[this.pos++])},makeSubStream:function(e,t,r){for(var i=e+t;this.bufferLength<=i&&!this.eof;)this.readBlock();return new Stream(this.buffer,e,t,r)},skip:function(e){e||(e=1),this.pos+=e},reset:function(){this.pos=0}},e}(),window.FlateStream=function(){function e(e){throw new Error(e)}function t(t){var r=0,i=t[r++],s=t[r++];(-1==i||-1==s)&&e("Invalid header in flate stream"),8!=(15&i)&&e("Unknown compression method in flate stream"),((i<<8)+s)%31!=0&&e("Bad FCHECK in flate stream"),32&s&&e("FDICT bit set in flate stream"),this.bytes=t,this.bytesPos=r,this.codeSize=0,this.codeBuf=0,DecodeStream.call(this)}var r=new Uint32Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),i=new Uint32Array([3,4,5,6,7,8,9,10,65547,65549,65551,65553,131091,131095,131099,131103,196643,196651,196659,196667,262211,262227,262243,262259,327811,327843,327875,327907,258,258,258]),s=new Uint32Array([1,2,3,4,65541,65543,131081,131085,196625,196633,262177,262193,327745,327777,393345,393409,459009,459137,524801,525057,590849,591361,657409,658433,724993,727041,794625,798721,868353,876545]),f=[new Uint32Array([459008,524368,524304,524568,459024,524400,524336,590016,459016,524384,524320,589984,524288,524416,524352,590048,459012,524376,524312,589968,459028,524408,524344,590032,459020,524392,524328,59e4,524296,524424,524360,590064,459010,524372,524308,524572,459026,524404,524340,590024,459018,524388,524324,589992,524292,524420,524356,590056,459014,524380,524316,589976,459030,524412,524348,590040,459022,524396,524332,590008,524300,524428,524364,590072,459009,524370,524306,524570,459025,524402,524338,590020,459017,524386,524322,589988,524290,524418,524354,590052,459013,524378,524314,589972,459029,524410,524346,590036,459021,524394,524330,590004,524298,524426,524362,590068,459011,524374,524310,524574,459027,524406,524342,590028,459019,524390,524326,589996,524294,524422,524358,590060,459015,524382,524318,589980,459031,524414,524350,590044,459023,524398,524334,590012,524302,524430,524366,590076,459008,524369,524305,524569,459024,524401,524337,590018,459016,524385,524321,589986,524289,524417,524353,590050,459012,524377,524313,589970,459028,524409,524345,590034,459020,524393,524329,590002,524297,524425,524361,590066,459010,524373,524309,524573,459026,524405,524341,590026,459018,524389,524325,589994,524293,524421,524357,590058,459014,524381,524317,589978,459030,524413,524349,590042,459022,524397,524333,590010,524301,524429,524365,590074,459009,524371,524307,524571,459025,524403,524339,590022,459017,524387,524323,589990,524291,524419,524355,590054,459013,524379,524315,589974,459029,524411,524347,590038,459021,524395,524331,590006,524299,524427,524363,590070,459011,524375,524311,524575,459027,524407,524343,590030,459019,524391,524327,589998,524295,524423,524359,590062,459015,524383,524319,589982,459031,524415,524351,590046,459023,524399,524335,590014,524303,524431,524367,590078,459008,524368,524304,524568,459024,524400,524336,590017,459016,524384,524320,589985,524288,524416,524352,590049,459012,524376,524312,589969,459028,524408,524344,590033,459020,524392,524328,590001,524296,524424,524360,590065,459010,524372,524308,524572,459026,524404,524340,590025,459018,524388,524324,589993,524292,524420,524356,590057,459014,524380,524316,589977,459030,524412,524348,590041,459022,524396,524332,590009,524300,524428,524364,590073,459009,524370,524306,524570,459025,524402,524338,590021,459017,524386,524322,589989,524290,524418,524354,590053,459013,524378,524314,589973,459029,524410,524346,590037,459021,524394,524330,590005,524298,524426,524362,590069,459011,524374,524310,524574,459027,524406,524342,590029,459019,524390,524326,589997,524294,524422,524358,590061,459015,524382,524318,589981,459031,524414,524350,590045,459023,524398,524334,590013,524302,524430,524366,590077,459008,524369,524305,524569,459024,524401,524337,590019,459016,524385,524321,589987,524289,524417,524353,590051,459012,524377,524313,589971,459028,524409,524345,590035,459020,524393,524329,590003,524297,524425,524361,590067,459010,524373,524309,524573,459026,524405,524341,590027,459018,524389,524325,589995,524293,524421,524357,590059,459014,524381,524317,589979,459030,524413,524349,590043,459022,524397,524333,590011,524301,524429,524365,590075,459009,524371,524307,524571,459025,524403,524339,590023,459017,524387,524323,589991,524291,524419,524355,590055,459013,524379,524315,589975,459029,524411,524347,590039,459021,524395,524331,590007,524299,524427,524363,590071,459011,524375,524311,524575,459027,524407,524343,590031,459019,524391,524327,589999,524295,524423,524359,590063,459015,524383,524319,589983,459031,524415,524351,590047,459023,524399,524335,590015,524303,524431,524367,590079]),9],n=[new Uint32Array([327680,327696,327688,327704,327684,327700,327692,327708,327682,327698,327690,327706,327686,327702,327694,0,327681,327697,327689,327705,327685,327701,327693,327709,327683,327699,327691,327707,327687,327703,327695,0]),5];return t.prototype=Object.create(DecodeStream.prototype),t.prototype.getBits=function(t){for(var r,i=this.codeSize,s=this.codeBuf,f=this.bytes,n=this.bytesPos;t>i;)"undefined"==typeof(r=f[n++])&&e("Bad encoding in flate stream"),s|=r<<i,i+=8;return r=s&(1<<t)-1,this.codeBuf=s>>t,this.codeSize=i-=t,this.bytesPos=n,r},t.prototype.getCode=function(t){for(var r=t[0],i=t[1],s=this.codeSize,f=this.codeBuf,n=this.bytes,o=this.bytesPos;i>s;){var a;"undefined"==typeof(a=n[o++])&&e("Bad encoding in flate stream"),f|=a<<s,s+=8}var h=r[f&(1<<i)-1],u=h>>16,d=65535&h;return(0==s||u>s||0==u)&&e("Bad encoding in flate stream"),this.codeBuf=f>>u,this.codeSize=s-u,this.bytesPos=o,d},t.prototype.generateHuffmanTable=function(e){for(var t=e.length,r=0,i=0;t>i;++i)e[i]>r&&(r=e[i]);for(var s=1<<r,f=new Uint32Array(s),n=1,o=0,a=2;r>=n;++n,o<<=1,a<<=1)for(var h=0;t>h;++h)if(e[h]==n){for(var u=0,d=o,i=0;n>i;++i)u=u<<1|1&d,d>>=1;for(var i=u;s>i;i+=a)f[i]=n<<16|h;++o}return[f,r]},t.prototype.readBlock=function(){function t(e,t,r,i,s){for(var f=e.getBits(r)+i;f-->0;)t[S++]=s}var o=this.getBits(3);if(1&o&&(this.eof=!0),o>>=1,0==o){var a,h=this.bytes,u=this.bytesPos;"undefined"==typeof(a=h[u++])&&e("Bad block header in flate stream");var d=a;"undefined"==typeof(a=h[u++])&&e("Bad block header in flate stream"),d|=a<<8,"undefined"==typeof(a=h[u++])&&e("Bad block header in flate stream");var c=a;"undefined"==typeof(a=h[u++])&&e("Bad block header in flate stream"),c|=a<<8,c!=(65535&~d)&&e("Bad uncompressed block length in flate stream"),this.codeBuf=0,this.codeSize=0;var l=this.bufferLength,b=this.ensureBuffer(l+d),g=l+d;this.bufferLength=g;for(var v=l;g>v;++v){if("undefined"==typeof(a=h[u++])){this.eof=!0;break}b[v]=a}return void(this.bytesPos=u)}var y,B;if(1==o)y=f,B=n;else if(2==o){for(var p=this.getBits(5)+257,m=this.getBits(5)+1,k=this.getBits(4)+4,w=Array(r.length),S=0;k>S;)w[r[S++]]=this.getBits(3);for(var C=this.generateHuffmanTable(w),L=0,S=0,A=p+m,U=new Array(A);A>S;){var P=this.getCode(C);16==P?t(this,U,2,3,L):17==P?t(this,U,3,3,L=0):18==P?t(this,U,7,11,L=0):U[S++]=L=P}y=this.generateHuffmanTable(U.slice(0,p)),B=this.generateHuffmanTable(U.slice(p,A))}else e("Unknown block type in flate stream");for(var b=this.buffer,z=b?b.length:0,H=this.bufferLength;;){var T=this.getCode(y);if(256>T)H+1>=z&&(b=this.ensureBuffer(H+1),z=b.length),b[H++]=T;else{if(256==T)return void(this.bufferLength=H);T-=257,T=i[T];var D=T>>16;D>0&&(D=this.getBits(D));var L=(65535&T)+D;T=this.getCode(B),T=s[T],D=T>>16,D>0&&(D=this.getBits(D));var F=(65535&T)+D;H+L>=z&&(b=this.ensureBuffer(H+L),z=b.length);for(var E=0;L>E;++E,++H)b[H]=b[H-F]}}},t}();

}) ( false );




/*
 * GOT
 * @author: ohmed
 * Landing page js
*/

var Landing = {

    href: '/got',

    currentPage: 0,
    currentSlide: 0,
    currentImageViewerScreen: 0,

    slideInterval: false,
    sliderActiveBG: 0,

    slides: [

                {
                    quote: { text: '<font style="font-size: 28px; color: #c22;">"</font>Best 3D map in browser I have seen...<font style="font-size: 28px; color: #c22;">"</font>', author: '- Lui Corban' },
                    image: 'img/img1.jpg'
                },

                {
                    quote: { text: '<font style="font-size: 28px; color: #c22;">"</font>It\'s new level of web!<font style="font-size: 28px; color: #c22;">"</font>', author: '- Donald Alber' },
                    image: 'img/img2.jpg'
                },

                {
                    quote: { text: '<font style="font-size: 28px; color: #c22;">"</font>Recently I thought it wasn\'t even possible...<font style="font-size: 28px; color: #c22;">"</font>', author: '- Alex Sandarm' },
                    image: 'img/img3.jpg'
                },

                {
                    quote: { text: '<font style="font-size: 28px; color: #c22;">"</font>I am Game of Thrones fan</br>and I love this awesome map!<font style="font-size: 28px; color: #c22;">"</font>', author: '- Devid Merdok' },
                    image: 'img/img4.jpg'
                }

            ]

};

Landing.preInit = function () {

    if ( NWE.isMobile() ) {

        $(document.head).append( '<style>body { position: absolute; width: 100%; top: 0px; left: 0px; height: 100%; } .desktop { display: none !important; } .mobile { display: block !important; }</style>' );

    }

};

Landing.init = function () {

    if ( ! NWE.isMobile() ) {

        this.initCarousel();

        Landing.handleRoute( window.location.pathname );

        if ( ! NWE.Detector.isWebGLSupported() ) {

            $('#start-btn').addClass( 'disabled-btn' );
            $('#start-btn').html( 'Sorry,&nbsp;&nbsp;you&nbsp;&nbsp;don\'t&nbsp;&nbsp;have&nbsp;&nbsp;webGL :(' );
            $('#start-bar').css( 'width', '360px' );
            $('#start-btn')[ 0 ].onclick = null;

        }

    }

};

Landing.initCarousel = function () {

    clearInterval( this.slideInterval );
    this.slideInterval = setInterval( this.nextSlide.bind( this ), 6000 );

};

Landing.nav = function ( event ) {

    event.stopPropagation();
    event.preventDefault();

    var href = event.target.getAttribute('href');

    window.history.pushState( '', 'Title', Landing.href + href );

    this.handleRoute( href );

};

Landing.handleRoute = function ( href ) {

    href = href.replace( this.href, '' );

    switch ( href ) {

        case '/':

            this.showHomePage();
            break;

        case '/about':

            this.showAboutPage();
            break;

        case '/blog':

            this.showBlogPage();
            break;

    }

};

Landing.switchSlide = function ( id ) {

    this.initCarousel();

    if ( id === this.currentSlide ) return;

    var slideData = this.slides[ id ];

    var quoteBar = $('.content .quote-bar');
    var quoteTextDom = $('.content .quote-bar .quote .text');
    var quoteAuthorDom = $('.content .quote-bar .quote .author');

    var backgroundImage1 = $('.content #home .active');
    var backgroundImage2 = $( $('.content #home .bg')[ id ] );

    $('.content #switches-bar .item').removeClass( 'active' );
    $( $('.content #switches-bar .item')[ id ] ).addClass( 'active' );

    backgroundImage1.animate({
        opacity: 0
    }, 800 );

    backgroundImage2.animate({
        opacity: 1
    }, 800, function () {

    });

    backgroundImage1.removeClass( 'active' );
    backgroundImage2.addClass( 'active' );

    quoteBar.animate({
        opacity: 0,
    }, 200, function () {

        quoteTextDom.html( slideData.quote.text );
        quoteAuthorDom.html( slideData.quote.author );

        quoteBar.animate({
            opacity: 1,
        }, 200 );
    
    });

    this.currentSlide = id;

};

Landing.nextSlide = function () {

    if ( this.currentSlide > this.slides.length - 2 ) {

        this.currentSlide = -1;

    }

    this.switchSlide( this.currentSlide + 1 );

};

Landing.prevSlide = function () {

    if ( this.currentSlide === 0 ) {

        this.currentSlide = this.slides.length;

    }

    this.switchSlide( this.currentSlide - 1 );

};

Landing.showHomePage = function () {

    $('.header .menu a').removeClass( 'active' );
    $('.header .menu #home').addClass( 'active' );

    $('.content #home').show();

    $('.content #home').stop();
    $('.content #about').stop();
    $('.content #blog').stop();

    $('.content #home').animate({ opacity: 1 }, 200, function () {

        $('.content #blog').hide();
        $('.content #about').hide();

    } );

    $('.content #blog').animate({ opacity: 0 }, 200 );
    $('.content #about').animate({ opacity: 0 }, 200 );

};

Landing.showAboutPage = function () {

    $('.header .menu a').removeClass( 'active' );
    $('.header .menu #about').addClass( 'active' );

    $('.content #about').show();

    $('.content #home').stop();
    $('.content #about').stop();
    $('.content #blog').stop();

    $('.content #home').animate({ opacity: 0 }, 200 );
    $('.content #blog').animate({ opacity: 0 }, 200 );
    $('.content #about').animate({ opacity: 1 }, 200, function () {

        $('.content #blog').hide();
        $('.content #home').hide();

    } );

};

Landing.showBlogPage = function () {

    $('.header .menu a').removeClass( 'active' );
    $('.header .menu #blog').addClass( 'active' );

    $('.content #blog').show();

    $('.content #home').stop();
    $('.content #about').stop();
    $('.content #blog').stop();

    $('.content #home').animate({ opacity: 0 }, 200 );
    $('.content #blog').animate({ opacity: 1 }, 200, function () {

        $('.content #home').hide();
        $('.content #about').hide();

    } );
    $('.content #about').animate({ opacity: 0 }, 200 );

};

//

Landing.startExploring = function () {

    var block = $('.content #start-bar');
    var startBtn = $('.content #start-bar #start-btn');
    var qualityBar = $('.content #start-bar #quality-bar');

    block.addClass( 'close' );

    setTimeout( function () {

        startBtn.hide();
        qualityBar.show();

        block.removeClass( 'close' );

    }, 500 );

};

Landing.startGOT = function ( quality ) {

    // set quality

    switch ( quality ) {

        case 0:

            GOT.settings.resolution = 0.6;
            GOT.settings.postprocessing.on = false;
            break;

        case 1:

            GOT.settings.resolution = 0.85;
            GOT.settings.postprocessing.on = false;
            break;

        case 2:

            GOT.settings.resolution = 1;
            GOT.settings.postprocessing.on = false;
            break;

    }

    // stop slide changing interval
    clearInterval( this.slideInterval );

    // disable rightClick menu
    document.oncontextmenu = function () { return false; };

    // change screen
    var mainPage = $('#landing-page');

    mainPage.addClass( 'hide' );
    $(document.body).addClass( 'game-body' );

    setTimeout( function () {

        mainPage.hide();
        $('.preloader').show();
        GOT.setupScene();

    }, 1000 );

    //

    GOT.vent.on('appLoaded', function() {

        setTimeout(function() {

            $('#ui').velocity('fadeIn');

        });

        //

        window.addEventListener( 'resize', GOT.view.onWindowResize, false );
        document.addEventListener( 'click', GOT.view.onClick, false );

    });

};

//

Landing.openImageViewer = function ( contentId ) {

    this.currentImageViewerScreen = contentId;

    $('.image-viewer').css( 'display', 'block' );

    $('.image-viewer #image-block').animate({
        opacity: 0.4
    }, 200, function () {

        $('.image-viewer #image-block').css( 'background-image', 'url(img/screens/' + contentId + '.jpg)' );

        $('.image-viewer #image-block').animate({
            opacity: 1
        }, 200);

    });

    $('.image-viewer').animate({
        opacity: 1
    }, 250, function () {});

};

Landing.closeImageViewer = function () {

    $('.image-viewer').animate({
        opacity: 0
    }, 250, function () {

        $('.image-viewer').css( 'display', 'none' );

    });

};

Landing.nextImageInViewer = function () {

    if ( this.currentImageViewerScreen === $('.screenshot-bar .item').length - 1 ) {

        this.currentImageViewerScreen = 0;

    }

    this.openImageViewer( this.currentImageViewerScreen + 1 );

};

Landing.prevImageInViewer = function () {

    if ( this.currentImageViewerScreen === 0 ) {

        this.currentImageViewerScreen = $('.screenshot-bar .item').length;

    }

    this.openImageViewer( this.currentImageViewerScreen - 1 );

};

//

$(document).ready( Landing.init.bind( Landing ) );
Landing.preInit();


/*
 * GOT
 * @author: ohmed
 * setup GOT object
*/

var GOT = {};

GOT.vent = new Vent();


/*
 * GOT
 * @author: ohmed
*/

GOT.Settings = function () {

    window.DEBUG = 1;
    window.EDITOR_MODE = + localStorage.getItem( 'edit_mode' );

    //

    this.windowWidth = window.innerWidth;
    this.windowHeight = window.innerHeight;

    this.resolution = 1;

    this.postprocessing = {

        on:         true,
        FXAA:       true,
        SSAO:       false,
        onlyDepth:  false

    };

    this.world = {

        flora:          true,
        decorations:    true,
        buildings:      true,
        water:          true,
        terrain:        true

    };

    //

    this.showBuildingsPopups = true;

    //

    if ( EDITOR_MODE ) {

        this.showBuildingsPopups = false;

    }

};

GOT.Settings.prototype.init = function () {

    this.initGUI();

    GOT.view.effectFXAA.enabled = this.postprocessing.FXAA;
    GOT.view.effectSSAO.enabled = this.postprocessing.SSAO;
    GOT.view.depthPassPlugin.enabled = this.postprocessing.SSAO;

    if ( this.postprocessing.onlyDepth ) {

        GOT.view.effectShowTexture.enabled = true;
        GOT.view.depthPassPlugin.enabled = true;

        GOT.view.effectSSAO.enabled = false;
        GOT.view.effectFXAA.enabled = false;

    }

    GOT.view.composer.setLastPassToScreen();

};

GOT.Settings.prototype.initGUI = function () {

    var self = this;

    this.gui = new dat.GUI();

    var gfx, world, ui;

    //

    gfx = this.gui.addFolder( 'Rendering' );

    this.gui.resolution = gfx.add( this, 'resolution', 0.0, 1.0, 0.1 ).name( 'Rsolution' ).onChange( function () { 

        GOT.view.onWindowResize();

    });

    this.gui.postprocess = gfx.add( this.postprocessing, 'on' ).name( 'Postprocessing' );

    this.gui.fxaa = gfx.add( this.postprocessing, 'FXAA' ).name( 'FXAA' ).onChange( function ( value ) {

        GOT.view.effectFXAA.enabled = value;
        GOT.view.composer.setLastPassToScreen();

    });

    this.gui.ssao = gfx.add( this.postprocessing, 'SSAO' ).name( 'SSAO' ).onChange( function ( value ) {

        GOT.view.effectSSAO.enabled = value;
        GOT.view.depthPassPlugin.enabled = value;

        GOT.view.composer.setLastPassToScreen();

    });

    this.gui.onlyDepth = gfx.add( this.postprocessing, 'onlyDepth' ).name( 'Depth' ).onChange( function ( value ) {

        GOT.view.effectShowTexture.enabled = value;
        GOT.view.depthPassPlugin.enabled = value;

        GOT.view.effectSSAO.enabled = ( ! value ) ? self.postprocessing.SSAO : false;
        GOT.view.effectFXAA.enabled = ( ! value ) ? self.postprocessing.FXAA : false;

        GOT.view.composer.setLastPassToScreen();

    });

    //

    world = this.gui.addFolder( 'World' );

    this.gui.flora = world.add( this.world, 'flora' ).name( 'Flora' ).onChange( function ( value ) { 

        if ( value ) {

            GOT.landscape.flora.show();

        } else {

            GOT.landscape.flora.hide();

        }

    });

    this.gui.decorations = world.add( this.world, 'decorations' ).name( 'Decorations' ).onChange( function ( value ) { 

        if ( value ) {

            GOT.landscape.decorations.show();

        } else {

            GOT.landscape.decorations.hide();

        }

    });

    this.gui.buildings = world.add( this.world, 'buildings' ).name( 'Buildings' ).onChange( function ( value ) { 

        if ( value ) {

            GOT.landscape.buildings.show();

        } else {

            GOT.landscape.buildings.hide();

        }

    });

    this.gui.water = world.add( this.world, 'water' ).name( 'Water' ).onChange( function ( value ) { 

        if ( value ) {

            GOT.landscape.terrain.water.show();

        } else {

            GOT.landscape.terrain.water.hide();

        }

    });

    this.gui.terrain = world.add( this.world, 'terrain' ).name( 'Terrain' ).onChange( function ( value ) { 

        if ( value ) {

            GOT.landscape.terrain.show();

        } else {

            GOT.landscape.terrain.hide();

        }

    });

    //

    ui = this.gui.addFolder( 'UI' );

    this.gui.buildingsPopups = ui.add( this, 'showBuildingsPopups' ).name( 'ShowBuildingsPopups' );

    //

    this.gui.domElement.parentNode.id = 'settings-gui';

};

GOT.Settings.prototype.togleGUI = function () {

    var element = this.gui.domElement.parentNode;

    if ( element.style['display'] === 'none' ) {

        element.style['display'] = 'block';

    } else {

        element.style['display'] = 'none';

    }

};

GOT.Settings.prototype.resetDefault = function () {

    // todo

};

GOT.settings = new GOT.Settings();


/*
 * GOT
 * @author: ohmed
 * GameObject base class [everything]
*/

function GameObject ( param ) {

    param = param || {};

    var objType = this.type;

    this.rotation = new NWE.Euler();
    this.position = new NWE.Vec3();
    this.scale = new NWE.Vec3( 1 );

    this.size = this.size || {
        x: 0,
        y: 0,
        z: 0
    };

    this.id = param.id || (GameObject.idCount ++);

    this.name = param.name || 0;
    this.subtype = param.subtype || '';

    this.state = param.state || 0;
    this.selected = false;

    this.info = false;

    this.effects = [];

    if ( param.position ) {
        this.position.x = param.position.x !== undefined ? Math.floor(param.position.x * 10) / 10 : 0;
        this.position.y = param.position.y !== undefined ? Math.floor(param.position.y * 10) / 10 : 0;
        this.position.z = param.position.z !== undefined ? Math.floor(param.position.z * 10) / 10 : 0;
    }

    if ( param.rotation ) {
        this.rotation.x = param.rotation.x !== undefined ? (Math.floor(param.rotation.x * 100) / 100) % (2 * Math.PI) : 0;
        this.rotation.y = param.rotation.y !== undefined ? (Math.floor(param.rotation.y * 100) / 100) % (2 * Math.PI) : 0;
        this.rotation.z = param.rotation.z !== undefined ? (Math.floor(param.rotation.z * 100) / 100) % (2 * Math.PI) : 0;
    }

    if ( param.scale ) {
        this.scale.x = param.scale.x !== undefined ? (Math.floor(param.scale.x * 100) / 100) % (2 * Math.PI) : 1;
        this.scale.y = param.scale.y !== undefined ? (Math.floor(param.scale.y * 100) / 100) % (2 * Math.PI) : 1;
        this.scale.z = param.scale.z !== undefined ? (Math.floor(param.scale.z * 100) / 100) % (2 * Math.PI) : 1;
    }

    if ( this.rotation.y < 0 ) {

        this.rotation.y = (2 * Math.PI + this.rotation.y) % (2 * Math.PI);

    }

};

GameObject.idCount = 0;

GameObject.prototype = {

    update: function () {

        // is reloaded

    },

    dispose: function () {

        var id = this.id;

        delete this.owner.buildings[id];
        delete this.owner.units[id];

    }

};


/*
 * GOT
 * @author: ohmed
 * Building base class
*/

function Building ( param, deferred ) {

    param = param || {};

    this.type = 'Building';
    GameObject.call( this, param );

    this.size = Building[ this.name ].size[ this.subtype ] || Building[ this.name ].size || param.size;
    this.subElements = [];

    if ( ! this.isFlora ) {

        this.instance = GOT.landscape.buildings.add( this, deferred );

    }

    this.preInit( deferred );

};

Building.prototype = Object.create( GameObject.prototype );

Building.prototype.preInit = function () {

    var self = this;

    //

};

Building.prototype.getShortInfo = function () {

    return this.shortInfo;

};

Building.prototype.remove = function () {

    var self = this;

    // remove building mesh
    view.buildings.remove( self );

    // remove addition meshes
    if ( self.meshAr ) {

        if ( meshAr.length ) {

            for ( var i = 0, il = self.meshAr.length; i < il; i ++ ) {

                view.remove( self.meshAr[ i ] );

            }

        } else {

            view.remove( self.meshAr );

        }

    }

};

//

Building.lastHovered = false;

Building.registerType = function ( param ) {

    var objClass = param.objClass || 'buildings';

    Building.list = Building.list || {};
    Building.list[ objClass ] = Building.list[ objClass ] || { length: 0 };

    Building.list[ objClass ][ param.name ] = {

        id: Building.list[ objClass ].length,
        name: param.name,
        model: param.model,
        parts: {}

    };

    Building.list[ objClass ].length ++;

};


/*
 * GOT
 * @author: ohmed
 * Decoration base class
*/

function Decoration ( param, deferred ) {

    param = param || {};

    this.type = 'Decoration';
    GameObject.call( this, param );

    this.instance = GOT.landscape.decorations.add( this, deferred );

};

Decoration.prototype = Object.create( GameObject.prototype );

//

Decoration.registerType = function ( param ) {

    Decoration.list = Decoration.list || { length: 0 };
    Decoration.list[ param.name ] = {

        id: Decoration.list.length,
        name: param.name

    };

    Decoration.list.length ++;

};


/* Rock decoration */

Decoration.Rock = function ( param, deferred ) {

    param = param || {};
    param.rotation.y = Math.floor( 255 * Math.random() );

    Decoration.call( this, param, deferred );

    this.init();

};

Decoration.Rock.prototype = Object.create( Decoration.prototype );

Decoration.Rock.prototype.init = function () {

    var self = this;

};

Decoration.Rock.size = { x: 8, y: 8, z: 8 };

Decoration.registerType( { name: 'Rock01', model: 'Rock01' } );
Decoration.registerType( { name: 'Rock02', model: 'Rock02' } );
Decoration.registerType( { name: 'Rock03', model: 'Rock03' } );


/* Ground decoration */

Decoration.Ground = function ( param, deferred ) {

    param = param || {};

    Decoration.call( this, param, deferred );

    this.init();

};

Decoration.Ground.prototype = Object.create( Decoration.prototype );

Decoration.Ground.prototype.init = function () {

    var self = this;

};

Decoration.Ground.size = { x: 8, y: 8, z: 8 };

Decoration.registerType( { name: 'Ground01', model: 'Ground01' } );
Decoration.registerType( { name: 'Ground02', model: 'Ground02' } );


/* GroundLabel decoration */

Decoration.GroundLabel = function ( param, deferred ) {

    param = param || {};

    Decoration.call( this, param, deferred );

    this.init();

};

Decoration.GroundLabel.prototype = Object.create( Decoration.prototype );

Decoration.GroundLabel.prototype.init = function () {

    var self = this;

};

Decoration.GroundLabel.prototype.setText = function ( text ) {

	// todo

};

Decoration.GroundLabel.prototype.stickGeometryToTerrain = function () {

	// todo

};

Decoration.GroundLabel.size = { x: 0, y: 0, z: 0 };


/* Town building */

Building.Town = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Town.prototype = Object.create( Building.prototype );

Building.Town.prototype.init = function () {

    var self = this;

    // GOT.view.picker.addObjectPickable( self );

};

Building.Town.size = {
    '01': {
        x: 13,
        y: 25,
        z: 13
    },
    '02': {
        x: 13,
        y: 20,
        z: 13
    },
    '03': {
        x: 16,
        y: 20,
        z: 16
    }
};

Building.registerType( { name: 'Town01', model: 'Town01' } );
Building.registerType( { name: 'Town02', model: 'Town02' } );
Building.registerType( { name: 'Town03', model: 'Town03' } );


/* Castle building */

Building.GreatNorthWall = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.GreatNorthWall.heraldyImg = 'img/heraldry/wall.png';
Building.GreatNorthWall.moviewPreview = 'img/movie-preview/wall.jpg';

Building.GreatNorthWall.prototype = Object.create( Building.prototype );

Building.GreatNorthWall.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.GreatNorthWall.prototype.shortInfo = (function() { 

    return [

        '<img class="pull-left" src="' + Building.GreatNorthWall.heraldyImg + '">',
        '<img class="pull-right" src="' + Building.GreatNorthWall.heraldyImg + '">',
        '<h3 class="info-popup-heading">The Wall</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.GreatNorthWall.moviewPreview + '"></div>',
        '<p>The Wall is a colossal fortification which stretches for 300 miles along the northern border of the Seven Kingdoms, defending the realm from the wildlings who live beyond. The Wall is reported to be over 700 feet tall and is made of solid ice. It was supposedly constructed using both magic and mundane means some eight millennia ago, in the aftermath of the Long Night to defend the realm against the White Walkers who apparently dwell in the far north, though they are now considered myths by most...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/The_Wall">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.GreatNorthWall.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.GreatNorthWall.size = { x: 900, y: 100, z: 40 };

Building.registerType( { name: 'GreatNorthWall', model: 'GreatNorthWall' } );


/* Winterfell building */

Building.Winterfell = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Winterfell.heraldyImg = 'img/heraldry/stark.webp';
Building.Winterfell.moviewPreview = 'img/movie-preview/winterfell.jpg';

Building.Winterfell.prototype = Object.create( Building.prototype );

Building.Winterfell.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.Winterfell.prototype.shortInfo = (function() { 

    return [

        '<img class="pull-left" src="' + Building.Winterfell.heraldyImg + '">',
        '<img class="pull-right" src="' + Building.Winterfell.heraldyImg + '">',
        '<h3 class="info-popup-heading">Winterfell</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.Winterfell.moviewPreview + '"></div>',
        '<p>Winterfell is the seat of House Stark. It is a large castle located at the center of the North, from where the head of House Stark rules over his people. It is the capital of the North under King Robb Stark. The castle is located alongside the Kingsroad as it makes its way from the Wall to the capital at King&#39;s Landing, more than a thousand miles to the south. It is situated atop hot springs which keep the castle warm even in the worst winters. Winding tombs below the castle contain the remains of Stark kings and lords and record the history of the ancient family. The castle has stood for millennia...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/Winterfell">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.Winterfell.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.Winterfell.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'Winterfell', model: 'Winterfell' } );


/* Braavos building */

Building.Braavos = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Braavos.heraldyImg = 'img/heraldry/braavos.png';
Building.Braavos.moviewPreview = 'img/movie-preview/braavos.jpg';

Building.Braavos.prototype = Object.create( Building.prototype );

Building.Braavos.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.Braavos.prototype.shortInfo = (function() { 

    return [

        '<img class="pull-left" src="' + Building.Braavos.heraldyImg + '">',
        '<img class="pull-right" src="' + Building.Braavos.heraldyImg + '">',
        '<h3 class="info-popup-heading">Braavos</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.Braavos.moviewPreview + '"></div>',
        '<p>Braavos is one of the Free Cities located on the continent of Essos. It lies east of Westeros, across the Narrow Sea. It is the northern-most, the richest, and arguably the most powerful of the Free Cities. The city spans hundreds of tiny islands connected by small stone bridges. As well as the city itself, the rulers of Braavos also control the surrounding lagoon and a strip of the coastline southwards towards Pentos...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/Braavos">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.Braavos.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};



Building.Braavos.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'Braavos', model: 'Braavos' } );


/* KingsLanding building */

Building.KingsLanding = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.KingsLanding.heraldyImg = 'img/heraldry/kings-landings.png';
Building.KingsLanding.moviewPreview = 'img/movie-preview/kings-landings.jpg';

Building.KingsLanding.prototype = Object.create( Building.prototype );

Building.KingsLanding.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.KingsLanding.prototype.shortInfo = (function() { 

    return [

        '<img class="pull-left" src="' + Building.KingsLanding.heraldyImg + '">',
        '<img class="pull-right" src="' + Building.KingsLanding.heraldyImg + '">',
        '<h3 class="info-popup-heading">King&#39;s Landing</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.KingsLanding.moviewPreview + '"></div>',
        '<p>King&#39;s Landing is the capital of the Seven Kingdoms. It is located on the east coast of Westeros in the Crownlands, overlooking Blackwater Bay. It is the site of the Iron Throne and the Red Keep, the seat of the King of the Andals and the First Men. The walled city is located on uplands just north of where the Blackwater Rush flows into Blackwater Bay. It enjoys a warm climate and life there is luxurious for those that can afford it, although it is not without its slums such as Flea Bottom. The city is overpopulated and dangerous at the best of times, despite being policed by a City Watch...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/King&#39;s_Landing">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.KingsLanding.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.KingsLanding.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'KingsLanding', model: 'KingsLanding' } );


/* Lys building */

Building.Lys = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Lys.heraldyImg = null;
Building.Lys.moviewPreview = 'img/movie-preview/lys.png';

Building.Lys.prototype = Object.create( Building.prototype );

Building.Lys.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.Lys.prototype.shortInfo = (function() { 

    return [

        Building.Lys.heraldyImg ? '<img class="pull-left" src="' + Building.Lys.heraldyImg + '">' : '',
        Building.Lys.heraldyImg ? '<img class="pull-right" src="' + Building.Lys.heraldyImg + '">' : '',
        '<h3 class="info-popup-heading">Lys</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.Lys.moviewPreview + '"></div>',
        '<p>Lys is one of the Free Cities to the east of Westeros. It is located far to the south of Pentos, southwest of Volantis and north of the Summer Islands. The city is actually located on an island separated from the mainland of Essos by narrow straits, though it has territorial possessions in the nearby regions of the mainland, east of Tyrosh and south of Myr. The city spans several islands...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/Lys">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.Lys.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.Lys.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'Lys', model: 'Lys' } );


/* Myr building */

Building.Myr = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Myr.heraldyImg = null;
Building.Myr.moviewPreview = 'img/movie-preview/myr.jpg';

Building.Myr.prototype = Object.create( Building.prototype );

Building.Myr.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.Myr.prototype.shortInfo = (function() { 

    return [

        Building.Myr.heraldyImg ? '<img class="pull-left" src="' + Building.Myr.heraldyImg + '">' : '',
        Building.Myr.heraldyImg ? '<img class="pull-right" src="' + Building.Myr.heraldyImg + '">' : '',
        '<h3 class="info-popup-heading">Myr</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.Myr.moviewPreview + '"></div>',
        '<p>Myr is one of the Free Cities located to the east of Westeros, on the coast of Essos. Myr is a major seaport located on a large body of water known as the Sea of Myrth, an inlet of the Narrow Sea. It is located south of Pentos and north of the Disputed Lands...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/Myr">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.Myr.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.Myr.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'Myr', model: 'Castle' } );


/* Norvos building */

Building.Norvos = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Norvos.heraldyImg = null;
Building.Norvos.moviewPreview = 'img/movie-preview/norvos.png';

Building.Norvos.prototype = Object.create( Building.prototype );

Building.Norvos.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.Norvos.prototype.shortInfo = (function() { 

    return [

        Building.Norvos.heraldyImg ? '<img class="pull-left" src="' + Building.Norvos.heraldyImg + '">' : '',
        Building.Norvos.heraldyImg ? '<img class="pull-right" src="' + Building.Norvos.heraldyImg + '">' : '',
        '<h3 class="info-popup-heading">Norvos</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.Norvos.moviewPreview + '"></div>',
        '<p>Norvos is one of the Free Cities, located to the east of Westeros. It lies in the interior of Essos, between Pentos and Qohor, on the Noyne, a tributary of the massive River Rhoyne. It is on the route leading from the Narrow Sea to the Dothraki sea, and as such pays tribute to passing Dothraki khalasars...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/Norvos">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.Norvos.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.Norvos.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'Norvos', model: 'Norvos' } );


/* Pentos building */

Building.Pentos = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Pentos.heraldyImg = null;
Building.Pentos.moviewPreview = 'img/movie-preview/pentos.png';

Building.Pentos.prototype = Object.create( Building.prototype );

Building.Pentos.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.Pentos.prototype.shortInfo = (function() { 

    return [

        Building.Pentos.heraldyImg ? '<img class="pull-left" src="' + Building.Pentos.heraldyImg + '">' : '',
        Building.Pentos.heraldyImg ? '<img class="pull-right" src="' + Building.Pentos.heraldyImg + '">' : '',
        '<h3 class="info-popup-heading">Pentos</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.Pentos.moviewPreview + '"></div>',
        '<p>Pentos is one of the Free Cities, located on the western coastline of Essos, across the Narrow Sea to the east of Westeros. It is a large, rich city...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/Pentos">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.Pentos.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.Pentos.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'Pentos', model: 'Pentos' } );


/* Pyke building */

Building.Pyke = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Pyke.heraldyImg = 'img/heraldry/pyke.png';
Building.Pyke.moviewPreview = 'img/movie-preview/pyke.jpg';

Building.Pyke.prototype = Object.create( Building.prototype );

Building.Pyke.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.Pyke.prototype.shortInfo = (function() { 

    return [

        '<img class="pull-left" src="' + Building.Pyke.heraldyImg + '">',
        '<img class="pull-right" src="' + Building.Pyke.heraldyImg + '">',
        '<h3 class="info-popup-heading">Pyke</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.Pyke.moviewPreview + '"></div>',
        '<p>Pyke is the stronghold and seat of House Greyjoy, located on the island of the same name, which is one of the seven major Iron Islands. The castle is the regional capital of the Iron Islands as a whole. Pyke is an ancient stronghold and the cliff it was built on has been eroded by the sea leaving the towers standing on stone stacks. The towers are connected by swaying rope bridges. The rocky moss covered stone at its base is not suitable for ships landing so traffic to the island flows through the nearby harbor town Lordsport...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/Pyke_(castle)">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.Pyke.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.Pyke.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'Pyke', model: 'Pyke' } );


/* Riverrun building */

Building.Riverrun = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Riverrun.heraldyImg = 'img/heraldry/tully.png';
Building.Riverrun.moviewPreview = 'img/movie-preview/riverrun.png';

Building.Riverrun.prototype = Object.create( Building.prototype );

Building.Riverrun.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.Riverrun.prototype.shortInfo = (function() { 

    return [

        '<img class="pull-left" src="' + Building.Riverrun.heraldyImg + '">',
        '<img class="pull-right" src="' + Building.Riverrun.heraldyImg + '">',
        '<h3 class="info-popup-heading">Riverrun</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.Riverrun.moviewPreview + '"></div>',
        '<p>Riverrun is the former seat of House Tully, who continue to hold it in defiance of the Iron Throne and its new lawful rulers, House Frey. It is a large castle located in the central-western part of the Riverlands. It sits at the point where the Red Fork of the Trident River is joined by its major tributary, the Tumblestone River flowing out of the west. In times of danger, sluice gates can be opened to flood a channel cut to the west of the castle, turning Riverrun into an island. Its walls rise sheer from the waters and its towers command the opposite shores, making assaulting it almost impossible without huge casualties...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/Riverrun">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.Riverrun.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.Riverrun.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'Riverrun', model: 'Riverrun' } );


/* TheTwins building */

Building.TheTwins = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.TheTwins.heraldyImg = 'img/heraldry/the-twins.webp';
Building.TheTwins.moviewPreview = 'img/movie-preview/the-twins.webp';

Building.TheTwins.prototype = Object.create( Building.prototype );

Building.TheTwins.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.TheTwins.prototype.shortInfo = (function() { 

    return [

        '<img class="pull-left" src="' + Building.TheTwins.heraldyImg + '">',
        '<img class="pull-right" src="' + Building.TheTwins.heraldyImg + '">',
        '<h3 class="info-popup-heading">The Twins</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.TheTwins.moviewPreview + '"></div>',
        '<p><b>The Twins</b>, sometimes known as <b>The Crossing</b>, is a castle in the Riverlands. It is the seat of House Frey, a vassal house of House Tully of Riverrun. It consists of two near-identical towers and a fortified bridge over the Green Fork of the River Trident...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/The_Twins">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.TheTwins.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.TheTwins.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'TheTwins', model: 'TheTwins' } );


/* Tyrosh building */

Building.Tyrosh = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Tyrosh.heraldyImg = null;
Building.Tyrosh.moviewPreview = 'img/movie-preview/tyrosh.png';

Building.Tyrosh.prototype = Object.create( Building.prototype );

Building.Tyrosh.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.Tyrosh.prototype.shortInfo = (function() { 

    return [

        Building.Tyrosh.heraldyImg ? '<img class="pull-left" src="' + Building.Tyrosh.heraldyImg + '">' : '',
        Building.Tyrosh.heraldyImg ? '<img class="pull-right" src="' + Building.Tyrosh.heraldyImg + '">' : '',
        '<h3 class="info-popup-heading">Tyrosh</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.Tyrosh.moviewPreview + '"></div>',
        '<p>Tyrosh is one of the Free Cities located to the east of Westeros. It is situated on an island off the southwestern coast of Essos, in the Narrow Sea. It is located at the eastern end of the Stepstones, an island chain that extends from Essos to Westeros, which according to legend used to be a land-bridge linking the two continents. Therefore, Tyrosh is the closest of the Free Cities to Westeros, located not far from Dorne and the Stormlands (fairly close to the island of Tarth)...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/Tyrosh">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.Tyrosh.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.Tyrosh.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'Tyrosh', model: 'Tyrosh' } );


/* Volantis building */

Building.Volantis = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Volantis.heraldyImg = null;
Building.Volantis.moviewPreview = 'img/movie-preview/volantis.png';

Building.Volantis.prototype = Object.create( Building.prototype );

Building.Volantis.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.Volantis.prototype.shortInfo = (function() { 

    return [

        Building.Volantis.heraldyImg ? '<img class="pull-left" src="' + Building.Volantis.heraldyImg + '">' : '',
        Building.Volantis.heraldyImg ? '<img class="pull-right" src="' + Building.Volantis.heraldyImg + '">' : '',
        '<h3 class="info-popup-heading">Volantis</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.Volantis.moviewPreview + '"></div>',
        '<p>Volantis is one of the Free Cities located east of Westeros. It is the southern-most and oldest of the Free Cities, located on the southern coast of Essos along the Summer Sea, at the mouth of the Rhoyne River. It was founded as a colony of Valyria many centuries ago. It is a great port...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/Volantis">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.Volantis.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.Volantis.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'Volantis', model: 'Castle' } );


/* WhiteHarbor building */

Building.WhiteHarbor = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.WhiteHarbor.heraldyImg = null;
Building.WhiteHarbor.moviewPreview = 'img/movie-preview/white-harbor.jpg';

Building.WhiteHarbor.prototype = Object.create( Building.prototype );

Building.WhiteHarbor.prototype.onClick = function () {

    if ( GOT.settings.showBuildingsPopups ) {

        GOT.vent.trigger('showBuildingPopup', this);

    }

};

Building.WhiteHarbor.prototype.shortInfo = (function() { 

    return [

        Building.WhiteHarbor.heraldyImg ? '<img class="pull-left" src="' + Building.WhiteHarbor.heraldyImg + '">' : '',
        Building.WhiteHarbor.heraldyImg ? '<img class="pull-right" src="' + Building.WhiteHarbor.heraldyImg + '">' : '',
        '<h3 class="info-popup-heading">White Harbor</h3>',
        '<br>',
        '<div><img class="moview-preview-thumb" src="' + Building.WhiteHarbor.moviewPreview + '"></div>',
        '<p>White Harbor is the only city in the North. It is one of the major cities of Westeros, located where the White Knife River flows into the Bite. It is the seat of House Manderly, a vassal house holding fealty to House Stark of Winterfell. White Harbor is the main seaport of the North and is one of only five settlements in Westeros large enough to be called a city, though it is the smallest of the five (the other four being, in decreasing order of size: King&#39;s Landing, Oldtown, Lannisport, and Gulltown)...</p>',
        '<p><a target="_blank" href="http://gameofthrones.wikia.com/wiki/White_Harbor">Read more at <b>Game Of Thrones Wiki</b></a></p>'

    ].join('');

}());

Building.WhiteHarbor.prototype.init = function () {

    var self = this;

    GOT.view.picker.addObjectPickable( self );

};

Building.WhiteHarbor.size = { x: 100, y: 100, z: 100 };

Building.registerType( { name: 'WhiteHarbor', model: 'WhiteHarbor' } );


/* flora Tree */

Building.Tree = function ( param, deferred ) {

    param = param || {};
    this.isFlora = true;

    Building.call( this, param, deferred );

    this.init( deferred );

};

Building.Tree.prototype = Object.create( Building.prototype );

Building.Tree.prototype.init = function ( deferred ) {

    var self = this;

    this.rotation.y = Math.PI * Math.random();
    this.scale.set( 0.5 * Math.random() + 0.8, 0.5 * Math.random() + 0.8, 0.5 * Math.random() + 0.8 );

    this.instance = GOT.landscape.flora.add( self, deferred );

};

Building.Tree.size = {
    '01': {
        x: 13,
        y: 25,
        z: 13
    },
    '02': {
        x: 13,
        y: 20,
        z: 13
    },
    '03': {
        x: 16,
        y: 20,
        z: 16
    }
};

Building.registerType({ objClass: 'flora', name: 'Tree01', model: 'Tree01' });
Building.registerType({ objClass: 'flora', name: 'Tree02', model: 'Tree02' });
Building.registerType({ objClass: 'flora', name: 'Tree03', model: 'Tree03' });


/* Bush building */

Building.Bush = function ( param, deferred ) {

    param = param || {};
    this.isFlora = true;

    Building.call( this, param, deferred );

    this.init( deferred );

};

Building.Bush.prototype = Object.create( Building.prototype );

Building.Bush.prototype.init = function ( deferred ) {

    var self = this;

    if ( this.subtype !== '02' ) {

        this.rotation.y = Math.PI * Math.random();
        this.scale.set( 0.5 * Math.random() + 0.8, 0.5 * Math.random() + 0.8, 0.5 * Math.random() + 0.8 );

    } else {

        this.rotation.y = -1.3 + 0.5 * ( Math.random() - 0.5 );
        this.scale.set( 1 * Math.random() + 0.3, 1 * Math.random() + 0.3, 1 * Math.random() + 0.3 );

    }

    this.instance = GOT.landscape.flora.add( self, deferred );

};

Building.Bush.size = {
    '01': { x: 4, y: 14, z: 4 },
    '02': { x: 8, y: 17, z: 8 },
    '03': { x: 5, y: 20, z: 5 }
};

Building.Bush.maxDensity = {
    '01': 3,
    '02': 15,
    '03': 15
};

Building.registerType( { objClass: 'flora', name: 'Bush01', model: 'Bush01' } );
Building.registerType( { objClass: 'flora', name: 'Bush02', model: 'Bush02' } );
Building.registerType( { objClass: 'flora', name: 'Bush03', model: 'Bush03' } );


/* Castle building */

Building.Castle = function ( param, deferred ) {

    Building.call( this, param, deferred );

    param = param || {};

    this.init();

};

Building.Castle.prototype = Object.create( Building.prototype );

Building.Castle.prototype.init = function () {

    var self = this;

    // ..

};

Building.Castle.size = { x: 36, y: 16, z: 36 };

Building.registerType( { name: 'Castle', model: 'Castle' } );


/*
 * GOT
 * @author: ohmed
 * APP core
*/

GOT.setupScene = function () {

    // clock

    GOT.clock = new NWE.Clock();

    // renderer

    GOT.view.renderer = new NWE.gfx.WebGLRenderer({ canvas: document.querySelector('#viewport'), antialias: false });

    GOT.view.renderer.addPrePlugin( new NWE.gfx.ShadowMapPlugin() );
    GOT.view.renderer.shadowMapAutouUpdate = true;
    GOT.view.renderer.shadowMapEnabled = true;

    // create scene

    GOT.view.scene = new NWE.gfx.Scene();

    // add camera

    GOT.view.camera = new NWE.gfx.PerspectiveCamera( 40, GOT.settings.windowWidth / GOT.settings.windowHeight, 1, 5300 );
    GOT.view.camera.position = new NWE.Vec3( 0, 4900, 0, function () { GOT.vent.trigger('mapMove'); } );
    GOT.view.camera.lookAt(
        new NWE.Vec3(
                GOT.view.camera.position.x - 120 * Math.sin( GOT.view.rot ),
                0.4 * GOT.view.camera.position.y - 20,
                GOT.view.camera.position.z - 120 * Math.cos( GOT.view.rot )
            ) 
    );
    GOT.view.scene.add( GOT.view.camera );

    // composer

    NWE.gfx.EffectComposer.init();

    var renderTargetParametersRGBA = { minFilter: NWE.gfx.Const.LinearFilter, magFilter: NWE.gfx.Const.LinearFilter, format: NWE.gfx.Const.RGBAFormat };
    var depthTarget = new NWE.gfx.WebGLRenderTarget( GOT.settings.resolution * GOT.settings.windowWidth, GOT.settings.resolution * GOT.settings.windowHeight, renderTargetParametersRGBA );

    GOT.view.composer = new NWE.gfx.EffectComposer( GOT.view.renderer );
    GOT.view.composer.setSize( GOT.settings.resolution * GOT.settings.windowWidth, GOT.settings.resolution * GOT.settings.windowHeight );

    GOT.view.renderPass = new NWE.gfx.RenderPass( GOT.view.scene, GOT.view.camera );
    GOT.view.effectFXAA = new NWE.gfx.ShaderPass( new NWE.gfx.ShaderLib.FXAAShader() );
    GOT.view.effectSSAO = new NWE.gfx.ShaderPass( new NWE.gfx.ShaderLib.SSAOShader() );

    GOT.view.effectShowTexture = new NWE.gfx.TexturePass( depthTarget, 1 );
    GOT.view.effectShowTexture.enabled = false;

    //

    GOT.view.effectSSAO.uniforms[ 'tDepth' ].value = depthTarget;
    GOT.view.effectSSAO.uniforms[ 'size' ].value.set( GOT.settings.resolution * GOT.settings.windowWidth, GOT.settings.resolution * GOT.settings.windowHeight );
    GOT.view.effectSSAO.uniforms[ 'cameraNear' ].value = GOT.view.camera.near;
    GOT.view.effectSSAO.uniforms[ 'cameraFar' ].value = GOT.view.camera.far;

    // GOT.view.effectSSAO.uniforms[ 'fogNear' ].value = GOT.view.scene.fog.near;
    // GOT.view.effectSSAO.uniforms[ 'fogFar' ].value = GOT.view.scene.fog.far;
    // GOT.view.effectSSAO.uniforms[ 'fogEnabled' ].value = 1;
    // GOT.view.effectSSAO.uniforms[ 'aoClamp' ].value = 0.5;

    GOT.view.effectSSAO.material.defines[ 'RGBA_DEPTH' ] = true;
    GOT.view.effectSSAO.material.defines[ 'ONLY_AO_COLOR' ] = '1.0, 0.7, 0.5';

    // depth pass

    GOT.view.depthPassPlugin = new NWE.gfx.DepthPassPlugin();
    GOT.view.depthPassPlugin.renderTarget = depthTarget;
    GOT.view.depthPassPlugin.enabled = false;

    GOT.view.renderer.addPrePlugin( GOT.view.depthPassPlugin );

    //

    GOT.view.composer.addPass( GOT.view.renderPass );
    GOT.view.composer.addPass( GOT.view.effectSSAO );
    GOT.view.composer.addPass( GOT.view.effectFXAA );
    GOT.view.composer.addPass( GOT.view.effectShowTexture );

    GOT.view.composer.setLastPassToScreen();

    // add light

    // ambient light

    GOT.view.scene.add( new NWE.gfx.AmbientLight( 0xdddddd ) );

    // sun

    GOT.view.sun = new NWE.gfx.DirectionalLight( 0xffffff, 1 );
    GOT.view.sun.target.position.set( 220, 0, 220 );

    GOT.view.sun.castShadow = true;

    GOT.view.sun.shadowCameraNear = 1;
    GOT.view.sun.shadowCameraFar = 5000;
    GOT.view.sun.shadowCameraFov = 50;

    GOT.view.sun.shadowCameraLeft = - 6000;
    GOT.view.sun.shadowCameraRight = 6000;
    GOT.view.sun.shadowCameraTop = 6000;
    GOT.view.sun.shadowCameraBottom = - 6000;

    GOT.view.sun.shadowBias = 0.0001;
    GOT.view.sun.shadowDarkness = 0.25;

    GOT.view.sun.shadowMapWidth = 2048;
    GOT.view.sun.shadowMapHeight = 2048;

    GOT.view.scene.add( GOT.view.sun );

    //

    GOT.Loader.load( function () {

        GOT.controls.init();

        GOT.landscape = new GOT.Landscape();
        GOT.landscape.init();

        GOT.landscape.parseLandscapeData( 'got' );

        GOT.initRender();

        GOT.vent.trigger( 'appLoaded' );

    } );

    // setup picker

    GOT.view.picker = new Picker();

    // init settings

    GOT.settings.init();

};

GOT.initRender = function () {

    var renderer = GOT.view.renderer;
    var resolution = GOT.settings.resolution;

    renderer.viewport.setSize( resolution * GOT.settings.windowWidth, resolution * GOT.settings.windowHeight );

    renderer.domElement.style['z-index'] = 2;
    renderer.domElement.style.zIndex = 2;

    GOT.render();

};


/*
 * GOT
 * @author: ohmed
 * view
*/

GOT.view = {

    rot: 0,
    globalTime: new NWE.Clock(),
    moveTime: new NWE.Clock()

};

GOT.view.onWindowResize = function () {

    GOT.settings.windowWidth = window.innerWidth;
    GOT.settings.windowHeight = window.innerHeight;

    var resolution = GOT.settings.resolution;

    var SCREEN_WIDTH = resolution * window.innerWidth;
    var SCREEN_HEIGHT = resolution * window.innerHeight;

    GOT.view.camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
    GOT.view.camera.updateProjectionMatrix();

    GOT.view.renderer.viewport.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
    GOT.view.composer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

};

GOT.view.onClick = function ( event ) {

    var mouseX = event.clientX;
    var mouseY = event.clientY;

    // var landscapePoint = GOT.view.picker.pick({
    //                         x: mouseX,
    //                         y: mouseY
    //                     }, GOT.view.camera, 'landscape').point;

    // var cube = new NWE.gfx.Mesh( new NWE.gfx.CubeGeometry( 10, 10, 10 ), new NWE.gfx.MeshBasicMaterial({ color: 0xff0000 }) );
    // cube.position = landscapePoint;
    // cube.position.y += 10;
    // GOT.view.scene.add( cube );

    // console.log( landscapePoint );

    GOT.view.picker.pick({
                            x: mouseX,
                            y: mouseY
                        }, GOT.view.camera);

};

GOT.view.add = function ( object ) {

    GOT.view.scene.add( object );

};

GOT.view.remove = function ( mesh, matrialRemove ) {

    if ( ! mesh ) {

        return;

    }

    // remove mesh from scene
    var scene = mesh.parent;
    if ( ! scene ) return;

    scene.remove( mesh );

    setTimeout( function () {

        // remove geometry

        // if ( !isMOBILE ) {  // spike for mobile [ chrome crushes when dispose geo [from units mng update] ]

            mesh.geometry.dispose();

        // }

        // remove material
        if ( matrialRemove !== false ) {

            if ( !mesh.material ) {

                return;

            }

            mesh.material.dispose();

        }

        // remove mesh data
        mesh.remove();

        mesh = null;

    }, 500 );

};


/*
 * GOT
 * @author: ohmed
 * UI handlers
*/

GOT.UI = {

    Controls: {},
    Menu: {}

};


/*
 * GOT
 * @author: ohmed
 * Map loading
*/

// var HOST = window.location.origin;

GOT.map = (function () {

    function load ( path, id, fn ) {

        var img = new Image();

        img.onload = function () {

            fn( img );

        };

        img.src = path + '/' + id + '.png';

    }

    this.loadMapping = function ( id, fn ) {

        load( 'mappings', id, fn );

    };

    this.loadPreview = function( id, fn ) {

        load( 'previews', id, fn );

    };

    return this;

}) ();


/*
 * GOT
 * @author: ohmed
 * Loader
*/

GOT.Loader = function () {

    this.loader = new NWE.PackLoader();

};

GOT.Loader.prototype.load = function ( callback ) {

    var self = this;

    var res = 'resources/packs/wd1.zip';
    // var res = 'https://s3-eu-west-1.amazonaws.com/nwg-data/data.pack';

    self.loader.load( res, function ( pack ) {

        GOT.ResourceMng = pack;

        ( callback && callback() );

    });

};

GOT.Loader = new GOT.Loader();


/*
 * GOT
 * @author: ohmed
 * Controls
*/

GOT.controls = {

    mapDraggingEnabled: true,

    sideSpeed: 0,
    forwardSpeed: 0,
    zoomSpeed: 0,
    rotSpeed: 0,

    maxMoveSpeed: 4,
    maxZoomSpeed: 70,
    maxRotSpeed: 0.1,

    activeMovmentForward: false,
    activeMovmentSide: false,

    fInterval: false,
    sInterval: false,
    zInterval: false,
    rInterval: false,

    lookAtVector: new NWE.Vec3(),

    moveForward: function ( dirrection ) { // direction = 1 | -1

        var controls = GOT.controls;

        if ( controls.activeMovmentForward ) return;

        clearInterval( controls.fInterval );
        controls.activeMovmentForward = true;

        controls.fInterval = setInterval( function () {

            var delta = ( dirrection * controls.maxMoveSpeed ) - controls.forwardSpeed;

            controls.forwardSpeed += delta / 5;
            if ( Math.abs( delta ) < 0.4 ) clearInterval( controls.fInterval );

        }, 40 );

    },

    stopForward: function ( stopSpeed ) {

        var controls = GOT.controls;

        stopSpeed = stopSpeed || 5;

        if ( ! controls.activeMovmentForward ) return;

        clearInterval( controls.fInterval );
        controls.activeMovmentForward = false;

        controls.fInterval = setInterval( function () {

            controls.forwardSpeed -= controls.forwardSpeed / stopSpeed;
            if ( Math.abs( controls.forwardSpeed - 0 ) < 0.2 ) {

                clearInterval( controls.fInterval );
                controls.forwardSpeed = 0;

            }

        }, 40 );

    },

    moveSide: function ( dirrection ) { // direction = 1 | -1

        var controls = GOT.controls;

        if ( controls.activeMovmentSide ) return;

        clearInterval( controls.sInterval );
        controls.activeMovmentSide = true;

        controls.sInterval = setInterval( function () {

            var delta = ( dirrection * controls.maxMoveSpeed ) - controls.sideSpeed;

            controls.sideSpeed += delta / 5;
            if ( Math.abs( delta ) < 0.2 ) clearInterval( controls.sInterval );

        }, 40 );

    },

    stopSide: function ( stopSpeed ) {

        var controls = GOT.controls;

        stopSpeed = stopSpeed || 5;

        if ( ! controls.activeMovmentSide ) return;

        clearInterval( controls.sInterval );
        controls.activeMovmentSide = false;

        controls.sInterval = setInterval( function () {

            controls.sideSpeed -= controls.sideSpeed / stopSpeed;
            if ( Math.abs( controls.sideSpeed - 0 ) < 0.4 ) {

                clearInterval( controls.sInterval );
                controls.sideSpeed = 0;

            }

        }, 40 );

    },

    zoom: function ( deltaZoom, forseZoomSpeed ) {

        var controls = GOT.controls;
        var view = GOT.view;

        forseZoomSpeed = forseZoomSpeed || 1;

        if ( view.camera.position.y + forseZoomSpeed * Math.sign( deltaZoom ) * 80 > 4900 ) return;
        if ( view.camera.position.y + forseZoomSpeed * Math.sign( deltaZoom ) * 80 < 80 ) return;

        view.camera.oldYPosition = view.camera.position.y;
        view.camera.position.y += forseZoomSpeed * Math.sign( deltaZoom ) * 80;

        controls.lookAtVector.set( view.camera.position.x - 100 * Math.sin( view.rot ), 0.4 * view.camera.position.y + 20, view.camera.position.z - 100 * Math.cos( view.rot ) );
        view.camera.lookAt( controls.lookAtVector );

    },

    rotate: function ( deltaRot ) {

        var controls = GOT.controls;
        
        controls.rotSpeed += deltaRot / 90;

        clearInterval( controls.rInterval );

        controls.rInterval = setInterval( function () {

            var delta = deltaRot - controls.rotSpeed;

            controls.rotSpeed += delta / 1.5;

            if ( Math.abs(controls.rotSpeed) > controls.maxRotSpeed ) {

                controls.rotSpeed = (controls.maxRotSpeed - 0.01) * ( Math.abs(controls.rotSpeed) /controls.rotSpeed );
                delta = 0;

            }

            if ( Math.abs( delta ) < 0.01 ) {

                if ( deltaRot !== 0 ) {

                    controls.rotate(0);

                } else {

                    controls.rotSpeed = 0;
                    clearInterval( controls.rInterval );

                }

            }

        }, 40 );

    },

    init: function () {

        GOT.controls.mouse = new GOT.MouseControl();
        GOT.controls.keyboard = new GOT.KeyboardControl();

    }

};

//

GOT.MouseControl = function () {

    var self = this;

    self.state = '';

    self.setEvents();

};

GOT.MouseControl.prototype.setEvents = function () {

    var self = this;

    var mouseDownCoord = {
        x: 0,
        y: 0
    };

    var mouseDown = 0;

    var lastMouseMove = Date.now();

    self.globalEvents = {};

    /* ------------------------------------------------------------------------------------- */

    var mouseWheelCallback = function(event) {

        var delta = 0;

        delta = event.deltaY / 3;

        GOT.controls.zoom( - 5 * delta );

    };

    $(document).mousewheel(mouseWheelCallback);

};

//

GOT.KeyboardControl = function () {

    var self = this;
    var controls = GOT.controls;

    self.CTRL = 0;
    self.CMD = 0;
    self.SHIFT = 0;

    self.moveKeysPressed = 0;

    self.keys = {

        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAUSE: 19,
        CAPS_LOCK: 20,
        ESCAPE: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT_ARROW: 37,
        UP_ARROW: 38,
        RIGHT_ARROW: 39,
        DOWN_ARROW: 40,
        INSERT: 45,
        DELETE: 46,
        KEY_0: 48,
        KEY_1: 49,
        KEY_2: 50,
        KEY_3: 51,
        KEY_4: 52,
        KEY_5: 53,
        KEY_6: 54,
        KEY_7: 55,
        KEY_8: 56,
        KEY_9: 57,
        KEY_A: 65,
        KEY_B: 66,
        KEY_C: 67,
        KEY_D: 68,
        KEY_E: 69,
        KEY_F: 70,
        KEY_G: 71,
        KEY_H: 72,
        KEY_I: 73,
        KEY_J: 74,
        KEY_K: 75,
        KEY_L: 76,
        KEY_M: 77,
        KEY_N: 78,
        KEY_O: 79,
        KEY_P: 80,
        KEY_Q: 81,
        KEY_R: 82,
        KEY_S: 83,
        KEY_T: 84,
        KEY_U: 85,
        KEY_V: 86,
        KEY_W: 87,
        KEY_X: 88,
        KEY_Y: 89,
        KEY_Z: 90,
        LEFT_META: 91,
        RIGHT_META: 92,
        SELECT: 93,
        NUMPAD_0: 96,
        NUMPAD_1: 97,
        NUMPAD_2: 98,
        NUMPAD_3: 99,
        NUMPAD_4: 100,
        NUMPAD_5: 101,
        NUMPAD_6: 102,
        NUMPAD_7: 103,
        NUMPAD_8: 104,
        NUMPAD_9: 105,
        MULTIPLY: 106,
        ADD: 107,
        SUBTRACT: 109,
        DECIMAL: 110,
        DIVIDE: 111,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        NUM_LOCK: 144,
        SCROLL_LOCK: 145,
        SEMICOLON: 186,
        EQUALS: 187,
        COMMA: 188,
        DASH: 189,
        PERIOD: 190,
        FORWARD_SLASH: 191,
        GRAVE_ACCENT: 192,
        OPEN_BRACKET: 219,
        BACK_SLASH: 220,
        CLOSE_BRACKET: 221,
        SINGLE_QUOTE: 222,

        CMD: 91

    };

    self.pressedKeys = [];

    self.movingKeysPressed = function () {

        return ( self.pressedKeys[self.keys.UP_ARROW] || self.pressedKeys[self.keys.KEY_W] ||
                 self.pressedKeys[self.keys.LEFT_ARROW] || self.pressedKeys[self.keys.KEY_A] ||
                 self.pressedKeys[self.keys.DOWN_ARROW] || self.pressedKeys[self.keys.KEY_S] ||
                 self.pressedKeys[self.keys.RIGHT_ARROW] || self.pressedKeys[self.keys.KEY_D] );

    };

    $(document).keydown(function ( event ) {

        event.stopPropagation();
        var key = event.keyCode;

        if ( self.pressedKeys[key] ) return;

        switch ( key ) {

            case self.keys.KEY_P:

                GOT.settings.togleGUI();
                break;

            case self.keys.UP_ARROW:
            case self.keys.KEY_W:

                controls.moveForward( -1 );

                break;

            case self.keys.LEFT_ARROW:
            case self.keys.KEY_A:

                controls.moveSide( -1 );

                break;

            case self.keys.DOWN_ARROW:
            case self.keys.KEY_S:

                controls.moveForward( 1 );

                break;

            case self.keys.RIGHT_ARROW:
            case self.keys.KEY_D:

                controls.moveSide( 1 );

                break;

            case self.keys.CTRL:

                self.CTRL = 1;

                break;

            case self.keys.CMD:

                self.CMD = 1;

                break;

            case self.keys.SHIFT:

                self.SHIFT = 1;

                break;

            case self.keys.KEY_Z:

                // Gameplay.toggleAllMenus();

                break;

        }

        self.pressedKeys[key] = true;

    });

    $(document).keyup(function ( event ) {

        event.stopPropagation();
        var key = event.keyCode;
        self.pressedKeys[key] = false;

        switch ( key ) {

            case self.keys.UP_ARROW:
            case self.keys.KEY_W:

                controls.stopForward();

                break;

            case self.keys.LEFT_ARROW:
            case self.keys.KEY_A:

                controls.stopSide();

                break;

            case self.keys.DOWN_ARROW:
            case self.keys.KEY_S:

                controls.stopForward();

                break;

            case self.keys.RIGHT_ARROW:
            case self.keys.KEY_D:

                controls.stopSide();

                break;

            case self.keys.CTRL:

                self.CTRL = 0;

                break;

            case self.keys.CMD:

                self.CMD = 0;

                break;

            case self.keys.SHIFT:

                self.SHIFT = 0;

                break;

        }

        self.moveKeysPressed = Math.max( self.moveKeysPressed, 0 );

    });

};


(function () {

    var mousedown = false;
    var position;

    function onMouseDown ( event ) {

        if ( ! GOT.controls.mapDraggingEnabled ) return;

        if ( EDITOR_MODE && GOT.editor.marker.enabled ) return;

        event.preventDefault();

        mousedown = true;

        position = {

            x: event.clientX,
            y: event.clientY

        };

        $('body').addClass('cursor-grab');

    };

    function onMouseMove ( event ) {

        if ( ! GOT.controls.mapDraggingEnabled ) return;

        if ( EDITOR_MODE && GOT.editor.marker.enabled ) return;

        if ( ! mousedown ) return;

        var deltaX = event.clientX - position.x;
        var deltaY = event.clientY - position.y;

        var delta = GOT.view.picker.deltaScreenToWorld( 0, 0, deltaX, deltaY );

        var k = 0;
        var steps = 10;

        var interval = setInterval( function () {

            GOT.view.updateCameraPosition( delta.dx / steps, delta.dz / steps );

            k ++;

            if ( k === steps ) {

                clearInterval( interval );

            }

        }, 20);

        position = {

            x: event.clientX,
            y: event.clientY

        };

        $('body').addClass('cursor-grabbing');

    };

    function onMouseUp () {

        if ( ! GOT.controls.mapDraggingEnabled ) return;

        mousedown = false;

        $('body').removeClass('cursor-grab cursor-grabbing');

    };

    function init () {

        $('body').on( 'mousedown', onMouseDown );
        $('body').on( 'mousemove', onMouseMove );
        $('body').on( 'mouseup', onMouseUp );

    };

    GOT.vent.on('appLoaded', init);

} ());


/*
 * GOT
 * @author: ohmed
 * Animation handler
*/

var AnimationHandler = function ( target ) {

    var self = this;

    var currentFrame, nextFrame,

        parentClass,
        timeout, frameChangeInterval;

    if ( target.type === 'Unit' ) {

        parentClass = GOT.landscape.units;

    } else if ( target.type === 'Building' || target.type === 'SubBuilding' ) {

        parentClass = GOT.landscape.buildings;

    } else {

        console.log( 'Animation handler error, unknown target type.' );
        return;

    }

    //

    this.loop = false;
    this.duration = 0;
    this.status = 'stopped';

    this.set = function ( animationName, duration, loop, revers ) {

        var animation = target.animFrames[ animationName ],
            dF, ddF;

        if ( !animation ) {

            console.log( 'Animation not found.' );
            return;

        }

        self.duration   = duration = duration || self.duration;
        self.loop       = loop = loop || self.loop;

        currentFrame = ( !revers ) ? animation.start : animation.end;
        nextFrame = ( !revers ) ? animation.end : animation.start;

        dF = nextFrame - currentFrame;
        ddF = dF / Math.abs( dF );

        clearTimeout(timeout);
        clearInterval(frameChangeInterval);

        if ( nextFrame === currentFrame ) {

            changeFrame(0, 1);
            return;

        }

        frameChangeInterval = setInterval( function ( df, dur ) {

            changeFrame(df, dur);

        }, duration / Math.abs( dF ) , ddF, duration / Math.abs( dF ) );

        changeFrame(ddF, duration / Math.abs( dF ));

        if ( !loop ) {

            timeout = setTimeout( function () {

                self.stop.call(self);

            }, duration );

        } else {

            timeout = setTimeout( function () {

                self.set.call(self, animationName, duration, self.loop, !revers);

            }, duration );

        }

        self.status = 'playing';

    };

    this.pause = function () {

        // todo

    };

    this.resume = function () {

        // todo

    };

    this.stop = function () {

        self.status = 'stopped';
        self.loop = false;

        clearInterval(timeout);

        parentClass.stopAnimation.call(parentClass, target);

    };

    this.showPart = function ( partName ) {

        parentClass.changeVisibility(target, partName, 'show');

    };

    this.hidePart = function ( partName ) {

        parentClass.changeVisibility(target, partName, 'hide');

    };

    this.hideAll = function () {

        parentClass.hideAll(target);

    };

    this.setFrame = function ( frame ) {

        parentClass.setAnimation(target, frame, frame, 0);

    };

    function changeFrame ( deltaFrame, duration ) {

        parentClass.setAnimation(target, currentFrame, currentFrame + deltaFrame, duration);
        currentFrame += deltaFrame;

        if ( currentFrame === nextFrame ) {

            clearInterval(frameChangeInterval);
            self.status = 'stopped';

        }

    };

    AnimationHandler.addToList( target );

};

AnimationHandler.list = [];

AnimationHandler.addToList = function ( object ) {

    // todo, will be changed

    this.list.push( object );

};

AnimationHandler.removeFromList = function ( ) {

    // todo

};


/*
 * GOT
 * @author: ohmed
 * Flora [visual meshes] handling
*/

GOT.FloraManager = function ( params ) {

    params = params || {};

    this.landscape = params.landscape || false;

    this.texturesID = {
        'tree-leaves01':    0,
        'bush01':           1,
        'bush02':           2
    };

    this.blocksCount = params.blocksCount || 9 * 25;
    this.blocks = [];

    this.textureAtlas = GOT.ResourceMng.getTexture( 'flora' );

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        var group = new NWE.fw.StaticGroup();

        group.material.uniforms.ambient.value.setRGB( 0.95, 0.95, 0.95 );
        group.material.transparent = true;
        group.material.defines[ 'ALPHATEST' ] = '1.0';
        group.material.uniforms[ 'alphaTest' ].value = 0.4;
        group.setAtlasTexture( this.textureAtlas, 4 );

        this.blocks.push( group );

    }

    this.globalSG = new NWE.fw.StaticGroup();
    this.globalSG.material.uniforms.ambient.value.setRGB( 0.95, 0.95, 0.95 );
    this.globalSG.material.transparent = true;
    this.globalSG.material.defines[ 'ALPHATEST' ] = '1.0';
    this.globalSG.material.uniforms[ 'alphaTest' ].value = 0.4;
    this.globalSG.setAtlasTexture( this.textureAtlas, 4 );
    this.globalSG.visible = false;

};

GOT.FloraManager.prototype.add = function ( plant ) {

    var terrainSize = this.landscape.terrain.gridSize;

    // move position coords to +/+ quater
    var x = plant.position.x + 3 * terrainSize / 2;
    var z = plant.position.z + 3 * terrainSize / 2;

    var blockSize = GOT.landscape.mapSize / 15;

    var blockID = Math.floor( x / blockSize ) + 15 * Math.floor( z / blockSize );
    var block = this.blocks[ blockID ];

    var part = '_lod1';
    if ( plant.subtype === '03' || plant.name === 'Bush' ) part = '';

    var instance = block.addInstance({
        type:       plant.name + plant.subtype,
        position:   new NWE.Vec3( plant.position.x, plant.position.y, plant.position.z ),
        rotation:   plant.rotation,
        scale:      plant.scale / 2.5,
        model:      GOT.ResourceMng.getRawGeometry( plant.name + plant.subtype ),
        texturesID: this.texturesID
    });

    this.globalSG.addInstance({
        type:       plant.name + plant.subtype,
        position:   new NWE.Vec3( plant.position.x, plant.position.y, plant.position.z ),
        rotation:   plant.rotation,
        scale:      plant.scale / 2.5,
        model:      GOT.ResourceMng.getRawGeometry( plant.name + plant.subtype + part ),
        texturesID: this.texturesID
    });

    return instance;

};

GOT.FloraManager.prototype.deferredUpdate = function () {

    var mapSize = GOT.landscape.mapSize;
    var blockSize = GOT.landscape.mapSize / 15;

    var shader = new NWE.gfx.ShaderLib.DepthRGBA();

    var material = new NWE.gfx.ShaderMaterial( {
        defines: shader.defines,
        uniforms: shader.uniforms,
        attributes: shader.attributes,
        varyings: shader.varyings,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
    } );

    material.uniforms['objectTexture'].value = this.textureAtlas;

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        if ( this.blocks[ i ].instances.length ) {

            this.blocks[ i ].updateGeometry();

            this.blocks[ i ].getInternal('mesh').geometry.boundingSphere = null;
            this.blocks[ i ].getInternal('mesh').geometry.boundingBox = new NWE.Box3();
            this.blocks[ i ].getInternal('mesh').geometry.boundingBox.min.set( blockSize / 2 + blockSize * ( i % 15 ) - mapSize / 2 - blockSize / 2, -10, blockSize / 2 + blockSize * Math.floor( i / 15 ) - mapSize / 2 - blockSize / 2 );
            this.blocks[ i ].getInternal('mesh').geometry.boundingBox.max.set( blockSize / 2 + blockSize * ( i % 15 ) - mapSize / 2 + blockSize / 2,  10, blockSize / 2 + blockSize * Math.floor( i / 15 ) - mapSize / 2 + blockSize / 2 );

            this.blocks[ i ].getInternal('mesh').customDepthMaterial = material;

        }

    }

    this.globalSG.updateGeometry();
    this.globalSG.getInternal('mesh').customDepthMaterial = material;

};

GOT.FloraManager.prototype.goToLowDetailed = function () {

    this.globalSG.visible = true;

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        this.blocks[ i ].visible = false;

    }

};

GOT.FloraManager.prototype.goToHighDetailed = function () {

    this.globalSG.visible = false;

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        this.blocks[ i ].visible = true;

    }

};

GOT.FloraManager.prototype.update = function () {

    // var i, il, 
    //     windOffset, windDirr;

    // for ( i = 0, il = blocks.length; i < il; i ++ ) {

    //     // update wind [will be changed]
    //     windOffset = blocks[ i ].mesh.material.uniforms.windOffset;

    //     if ( windOffset.value > 1 ) windDirr = -1;
    //     if ( windOffset.value <= 0 ) windDirr = 1;

    //     windOffset.value += windDirr * 0.0005;

    // }

};

GOT.FloraManager.prototype.addToScene = function () {

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        if ( this.blocks[ i ].instances.length ) {

            this.blocks[ i ].getInternal('mesh').castShadow = true;
            this.blocks[ i ].getInternal('mesh').receiveShadow = true;
            GOT.view.scene.add( this.blocks[ i ] );
            this.blocks[ i ].visible = false;

        }

    }

    this.globalSG.getInternal('mesh').castShadow = true;
    this.globalSG.getInternal('mesh').receiveShadow = true;
    GOT.view.scene.add( this.globalSG );

};

GOT.FloraManager.prototype.show = function () {

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        this.blocks[ i ].visible = true;

    }

};

GOT.FloraManager.prototype.hide = function () {

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        this.blocks[ i ].visible = false;

    }

    this.globalSG.visible = false;

};


/*
 * GOT
 * @author: ohmed
 * ALL decorations [visual meshes] handling
*/

GOT.DecorationManager = function ( params ) {

    params = params || {};

    this.landscape = params.landscape || false;

    this.texturesID = {
        'stone01':          0,
        'ground-block01':   1,
        'ground-block02':   2,
        'gold01':           3,
        'SRocks':           4
    },

    this.blocksCount = params.blocksCount || 9 * 25;
    this.blocks = [];

    var textureAtlas = GOT.ResourceMng.getTexture( 'decorations' );

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        var group = new NWE.fw.StaticGroup();
        group.material.transparent = true;
        group.material.defines[ 'ALPHATEST' ] = '1.0';
        group.material.uniforms[ 'alphaTest' ].value = 0.4;
        group.setAtlasTexture( textureAtlas, 4 );

        this.blocks.push( group );

    }

    this.globalSG = new NWE.fw.StaticGroup();
    this.globalSG.material.transparent = true;
    this.globalSG.material.defines[ 'ALPHATEST' ] = '1.0';
    this.globalSG.material.uniforms[ 'alphaTest' ].value = 0.4;
    this.globalSG.setAtlasTexture( textureAtlas, 4 );
    this.globalSG.visible = false;

};

GOT.DecorationManager.prototype.add = function ( decoration ) {

    var TYPE = decoration.name + decoration.subtype;
    var terrainSize = this.landscape.terrain.gridSize;

    // move position coords to +/+ quater
    var x = decoration.position.x + 3 * terrainSize / 2;
    var z = decoration.position.z + 3 * terrainSize / 2;

    var blockSize = GOT.landscape.mapSize / 15;

    var blockID = Math.floor( x / blockSize ) + 15 * Math.floor( z / blockSize );
    var block = this.blocks[ blockID ];

    var instance = block.addInstance({
        type:       TYPE,
        position:   decoration.position.clone(),
        rotation:   decoration.rotation.clone(),
        scale:      new NWE.Vec3( 1 ),
        model:      GOT.ResourceMng.getRawGeometry( TYPE ),
        texturesID: this.texturesID
    });

    this.globalSG.addInstance({
        type:       TYPE,
        position:   decoration.position.clone(),
        rotation:   decoration.rotation.clone(),
        scale:      new NWE.Vec3( 1 ),
        model:      GOT.ResourceMng.getRawGeometry( TYPE ),
        texturesID: this.texturesID
    });

    return instance;

};

GOT.DecorationManager.prototype.deferredUpdate = function () {

    var mapSize = GOT.landscape.mapSize;
    var blockSize = GOT.landscape.mapSize / 15;

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        if ( this.blocks[ i ].instances.length ) {

            this.blocks[ i ].updateGeometry();

            this.blocks[ i ].getInternal('mesh').geometry.boundingSphere = null;
            this.blocks[ i ].getInternal('mesh').geometry.boundingBox = new NWE.Box3();
            this.blocks[ i ].getInternal('mesh').geometry.boundingBox.min.set( blockSize / 2 + blockSize * ( i % 15 ) - mapSize / 2 - blockSize / 2, -10, blockSize / 2 + blockSize * Math.floor( i / 15 ) - mapSize / 2 - blockSize / 2 );
            this.blocks[ i ].getInternal('mesh').geometry.boundingBox.max.set( blockSize / 2 + blockSize * ( i % 15 ) - mapSize / 2 + blockSize / 2,  10, blockSize / 2 + blockSize * Math.floor( i / 15 ) - mapSize / 2 + blockSize / 2 );

        }

    }

    this.globalSG.updateGeometry();

};

GOT.DecorationManager.prototype.goToLowDetailed = function () {

    this.globalSG.visible = true;

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        this.blocks[ i ].visible = false;

    }

};

GOT.DecorationManager.prototype.goToHighDetailed = function () {

    this.globalSG.visible = false;

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        this.blocks[ i ].visible = true;

    }

};

GOT.DecorationManager.prototype.addToScene = function () {

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        if ( this.blocks[ i ].instances.length ) {

            this.blocks[ i ].getInternal('mesh').castShadow = true;
            this.blocks[ i ].getInternal('mesh').receiveShadow = true;

            GOT.view.scene.add( this.blocks[ i ] );

        }

    }

    this.globalSG.getInternal('mesh').castShadow = true;
    // this.globalSG.getInternal('mesh').receiveShadow = true;
    GOT.view.scene.add( this.globalSG );

};

GOT.DecorationManager.prototype.show = function () {

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        this.blocks[ i ].visible = true;

    }

};

GOT.DecorationManager.prototype.hide = function () {

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        this.blocks[ i ].visible = false;

    }

    this.globalSG.visible = false;

};


/*
 * GOT
 * @author: ohmed
 * ALL building [visual meshes] handling
*/

GOT.BuildingManager = function ( params ) {

    params = params || {};

    this.landscape = params.landscape || false;

    this.texturesID = {
        'Castle01': 0,
        'Roof01': 0,
        'Roof02': 0,
        'Roof03': 0,
        'Wall01': 0,
        'Wall02': 0,
        'Wall03': 0,
        'Wall04': 0,
        'Field01': 0,
        'stone1': 0
    };

    this.blocksCount = params.blocksCount || 9 * 25;
    this.blocks = [];

    var textureAtlas = GOT.ResourceMng.getTexture( 'buildings' );

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        var group = new NWE.fw.StaticGroup();
        group.setAtlasTexture( textureAtlas, 4 );

        this.blocks.push( group );

    }

};

GOT.BuildingManager.prototype.add = function ( building ) {

    var TYPE = building.name + building.subtype;
    var terrainSize = this.landscape.terrain.gridSize;

    // move position coords to +/+ quater
    var x = building.position.x + 3 * terrainSize / 2;
    var z = building.position.z + 3 * terrainSize / 2;

    var blockSize = GOT.landscape.mapSize / 15;

    var blockID = Math.floor( x / blockSize ) + 15 * Math.floor( z / blockSize );
    var block = this.blocks[ blockID ];

    var instance = block.addInstance({
        type:       TYPE,
        position:   building.position.clone(),
        rotation:   building.rotation.clone(),
        scale:      building.scale.clone(),
        model:      GOT.ResourceMng.getRawGeometry( Building.list.buildings[ TYPE ].model ),
        texturesID: this.texturesID
    });

    return instance;

};

GOT.BuildingManager.prototype.deferredUpdate = function () {

    var mapSize = GOT.landscape.mapSize;
    var blockSize = GOT.landscape.mapSize / 15;

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        if ( this.blocks[ i ].instances.length ) {

            this.blocks[ i ].updateGeometry();

            this.blocks[ i ].getInternal('mesh').geometry.boundingSphere = null;
            this.blocks[ i ].getInternal('mesh').geometry.boundingBox = new NWE.Box3();
            this.blocks[ i ].getInternal('mesh').geometry.boundingBox.min.set( blockSize / 2 + blockSize * ( i % 15 ) - mapSize / 2 - blockSize / 2, -10, blockSize / 2 + blockSize * Math.floor( i / 15 ) - mapSize / 2 - blockSize / 2 );
            this.blocks[ i ].getInternal('mesh').geometry.boundingBox.max.set( blockSize / 2 + blockSize * ( i % 15 ) - mapSize / 2 + blockSize / 2,  10, blockSize / 2 + blockSize * Math.floor( i / 15 ) - mapSize / 2 + blockSize / 2 );

        }

    }

};

GOT.BuildingManager.prototype.addToScene = function () {

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        if ( this.blocks[ i ].instances.length ) {

            this.blocks[ i ].getInternal('mesh').castShadow = true;
            this.blocks[ i ].getInternal('mesh').receiveShadow = true;

            GOT.view.scene.add( this.blocks[ i ] );

        }

    }

};

GOT.BuildingManager.prototype.show = function () {

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        this.blocks[ i ].visible = true;

    }

};

GOT.BuildingManager.prototype.hide = function () {

    for ( var i = 0, il = this.blocksCount; i < il; i ++ ) {

        this.blocks[ i ].visible = false;

    }

};


/*
 * GOT
 * @author: ohmed
 * Landscape control
*/

GOT.Landscape = function () {

    var self = this;

    this.floraObjects = [];
    this.decorationsObjects = [];
    this.buildingsObjects = [];

    this.mapSize = 2033 * 3;

};

GOT.Landscape.prototype.init = function () {

    this.terrain = new GOT.Terrain();
    this.terrain.generate();

    this.buildings   = new GOT.BuildingManager({ landscape: this });
    this.flora       = new GOT.FloraManager({ landscape: this });
    this.decorations = new GOT.DecorationManager({ landscape: this });

    if ( EDITOR_MODE ) {

        GOT.editor.terrain = new Editor.Terrain();
        GOT.editor.terrain.init();

        GOT.editor.flora = new Editor.Flora();

        GOT.editor.decorations = new Editor.Decorations();

        GOT.editor.init();

    }

};

GOT.Landscape.prototype.parseLandscapeData = function ( name ) {

    var data = JSON.parse( GOT.ResourceMng.getRawConfig( name + '.map') );

    // add flora

    var object, type;
    var list;

    for ( var i = 0, il = data.mapObjects.objects.length; i < il; i ++ ) {

        object = data.mapObjects.objects[ i ];

        if ( object.type === 'Decoration' ) {

            type = Decoration;
            list = this.decorationsObjects;

        } else {

            type = Building;
            list = this.floraObjects;

        }

        object = new type[ object.name ]({
                    name: object.name,
                    subtype: object.subtype,
                    position: new NWE.Vec3( object.position.x, object.position.y, object.position.z ),
                    rotation: new NWE.Vec3()
                });

        list.push( object );

    }

    GOT.landscape.flora.deferredUpdate();
    GOT.landscape.flora.addToScene();

    if ( EDITOR_MODE ) {

        GOT.editor.flora.init();

    }

    // add labels

    for ( var i = 0, il = data.mapObjects.labels.length; i < il; i ++ ) {

        object = data.mapObjects.labels[ i ];

        object = new Decoration.GroundLabel({
                    name: object.name,
                    subtype: '',
                    position: new NWE.Vec3( object.position[ 0 ], object.position[ 1 ], object.position[ 2 ] ),
                    rotation: new NWE.Vec3( 0, object.rotation, 0 )
                });

        this.decorationsObjects.push( object );

    }

    GOT.landscape.decorations.deferredUpdate();
    GOT.landscape.decorations.addToScene();

    // add buildings

    var building;

    for ( var i = 0, il = data.mapObjects.buildings.length; i < il; i ++ ) {

        building = data.mapObjects.buildings[ i ];

        building = new Building[ building.name ]({
                        name: building.name,
                        subtype: building.subtype,
                        position: new NWE.Vec3( building.position[0], building.position[1] + 20, building.position[2] ),
                        scale: new NWE.Vec3( 1 ),
                        rotation: new NWE.Vec3( 0, building.rotation, 0 )
                    });

        this.buildingsObjects.push( building );

    }

    GOT.landscape.buildings.deferredUpdate();
    GOT.landscape.buildings.addToScene();

};


/*
 * GOT
 * @author: ohmed
 * Terrain water sys
*/

GOT.Water = function () {

    // add water plane

    var geometry = new NWE.gfx.PlaneGeometry( GOT.landscape.mapSize, GOT.landscape.mapSize, 2, 2 );
    geometry.applyMatrix( new NWE.Matrix4().makeRotationX( - Math.PI / 2 ) );
    geometry.boundingSphere = new NWE.Sphere();
    geometry.boundingSphere.center.set( 0, 0, 0 );
    geometry.boundingSphere.radius = 8000;

    //

    var vertexShader = [

        'void main () {',

        '    vUv = uv;',
        '    vUv2 = 20.0 * vUv;',

        '    vec4 mvPosition;',
        '    mvPosition = modelViewMatrix * vec4( position, 1.0 );',
        '    gl_Position = projectionMatrix * mvPosition;',

        '}'

    ].join( '\n' );

    var fragmentShader = [

        'void main () {',

        '    float koef = 2.0 * texture2D( noiseMap, vUv ).r;',
        '    gl_FragColor = vec4( normalize( vec3( 0.3 + koef / 2.0, 0.8 + koef / 2.0, 1.0 + koef * 2.0 ) ), 0.5 );',

        '    vec2 uv2 = vec2( mod( vUv2.s + offset.x, 1.0 ), mod( vUv2.t + offset.y, 1.0 ) );',

        '    vec3 texture = texture2D( textureMap, uv2 ).rgb;',
        '    gl_FragColor = vec4( 0.3 * texture.r + 0.8 * gl_FragColor.r, 0.3 * texture.g + 0.8 * gl_FragColor.g, 0.3 * texture.b + 0.8 * gl_FragColor.b, gl_FragColor.a );',

        '}'

    ].join('\n');

    var material = new NWE.gfx.ShaderMaterial({
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        varyings: {
                            'vUv':      { type: 'v2' },
                            'vUv2':     { type: 'v2' },
                        },
                        attributes: {
                            'position': { type: 'v3' },
                            'uv':       { type: 'v2' }
                        },
                        uniforms: {
                            'noiseMap':     { type: 't', value: GOT.ResourceMng.getTexture('wind01'), global: -1 },
                            'textureMap':   { type: 't', value: GOT.ResourceMng.getTexture('water'), global: -1 },
                            'offset':       { type: 'v2', value: new  NWE.Vec2( 0, 0 ), global: -1 },

                            'modelViewMatrix':  { type: 'm4', value: null, global: 2 },
                            'projectionMatrix': { type: 'm4', value: null, global: 2 }
                        },
                        transparent: true
                    });

    material.uniforms.textureMap.value.image.id = 'WATER';

    material.programId = 1000000;

    //

    var waterMesh = new NWE.gfx.Mesh( geometry, material );
    waterMesh.type = 'Water';
    GOT.view.add( waterMesh );

    this.mesh = waterMesh;
    this.offset = material.uniforms.offset.value;

};

GOT.Water.prototype.update = function ( delta ) {

    this.offset.x += delta / 50;
    this.offset.y += delta / 50;

};

GOT.Water.prototype.show = function () {

    this.mesh.visible = true;

};

GOT.Water.prototype.hide = function () {

    this.mesh.visible = false;

};


/*
 * GOT
 * @author: ohmed
 * Terrain control
*/

GOT.Terrain = function () {

    this.gridNodeCount = 101; // 100x100
    
    this.gridSize = 2033; // 2033x2033

    this.textureMapSize = 1024;

};

GOT.Terrain.prototype.generate = function () {

    var self = this;

    this.blocks = [];

    //

    var texture = GOT.ResourceMng.getTexture( 'landscape' );
    var k = 0;

    if ( EDITOR_MODE ) {

        for ( var j = 0; j < 3; j ++ ) {

            for ( var i = 0; i < 3; i ++ ) {

                var terrain = new NWE.fw.DynamicTerrain({
                    width: this.gridSize,
                    height: this.gridSize,
                    gridWidthNodeCount: 200,
                    gridHeightNodeCount: 200,
                    visiblePartSize: this.gridSize
                });

                terrain.getInternal('material').uniforms.noiseTexture.value = GOT.ResourceMng.getTexture( 'wind01' );
                terrain.getInternal('material').uniforms.zoom.value = 1;

                terrain.setAtlasTexture( texture, 4 );

                this.blocks.push( terrain );

                var dx = - this.gridSize + i * this.gridSize;
                var dz = - this.gridSize + j * this.gridSize;

                terrain.position.set( dx, 0, dz );

                if ( ! EDITOR_MODE ) {

                    ( function ( id, object ) {

                        GOT.map.loadMapping( 'map' + ( id + 1 ), function ( mapping ) {

                            object.setMapping( mapping );

                        });

                    }) ( k, terrain );

                } else {

                    GOT.map.loadMapping( 'mappingDev', function ( mapping ) {

                        GOT.editor.terrain.prepareMapping( mapping );
                        GOT.editor.terrain.updateMapping();

                    });

                }

                GOT.view.add( terrain );

                terrain.getInternal('mesh').geometry.boundingSphere = null;
                terrain.getInternal('mesh').geometry.boundingBox = new NWE.Box3();
                terrain.getInternal('mesh').geometry.boundingBox.min.set( - this.gridSize / 2, -10, - this.gridSize / 2 );
                terrain.getInternal('mesh').geometry.boundingBox.max.set( + this.gridSize / 2,  10, + this.gridSize / 2 );

                k ++;

            }

        }

    } else {

        var terrain = new NWE.fw.StaticTerrain( { width: 3 * this.gridSize, height: 3 * this.gridSize, zoom: 1, blocksXCount: 3, blocksYCount: 3 } );
        terrain.setup();

        var geometry;

        geometry = GOT.ResourceMng.getGeometry( 'Terrain1' );
        geometry.applyMatrix( new NWE.Matrix4().makeScale( 10, 10, 10 ) );
        geometry.applyMatrix( new NWE.Matrix4().makeTranslation( 0, -12, 0 ) );
        terrain.blocks[ 0 ].setGeometryLevel( geometry, 800 );

        geometry = GOT.ResourceMng.getGeometry( 'Terrain2' );
        geometry.applyMatrix( new NWE.Matrix4().makeScale( 10, 10, 10 ) );
        geometry.applyMatrix( new NWE.Matrix4().makeTranslation( 0, -12, 0 ) );
        terrain.blocks[ 1 ].setGeometryLevel( geometry, 800 );

        terrain.blocks[ 2 ].enabled = false;

        geometry = GOT.ResourceMng.getGeometry( 'Terrain4' );
        geometry.applyMatrix( new NWE.Matrix4().makeScale( 10, 10, 10 ) );
        geometry.applyMatrix( new NWE.Matrix4().makeTranslation( 0, -12, 0 ) );
        terrain.blocks[ 3 ].setGeometryLevel( geometry, 800 );

        geometry = GOT.ResourceMng.getGeometry( 'Terrain5' );
        geometry.applyMatrix( new NWE.Matrix4().makeScale( 10, 10, 10 ) );
        geometry.applyMatrix( new NWE.Matrix4().makeTranslation( 0, -12, 0 ) );
        terrain.blocks[ 4 ].setGeometryLevel( geometry, 800 );

        geometry = GOT.ResourceMng.getGeometry( 'Terrain6' );
        geometry.applyMatrix( new NWE.Matrix4().makeScale( 10, 10, 10 ) );
        geometry.applyMatrix( new NWE.Matrix4().makeTranslation( 0, -12, 0 ) );
        terrain.blocks[ 5 ].setGeometryLevel( geometry, 800 );

        geometry = GOT.ResourceMng.getGeometry( 'Terrain7' );
        geometry.applyMatrix( new NWE.Matrix4().makeScale( 10, 10, 10 ) );
        geometry.applyMatrix( new NWE.Matrix4().makeTranslation( 0, -12, 0 ) );
        terrain.blocks[ 6 ].setGeometryLevel( geometry, 800 );

        geometry = GOT.ResourceMng.getGeometry( 'Terrain8' );
        geometry.applyMatrix( new NWE.Matrix4().makeScale( 10, 10, 10 ) );
        geometry.applyMatrix( new NWE.Matrix4().makeTranslation( 0, -12, 0 ) );
        terrain.blocks[ 7 ].setGeometryLevel( geometry, 800 );

        geometry = GOT.ResourceMng.getGeometry( 'Terrain9' );
        geometry.applyMatrix( new NWE.Matrix4().makeScale( 10, 10, 10 ) );
        geometry.applyMatrix( new NWE.Matrix4().makeTranslation( 0, -12, 0 ) );
        terrain.blocks[ 8 ].setGeometryLevel( geometry, 800 );

        terrain.matchEdges();

        for ( var i = 0; i < 9; i ++ ) {

            terrain.blocks[ i ].setAtlasTexture( texture, 4 );

            if ( terrain.blocks[ i ].enabled ) {

                terrain.blocks[ i ].object.objects[0].object.receiveShadow = true;
                terrain.blocks[ i ].object.objects[0].object.castShadow = false;
                terrain.blocks[ i ].material.uniforms.noiseTexture.value = GOT.ResourceMng.getTexture( 'random' );

            }

            ( function ( id, object ) {

                GOT.map.loadMapping( 'map' + ( id + 1 ), function ( mapping ) {

                    object.blocks[ id ].useMappingTexture( mapping );

                });

            }) ( i, terrain );

        }

        terrain.position.y = 1;

        GOT.view.scene.add( terrain );

        GOT.landscape.terrain.object = terrain;

        // add bottom ground plane

        var bottomTexture = GOT.ResourceMng.getTexture( 'ground' );
        bottomTexture.repeat.set( 20, 20 );
        bottomTexture.wrapS = NWE.gfx.Const.RepeatWrapping;
        bottomTexture.wrapT = NWE.gfx.Const.RepeatWrapping;
        geometry = GOT.ResourceMng.getGeometry( 'BottomGround' );
        geometry.applyMatrix( new NWE.Matrix4().makeScale( 10, 10, 10 ) );
        this.bottom = new NWE.gfx.Mesh( geometry, new NWE.gfx.MeshLambertMaterial({ ambient: 0x888888, map: bottomTexture }) );
        this.bottom.position.set( 0, -45, 0 );
        GOT.view.scene.add( this.bottom );

    }

    // add water plane

    this.water = new GOT.Water();

};

GOT.Terrain.prototype.update = function ( delta ) {

    if ( EDITOR_MODE ) {

        for ( var i = 0, il = this.blocks.length; i < il; i ++ ) {

            this.blocks[ i ].update( GOT.view.scene, GOT.view.camera );

        }

    }

    this.water.update( delta );

};

GOT.Terrain.prototype.createEdges = function () {

    // todo

};

GOT.Terrain.prototype.enableCliffUVCounting = function () {

    if ( EDITOR_MODE ) {

        for ( var i = 0, il = this.blocks.length; i < il; i ++ ) {

            this.blocks[ i ].getInternal('mesh').material.uniforms.useCliffTexture.value = 1;

        }

    } else {

        for ( var i = 0, il = this.object.blocks.length; i < il; i ++ ) {

            this.object.blocks[ i ].material.uniforms.useCliffTexture.value = 1;

        }

    }

};

GOT.Terrain.prototype.disableCliffUVCounting = function () {

    if ( EDITOR_MODE ) {

        for ( var i = 0, il = this.blocks.length; i < il; i ++ ) {

            this.blocks[ i ].getInternal('mesh').material.uniforms.useCliffTexture.value = 0;

        }

    } else {

        for ( var i = 0, il = this.object.blocks.length; i < il; i ++ ) {

            this.object.blocks[ i ].material.uniforms.useCliffTexture.value = 0;

        }

    }

};

GOT.Terrain.prototype.getPoint = function ( x, z ) {

    // ctx = this.textureMapCanvasCtx[ 0 ];
    // tmp

    var offset = 22;

    var ctx = GOT.editor.terrain.ctx;
    var size = ctx.canvas.width;
    var sizeReal = size - 2 * offset;
    var data = this.tmpHCache = this.tmpHCache || ctx.getImageData( offset, offset, sizeReal, sizeReal ).data;

    // convert position to canvas position
    x = Math.round( ( size / 2 ) * Math.max( x, 0 ) ) - 4;
    z = Math.round( ( size / 2 ) * Math.max( z, 0 ) ) - 4;

    // get mapping Points
    var id1 = 4 * ( x + z * sizeReal ),
        id2 = 4 * ( ( x + sizeReal / 2 ) + z * sizeReal ),
        id3 = 4 * ( x + ( z + sizeReal / 2 ) * sizeReal ),
        id4 = 4 * ( ( x + sizeReal / 2 ) + ( z + sizeReal / 2 ) * sizeReal );

    return [

        data[ id1 + 0 ],  // [0] ground01
        data[ id1 + 1 ],  // [1] grass01
        data[ id1 + 2 ],  // [2] grass02
        data[ id2 + 0 ],  // [3] stone01
        data[ id2 + 1 ],  // [4] iron01
        data[ id2 + 2 ],  // [5] swamp01
        // ...
        0, 0, 0, 0, 0, 0, 0,
        // ...
        data[ id4 + 1 ],  // [13] building height
        data[ id4 + 2 ] - 128  // [14] terrain height

    ];

};

GOT.Terrain.prototype.getPointHeight = function ( x, z, asColor ) {

    var height = this.getPoint( x, z )[14];

    if ( ! asColor ) {

        return height;

    } else {

        return height + 128;

    }

};

GOT.Terrain.prototype.show = function () {

    for ( var i = 0, il = this.blocks.length; i < il; i ++ ) {

        this.blocks[ i ].visible = true;

    }

};

GOT.Terrain.prototype.hide = function () {

    for ( var i = 0, il = this.blocks.length; i < il; i ++ ) {

        this.blocks[ i ].visible = false;

    }

};


/*
 * GOT
 * @author: ohmed
 * Render loop
*/

(function () {

    var view = GOT.view;
    var controls = GOT.controls;

    var terrainSize;

    var cameraPosition;
    var lookAtVector = new NWE.Vec3();
    var delta;

    GOT.view.updateCameraPosition = function ( xval, zval ) {

        delta = 1000 * view.globalTime.getDelta();

        terrainSize = GOT.landscape.terrain.gridSize;

        cameraPosition = view.camera.position;

        // move camera

        xval = xval || ( view.camera.position.y / 400 * delta / 10 ) * (  controls.forwardSpeed * Math.sin( view.rot ) + controls.sideSpeed    * Math.cos( view.rot ) );
        zval = zval || ( view.camera.position.y / 400 * delta / 10 ) * ( -controls.sideSpeed    * Math.sin( view.rot ) + controls.forwardSpeed * Math.cos( view.rot ) );

        if ( cameraPosition.x + xval <  terrainSize / 2 * 3 && xval > 0 ) cameraPosition.x += xval;
        if ( cameraPosition.x + xval > -terrainSize / 2 * 3 && xval < 0 ) cameraPosition.x += xval;
        if ( cameraPosition.z + zval <  terrainSize / 2 * 3 && zval > 0 ) cameraPosition.z += zval;
        if ( cameraPosition.z + zval > -terrainSize / 2 * 3 && zval < 0 ) cameraPosition.z += zval;

        // rotate camera

        if ( controls.rotSpeed ) {

            view.rot += controls.rotSpeed;

        }

        // zoom camera

        if ( view.camera.oldYPosition !== view.camera.position.y ) {

            view.camera.oldYPosition = view.camera.position.y;
            var zoom = Math.max( Math.min( view.camera.position.y / 800, 1 ), 0.4 );

            if ( view.camera.position.y < 3000 ) {

                GOT.landscape.terrain.enableCliffUVCounting();

            } else {

                GOT.landscape.terrain.disableCliffUVCounting();

            }

            if ( view.camera.position.y < 180 ) {

                $('#map-controls-top').show();
                $('#map-controls-left').show();
                $('#map-controls-right').show();
                $('#map-controls-bottom').show();

                GOT.controls.mapDraggingEnabled = false;

                zoom = 1;

            } else {

                $('#map-controls-top').hide();
                $('#map-controls-left').hide();
                $('#map-controls-right').hide();
                $('#map-controls-bottom').hide();

                GOT.controls.mapDraggingEnabled = true;

            }

            if ( view.camera.position.y > 1500 ) {

                GOT.landscape.flora.goToLowDetailed();
                GOT.landscape.decorations.goToLowDetailed();

            } else {

                GOT.landscape.flora.goToHighDetailed();
                GOT.landscape.decorations.goToHighDetailed();

            }

            if ( GOT.view.sun.shadowCamera ) {

                var k;

                if  ( view.camera.position.y < 200 ) {

                    k = view.camera.position.y / 500;

                } else if ( view.camera.position.y < 2000 ) {

                    k = view.camera.position.y / 1500;

                } else {

                    k = 2;

                }

                GOT.view.sun.shadowCamera.top = 3000 * k;
                GOT.view.sun.shadowCamera.bottom = - 3000 * k;
                GOT.view.sun.shadowCamera.left = - 3000 * k;
                GOT.view.sun.shadowCamera.right = 3000 * k;

                GOT.view.sun.shadowCamera.updateProjectionMatrix();

            }

            if ( EDITOR_MODE ) {

                for ( var i = 0; i < 9; i ++ ) {

                    GOT.landscape.terrain.blocks[ i ].setZoom( zoom );

                }

            }

            if ( view.camera.position.y > 4900 ) view.camera.position.y = 4900;
            if ( view.camera.position.y < 80 ) view.camera.position.y = 80;

        }

    };

    GOT.render = function () {

        var delta = GOT.clock.getDelta();

        var view = GOT.view;

        requestAnimationFrame( GOT.render );

        //

        GOT.landscape.terrain.update( delta );

        view.scene.update( view.camera, delta );

        var pos;

        if  ( view.camera.position.y < 200 ) {

            pos = new NWE.Vec3( view.camera.position.x + view.camera.position.y / 2, 240, view.camera.position.z - 500 );
            GOT.view.sun.position.set( pos.x + 120, pos.y, pos.z );

        } else if ( view.camera.position.y < 2000 ) {

            pos = new NWE.Vec3( view.camera.position.x + view.camera.position.y / 2, 240, view.camera.position.z );
            GOT.view.sun.position.set( pos.x + 120, pos.y, pos.z );

        } else {

            pos = new NWE.Vec3( 0, 240, 0 );
            GOT.view.sun.position.set( pos.x + 0, pos.y, pos.z );

        }

        GOT.view.sun.target.position.set( pos.x, 0, pos.z );
        GOT.view.sun.target.updateMatrixWorld();

        if ( GOT.settings.postprocessing.on ) {

            view.composer.render();

        } else {

            view.renderer.render( view.scene, view.camera );

        }

        GOT.view.updateCameraPosition();

    };

}) ();


/*
 * GOT
 * @author: ohmed
 * Intersect sys for view.scene objects
*/

var Picker = function () {

    this.objSelector = new NWE.gfx.GpuSelector();
    this.objSelector.addEventListener( 'onSelect', this.onObjectSelect );

    this.projector = new NWE.gfx.Projector();

    this._vector = new NWE.Vec3();
    this._ray = new NWE.Ray();

    this.pickableObjects = {};

};

Picker.prototype.onObjectSelect = function ( event ) {

    var selectedObject = GOT.view.picker.pickableObjects[ 'id' + event.objectID ];

    if ( selectedObject && selectedObject.onClick ) {

        selectedObject.onClick();

    }

};

Picker.prototype.deltaScreenToWorld = function ( x, y, dx, dy ) {

    var landscapePoint1, landscapePoint2;

    landscapePoint1 = GOT.view.picker.pick({
                            x: x,
                            y: y
                        }, GOT.view.camera, 'landscape').point;

    landscapePoint2 = GOT.view.picker.pick({
                            x: x - dx,
                            y: y - dy
                        }, GOT.view.camera, 'landscape').point;

    var dx = landscapePoint2.x - landscapePoint1.x;
    var dz = landscapePoint2.z - landscapePoint1.z;

    return { dx: dx, dz: dz };

};

Picker.prototype.getPointedObj = function ( x, y, intersectPoint, camera ) {

    this.objSelector.pick( x / window.innerWidth, y / window.innerHeight, camera );

};

Picker.prototype.getScreenPos = function ( point, camera ) {

    point = new NWE.Vec3( point.x, point.y, point.z );

    var widthHalf = window.innerWidth / 2,
        heightHalf = window.innerHeight / 2,
        vector = this.projector.projectVector( point, camera );

    return {

        x: ( vector.x * widthHalf ) + widthHalf,
        y: - ( vector.y * heightHalf ) + heightHalf

    };

};

Picker.prototype.removeObjectPickable = function ( gameObj ) {

    gameObj.pickable = false;
    this.objSelector.removeObject( gameObj );

};

Picker.prototype.addObjectPickable = function ( gameObj ) {

    this.objSelector.addObject({

        id:       gameObj.id,
        size:     gameObj.size,
        rotation: gameObj.rotation.clone(),
        position: gameObj.position.clone(),

        staticObject: true

    });

    gameObj.pickable = true;
    this.pickableObjects[ 'id' + gameObj.id ] = gameObj;

};

Picker.prototype.pick = function ( point, camera, param ) {

    var self = this,

        alpha, dx, dy, dz,
        k, steps, terrainSize;

    //

    self._vector.set( ( point.x / window.innerWidth ) * 2 - 1, - ( point.y / window.innerHeight ) * 2 + 1, 0.5 );
    self.projector.unprojectVector( self._vector, camera );

    self._ray.set( camera.position, self._vector.sub( camera.position ).normalize() );
    alpha = - Math.atan( self._ray.direction.z / self._ray.direction.x ) - Math.PI / 2;

    k = camera.position.y / self._ray.direction.y;
    dx = - self._ray.direction.x * k;
    dz = - self._ray.direction.z * k;
    steps = 300;

    var pos = new NWE.Vec3();
    var intrPoint = new NWE.Vec3();

    for ( var i = 0, h; i <= steps; i ++ ) {

        intrPoint.set(
            camera.position.x + ( i + 3 ) * dx / steps,
            0,
            camera.position.z + ( i + 3 ) * dz / steps
        );

        h = 5;

        if ( h >= camera.position.y - i * camera.position.y / steps ) {

            if ( param === 'landscape' ) {

                return {

                    type:     null,
                    objects:  [],
                    point:    new NWE.Vec3( intrPoint.x, 0, intrPoint.z )

                };

            } else {

                return self.getPointedObj( point.x, point.y, new NWE.Vec3( intrPoint.x, 0, intrPoint.z ), camera );
            
            }

        }

    }

    return self.getPointedObj( point.x, point.y, intrPoint, camera );

};


(function() {

    function toggle () {

        var target = $(this).data('target');

        if ( $(this).hasClass('open') ) {

            $(this).removeClass('open');

            $(target).velocity('slideUp', 100);

        } else {

            $(this).addClass('open');

            $(target).velocity('slideDown', 100);

        }

    };

    $(document).on('click', '[data-toggle="dropdown"]', toggle);

}());


(function () {

    var POPUP_WIDTH = 320;
    var POPUP_MAX_HEIGHT = 500;
    var POPUP_OFFSET_Y = -20;
    var POPUP_ZOOM_EFFECT_OFFSET = 3;

    var activeObject;

    function showBuildingPopup ( instance ) {

        activeObject = instance;

        var position = GOT.view.picker.getScreenPos( activeObject.position, GOT.view.camera );

        var infoPopupEl = $('.info-popup');
        var infoPopupContentEl = infoPopupEl.find('.info-popup-content');

        infoPopupContentEl.html( activeObject.getShortInfo() );

        var width = $(window).width();
        var height = $(window).height();

        infoPopupEl.css({

            left: position.x - 0.5 * POPUP_WIDTH - POPUP_ZOOM_EFFECT_OFFSET, 
            bottom: height - position.y - POPUP_OFFSET_Y + 2 * POPUP_ZOOM_EFFECT_OFFSET,
            width: POPUP_WIDTH + 2 * POPUP_ZOOM_EFFECT_OFFSET, 
            opacity: 0

        }).show();

        _cancelMousewheel();

        setTimeout( _fitPopup );

        function _fitPopup () {

            infoPopupEl.velocity({ 

                left: position.x - 0.5 * POPUP_WIDTH, 
                bottom: height - position.y - POPUP_OFFSET_Y,
                width: POPUP_WIDTH, 
                opacity: 1

            }, {

                duration: 150,

                complete: function () {

                    var rect = infoPopupEl[0].getBoundingClientRect();
                    var delta;

                    if ( rect.left < 0 ) {

                        delta = GOT.view.picker.deltaScreenToWorld(position.x, position.y, - rect.left, 0);

                    }

                    if ( rect.top < 0 ) {

                        delta = GOT.view.picker.deltaScreenToWorld(position.x, position.y, 0, - rect.top + $('#main-nav').height());

                    }

                    if ( width - rect.right < 0 ) {

                        delta = GOT.view.picker.deltaScreenToWorld(position.x, position.y, - (width - rect.right), 0);

                    }

                    if ( height - rect.bottom < 0 ) {

                        delta = GOT.view.picker.deltaScreenToWorld(position.x, position.y, 0, - (height - rect.bottom));

                    }

                    var k = 0;
                    var steps = 10;

                    var interval = setInterval( function () {

                        GOT.view.updateCameraPosition( delta.dx / steps, delta.dz / steps );

                        k ++;

                        if ( k === steps ) {

                            clearInterval( interval );

                        }

                    }, 20);

                }

            });

            infoPopupContentEl.css({ 

                'max-height': POPUP_MAX_HEIGHT, 

            });

        };

        function _cancelMousewheel () {

            infoPopupEl.off('mousewheel.got');

            infoPopupEl.on('mousewheel.got', function (e) { e.stopPropagation(); });

        };

    };

    function closePopup () {

        $('.info-popup').hide();

        activeObject = undefined;

    };

    var infoPopupEl, height;

    function movePopup () {

        if ( ! activeObject ) return;

        var position = GOT.view.picker.getScreenPos( activeObject.position, GOT.view.camera );

        if ( ! infoPopupEl ) {

            infoPopupEl = $('.info-popup');

        }

        if ( ! height ) {

            height = $(window).height();

        }

        infoPopupEl.css({

            left: position.x - 0.5 * POPUP_WIDTH, 
            bottom: height - position.y - POPUP_OFFSET_Y

        });

    };

    $(document).on('click', closePopup);
    $(document).on('click', '.info-popup', function ( event ) { event.stopPropagation(); });

    GOT.vent.on('showBuildingPopup', showBuildingPopup);
    GOT.vent.on('mapMove', movePopup);

} ());


(function () {

    function zoomIn () {

        GOT.controls.zoom( -1, 3 );

    };

    function zoomOut () {

        GOT.controls.zoom( 1, 3 );

    };

    function moveForard () {

        GOT.controls.moveForward( -3 );

    };

    function moveBack () {

        GOT.controls.moveForward( 3 );

    };

    function moveRight () {

        GOT.controls.moveSide( 3 );

    };

    function moveLeft () {

        GOT.controls.moveSide( -3 );

    };

    function stopMoveForard () {

        GOT.controls.stopForward();

    };

    function stopMoveBack () {

        GOT.controls.stopForward();

    };

    function stopMoveRight () {

        GOT.controls.stopSide();

    };

    function stopMoveLeft () {

        GOT.controls.stopSide();

    };

    function init () {

        $('.map-zoom-in').click( zoomIn );
        $('.map-zoom-out').click( zoomOut );

        $('#map-controls-top').mousedown( moveForard );
        $('#map-controls-bottom').mousedown( moveBack );
        $('#map-controls-right').mousedown( moveRight );
        $('#map-controls-left').mousedown( moveLeft );

        $('#map-controls-top').mouseup( stopMoveForard );
        $('#map-controls-bottom').mouseup( stopMoveBack );
        $('#map-controls-right').mouseup( stopMoveRight );
        $('#map-controls-left').mouseup( stopMoveLeft );

    };

    GOT.vent.on('appLoaded', init);

} ());


(function () {

    var Menu = GOT.UI.Menu;

    var tree;

    function init () {

        $.get('resources/family-tree.json').then( function ( res ) {

            tree = res;

            renderFamilies();
            renderFamilyTree();

        });

    };

    function renderFamilies () {

        var html = [];

        tree.forEach(function ( item ) {

            html.push([

                '<a data-toggle="dropdown" class="dropdown" data-target="#' + item.name + '-dropdown">',
                '    <img src="img/houses/' + item.name + '-mini.png" height="20">' + item.name,
                '</a>'

            ].join(''));

        });

        $('#families').html(html.join(''));

    };

    function renderFamilyTree () {

        var html = [];

        tree.forEach(function ( item ) {

            html.push([

                '<nav id="' + item.name + '-dropdown" class="dropdown-menu">',
                '    <a style="width:40px;"><img src="img/houses/' + item.name + '-mini.png" height="20"></a>'

            ].join(''));

            item.children.forEach(function (child) {

                html.push([

                    '<a href="#">',
                    '    ' + child.name,
                    '</a>'

                ].join(''));

            });

            html.push('</nav>');

        });

        $('#main-nav').append(html.join(''));

    };

    function loadTemplate ( name ) {

        return $.get( '/html/bio/' + name + '.html' );

    };

    $(init);

}());


/*
 * GOT
 * @author: ohmed
*/

var Editor = function () {

};

Editor.prototype.init = function () {

    this.oldMousePosition = new NWE.Vec2();

    this.actions = [];
    this.activeActionId = -1;

    document.querySelector('#editor').style['display'] = 'block';

    this.marker = {
        size: 20,
        type: null,
        subtype: null,
        mousePressed: false,
        position: new NWE.Vec2(),
        enabled: false
    };

    //

    document.addEventListener( 'keydown', this.onKeyDown.bind( this ), false );
    document.addEventListener( 'keyup', this.onKeyUp.bind( this ), false );

    document.addEventListener( 'mousemove', this.onMouseMove.bind( this ), false );
    document.addEventListener( 'mouseup', this.onMouseUp.bind( this ), false );
    document.addEventListener( 'mousedown', this.onMouseDown.bind( this ), false );
    document.body.addEventListener( 'mousewheel', this.onMouseWheel.bind( this ), false );

};

Editor.prototype.selectTab = function ( tabName ) {

    var items = document.querySelectorAll('#editor .main-menu');

    for ( var i = 0, il = items.length; i < il; i ++ ) {

        items[ i ].style['display'] = 'none';

    }

    document.querySelector('#editor #' + tabName).style['display'] = 'block';

};

//

Editor.prototype.clearNextActions = function () {

    for ( var i = this.activeActionId + 1, il = this.actions.length; i < il; i ++ ) {

        this.actions.pop();

    }

};

Editor.prototype.addAction = function ( type ) {

    this.actions.push( type );
    this.activeActionId ++;

    switch ( type ) {

        case 'terrain':

            this.terrain.saveState();
            break;

        case 'flora':

            this.flora.saveState();
            break;

    }

};

Editor.prototype.undo = function () {

    if ( this.actions[ this.activeActionId ] ) {

        switch ( this.actions[ this.activeActionId ] ) {

            case 'terrain':

                this.terrain.undo();
                break;

            case 'flora':

                this.flora.undo();
                break;

        }

        this.activeActionId --;

    } else {

        NWE.Logger.log( 'No prev actions found.' );

    }

};

Editor.prototype.redo = function () {

    if ( this.actions[ this.activeActionId + 1 ] ) {

        switch ( this.actions[ this.activeActionId + 1 ] ) {

            case 'terrain':

                this.terrain.redo();
                break;

            case 'flora':

                this.flora.redo();
                break;

        }

        this.activeActionId ++;

    } else {

        NWE.Logger.log( 'No next actions found.' );

    }

};

//

Editor.prototype.selectMarker = function ( type, subtype ) {

    this.marker.type = type;
    this.marker.subtype = subtype;

    for ( var i = 0, il = GOT.landscape.terrain.blocks.length; i < il; i ++ ) {

        if ( ! GOT.landscape.terrain.blocks[ i ].getInternal('material').uniforms.marker.value ) {

            GOT.landscape.terrain.blocks[ i ].getInternal('material').uniforms.marker.value = new NWE.Vec3( -10000, -10000, this.marker.size );

        }

    }

    this.enableMarker();

};

Editor.prototype.setMarkerSize = function ( value ) {

    this.marker.size = value;

    for ( var i = 0, il = GOT.landscape.terrain.blocks.length; i < il; i ++ ) {

        GOT.landscape.terrain.blocks[ i ].getInternal('material').uniforms.marker.value.z = value;

    }

};

Editor.prototype.enableMarker = function () {

    this.marker.enabled = true;

};

Editor.prototype.disableMarker = function () {

    this.marker.enabled = false;
    this.updateMarkerPosition( -10000, -10000 );

};

Editor.prototype.updateMarkerPosition = function ( mouseX, mouseY ) {

    mouseX = mouseX || this.oldMousePosition.x;
    mouseY = mouseY || this.oldMousePosition.y;

    var position = GOT.view.picker.pick( { x: mouseX, y: mouseY }, GOT.view.camera, 'landscape' ).point;
    var vec3;

    for ( var i = 0, il = GOT.landscape.terrain.blocks.length; i < il; i ++ ) {

        vec3 = GOT.landscape.terrain.blocks[ i ].getInternal('material').uniforms.marker.value;

        vec3.x = (   position.x - GOT.landscape.terrain.blocks[ i ].position.x ) / GOT.landscape.terrain.gridSize + 0.5;
        vec3.y = ( - position.z + GOT.landscape.terrain.blocks[ i ].position.z ) / GOT.landscape.terrain.gridSize + 0.5;

    }

    this.marker.position.set( position.x / GOT.landscape.mapSize + 0.5, position.z / GOT.landscape.mapSize + 0.5 );

};

Editor.prototype.markerDraw = function ( mouseX, mouseY ) {

    if ( this.marker.mousePressed && ( Math.abs( this.oldMousePosition.x - mouseX ) > 5 || Math.abs( this.oldMousePosition.y - mouseY ) > 5 ) ) {

        this.oldMousePosition.set( mouseX, mouseY );
        $('body').addClass('default');

        if ( this.marker.type === 'terrain' ) {

            this.terrain.draw( this.marker );

        } else if ( this.marker.type === 'flora' ) {

            if ( this.marker.subtype === 'Eraser' ) {

                this.flora.erase( this.marker );

            } else {

                this.flora.draw( this.marker );

            }

        } else if ( this.marker.type === 'decorations' ) {

            if ( this.marker.subtype === 'Eraser' ) {

                this.decorations.erase( this.marker );

            } else {

                this.decorations.draw( this.marker );

            }

        }

    }

};

//

Editor.prototype.onMouseDown = function ( event ) {

    if ( event.which === 3 ) {

        this.disableMarker();
        return;

    }

    var mouseX = event.clientX;
    var mouseY = event.clientY;

    this.marker.mousePressed = true;

    if ( this.marker.enabled ) {

        this.oldMousePosition.set( -100, -100 );
        this.markerDraw( mouseX, mouseY );

    }

};

Editor.prototype.onMouseUp = function ( event ) {

    var mouseX = event.clientX;
    var mouseY = event.clientY;

    if ( this.marker.type === 'flora' ) {

        this.flora.update();

    }

    if ( this.marker.enabled ) {

        this.clearNextActions();
        this.addAction( this.marker.type );

    }

    this.marker.mousePressed = false;

};

Editor.prototype.onMouseMove = function ( event ) {

    event.preventDefault();

    var mouseX = event.clientX;
    var mouseY = event.clientY;

    if ( this.marker.enabled ) {

        this.updateMarkerPosition( mouseX, mouseY );
        this.markerDraw( mouseX, mouseY );

    }

};

Editor.prototype.onMouseWheel = function ( event ) {

    var delta = event.wheelDelta;

    if ( this.marker.enabled ) {

        this.marker.size += delta / 100;

        for ( var i = 0, il = GOT.landscape.terrain.blocks.length; i < il; i ++ ) {

            this.setMarkerSize( this.marker.size );

        }

        event.stopPropagation();
        event.preventDefault();
        return false;

    }

};

//

Editor.prototype.onKeyDown = function ( event ) {

    switch ( event.keyCode ) {

        case 90:  // Z

            if ( ( GOT.controls.keyboard.CMD || GOT.controls.keyboard.CTRL ) && GOT.controls.keyboard.SHIFT ) {

                this.redo();
                break;

            }

            if ( GOT.controls.keyboard.CMD || GOT.controls.keyboard.CTRL ) {

                this.undo();
                break;

            }

            break;

    }

};

Editor.prototype.onKeyUp = function ( event ) {

};

//

GOT.editor = new Editor();


/*
 * GOT
 * @author: ohmed
*/

Editor.Terrain = function () {

};

Editor.Terrain.prototype.init = function () {

    this.canvas = document.createElement('canvas');
    this.canvas.width = 1024 * 3;
    this.canvas.height = 1024 * 3;

    this.ctx = this.canvas.getContext('2d');

    this.mappingsList = [];

    this.states = [];
    this.activeState = -1;

};

Editor.Terrain.prototype.prepareMapping = function ( mapping ) {

    var size = 512 * 6;

    this.ctx.drawImage( mapping, 0, 0, size, size, 0, 0, size, size );

    //

    this.saveState();

};

Editor.Terrain.prototype.updateMapping = function () {

    var mapping;
    var id = 0;
    var part;
    var size = 512;

    var offset = [ 8, 0, -8 ];

    for ( var j = 0; j < 3; j ++ ) {

        for ( var i = 0; i < 3; i ++ ) {

            if ( ! this.mappingsList[ id ] ) {

                var canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 1024;

                GOT.landscape.terrain.blocks[ id ].setMapping( canvas );
                this.mappingsList[ id ] = { canvas: canvas, ctx: canvas.getContext('2d') };

            }

            var ctx = this.mappingsList[ id ].ctx;

            part = this.ctx.getImageData( i * size + offset[ i ], j * size + offset[ j ], size, size );
            ctx.putImageData( part, 0, 0 );

            part = this.ctx.getImageData( i * size + 3 * size + offset[ i ], j * size + offset[ j ], size, size );
            ctx.putImageData( part, size, 0 );

            part = this.ctx.getImageData( i * size + offset[ i ], j * size + 3 * size + offset[ j ], size, size );
            ctx.putImageData( part, 0, size );

            part = this.ctx.getImageData( i * size + 3 * size + offset[ i ], j * size + 3 * size + offset[ j ], size, size );
            ctx.putImageData( part, size, size );

            GOT.landscape.terrain.blocks[ id ].updateMapping();

            id ++;

        }

    }

};

Editor.Terrain.prototype.draw = function ( marker ) {

    var mappingSize = 512; 

    var type = marker.subtype;
    var position = marker.position;
    var size = ( marker.size / GOT.landscape.terrain.gridSize ) * mappingSize * 2;
    size = size - ( size % 2 );

    if ( size <= 0 ) size = 2;

    //

    var x = 8 + Math.floor( position.x * ( mappingSize - 8 ) * 3 );
    var y = 8 + Math.floor( position.y * ( mappingSize - 8 ) * 3 );

    //

    function paint ( opacity, intensity, textureType ) {

        var localIntensity;
        var dist;
        var id;

        var mappingColor = textureType % 4;

        var deltaX = ( Math.floor( textureType / 4 ) % 2 ) * 3 * mappingSize;
        var deltaY = Math.floor( Math.floor( textureType / 4 ) / 2 ) * 3 * mappingSize;

        var mapData = this.ctx.getImageData( x + deltaX - size / 2, y + deltaY - size / 2, size, size );

        for ( var i = -size / 2, il = size / 2; i < il; i ++ ) {

            for ( var j = -size / 2, jl = size / 2; j < jl; j ++ ) {

                dist = Math.sqrt( i * i + j * j );
                if ( dist > size / 2 ) continue;

                localIntensity = intensity * ( size - dist ) / size;

                id = 4 * ( ( i + size / 2 ) + size * ( j + size / 2 ) );
                mapData.data[ id + mappingColor ] = Math.min( mapData.data[ id + mappingColor ] + 255 * localIntensity, 255 * opacity );

            }

        }

        this.ctx.putImageData( mapData, x + deltaX - size / 2, y + deltaY - size / 2 );

    };

    function erase () {

        var mappingColor;
        var deltaX, deltaY;
        var mapData;
        var i, j;
        var dist, id;

        for ( var textureType = 0; textureType < 15; textureType ++ ) {

            if ( textureType === 14 || ( textureType + 1 ) % 4 === 0 ) continue;

            mappingColor = textureType % 4;

            deltaX = ( Math.floor( textureType / 4 ) % 2 ) * 3 * mappingSize;
            deltaY = Math.floor( Math.floor( textureType / 4 ) / 2 ) * 3 * mappingSize;

            mapData = this.ctx.getImageData( x + deltaX - size / 2, y + deltaY - size / 2, size, size );

            for ( i = -size / 2, il = size / 2; i < il; i ++ ) {

                for ( j = -size / 2, jl = size / 2; j < jl; j ++ ) {

                    dist = Math.sqrt( i * i + j * j );
                    if ( dist > size / 2 ) continue;

                    id = 4 * ( ( i + size / 2 ) + size * ( j + size / 2 ) );

                    if ( textureType === 0 ) {

                        mapData.data[ id + mappingColor ] = 255;

                    } else {

                        mapData.data[ id + mappingColor ] = 0;

                    }

                }

            }

            this.ctx.putImageData( mapData, x + deltaX - size / 2, y + deltaY - size / 2 );

        }

    };

    //

    function smooth () {

        var mappingColor = 2;
        var dist;
        var newValue;
        var id;

        var deltaX = mappingSize * 3;
        var deltaY = mappingSize * 3;

        var mapData = this.ctx.getImageData( x + deltaX - size / 2, y + deltaY - size / 2, size, size );

        for ( var i = -size / 2 + 1, il = size / 2 - 1; i < il; i ++ ) {

            for ( var j = -size / 2 + 1, jl = size / 2 - 1; j < jl; j ++ ) {

                dist = Math.sqrt( i * i + j * j );
                if ( dist > size / 2 ) continue;

                id = 4 * ( ( i + size / 2 ) + size * ( j + size / 2 ) );

                newValue  = mapData.data[ id + mappingColor ];
                newValue += mapData.data[ id + mappingColor + 4 ];
                newValue += mapData.data[ id + mappingColor - 4 ];
                newValue += mapData.data[ id + mappingColor + 4 * size ];
                newValue += mapData.data[ id + mappingColor - 4 * size ];
                newValue += mapData.data[ id + mappingColor + 4 * size + 4 ];
                newValue += mapData.data[ id + mappingColor + 4 * size - 4 ];
                newValue += mapData.data[ id + mappingColor - 4 * size + 4 ];
                newValue += mapData.data[ id + mappingColor - 4 * size - 4 ];

                newValue /= 9;

                mapData.data[ id + mappingColor ] = newValue;

            }

        }

        this.ctx.putImageData( mapData, x + deltaX - size / 2, y + deltaY - size / 2 );

    };

    function smoothX2 () {

        var mappingColor = 2;
        var dist;
        var newValue;
        var id;

        var deltaX = mappingSize * 3;
        var deltaY = mappingSize * 3;

        var mapData = this.ctx.getImageData( x + deltaX - size / 2, y + deltaY - size / 2, size, size );

        var sum = 0;
        var pixelCount = 0;

        for ( var i = -size / 2 + 2, il = size / 2 - 2; i < il; i ++ ) {

            for ( var j = -size / 2 + 2, jl = size / 2 - 2; j < jl; j ++ ) {

                dist = Math.sqrt( i * i + j * j );
                if ( dist > size / 2 ) continue;

                id = 4 * ( ( i + size / 2 ) + size * ( j + size / 2 ) );

                sum += mapData.data[ id + mappingColor ];
                pixelCount ++;

            }

        }

        var middleValue = sum / pixelCount;
        var k;

        for ( var i = -size / 2 + 2, il = size / 2 - 2; i < il; i ++ ) {

            for ( var j = -size / 2 + 2, jl = size / 2 - 2; j < jl; j ++ ) {

                dist = Math.sqrt( i * i + j * j );
                if ( dist > size / 2 ) continue;

                id = 4 * ( ( i + size / 2 ) + size * ( j + size / 2 ) );

                k = Math.min( 2 * dist / size, 0.5 );

                mapData.data[ id + mappingColor ] = ( 1 - k ) * mapData.data[ id + mappingColor ] + k * middleValue;

            }

        }

        this.ctx.putImageData( mapData, x + deltaX - size / 2, y + deltaY - size / 2 );

    };

    function noise () {

        var mappingColor = 2;
        var dist;
        var newValue;
        var id;

        var deltaX = mappingSize * 3;
        var deltaY = mappingSize * 3;

        var mapData = this.ctx.getImageData( x + deltaX - size / 2, y + deltaY - size / 2, size, size );

        for ( var i = -size / 2 + 1, il = size / 2 - 1; i < il; i ++ ) {

            for ( var j = -size / 2 + 1, jl = size / 2 - 1; j < jl; j ++ ) {

                dist = Math.sqrt( i * i + j * j );
                if ( dist > size / 2 ) continue;

                id = 4 * ( ( i + size / 2 ) + size * ( j + size / 2 ) );

                newValue  = mapData.data[ id + mappingColor ];
                newValue += mapData.data[ id + mappingColor + 4 ];
                newValue += mapData.data[ id + mappingColor - 4 ];
                newValue += mapData.data[ id + mappingColor + 4 * size ];
                newValue += mapData.data[ id + mappingColor - 4 * size ];
                newValue += mapData.data[ id + mappingColor + 4 * size + 4 ];
                newValue += mapData.data[ id + mappingColor + 4 * size - 4 ];
                newValue += mapData.data[ id + mappingColor - 4 * size + 4 ];
                newValue += mapData.data[ id + mappingColor - 4 * size - 4 ];

                newValue /= 9;

                mapData.data[ id + mappingColor ] = newValue + 5 * ( Math.random() - 0.5 );

            }

        }

        this.ctx.putImageData( mapData, x + deltaX - size / 2, y + deltaY - size / 2 );

    };

    // zero bg ground

    paint.call( this, 0.08, 0.001, 0 );

    switch ( type ) {

        case 'SMOOTHX2':

            smoothX2.call( this );
            break;

        case 'SMOOTH':

            smooth.call( this );
            break;

        case 'DOWN':

            paint.call( this, 1, -0.02, 14 );
            break;

        case 'UP':

            paint.call( this, 1, 0.02, 14 );
            break;

        case 'GRASS01':

            paint.call( this, 1, 0.05, 1 );
            break;

        case 'GRASS02':

            paint.call( this, 1, 0.05, 2 );
            break;

        case 'CLIFF':

            paint.call( this, 1, 0.05, 4 );
            break;

        case 'SNOW':

            paint.call( this, 1, 0.05, 5 );
            break;

        case 'SWAMP':

            paint.call( this, 1, 0.05, 6 );
            break;

        case 'ERASER':

            erase.call( this );
            break;

        case 'NOISE':

            noise.call( this );
            break;

    }

    //

    this.updateMapping();

};

Editor.Terrain.prototype.saveState = function () {

    for ( var i = this.activeState + 1, il = this.states.length; i < il; i ++ ) {

        this.states.pop();

    }

    this.activeState ++;

    this.states.push( this.canvas.toDataURL() );

};

Editor.Terrain.prototype.undo = function () {

    var self = this;

    var canvasPic = new Image();

    if ( ! this.states[ this.activeState - 1 ] ) {

        return;

    }

    this.activeState --;

    canvasPic.src = this.states[ this.activeState ];
    canvasPic.onload = function () {

        self.ctx.drawImage( canvasPic, 0, 0 );
        self.updateMapping();

    };

};

Editor.Terrain.prototype.redo = function () {

    var self = this;

    var canvasPic = new Image();

    if ( ! this.states[ this.activeState + 1 ] ) {

        return;

    }

    this.activeState ++;

    canvasPic.src = this.states[ this.activeState ];

    canvasPic.onload = function () {

        self.ctx.drawImage( canvasPic, 0, 0 );
        self.updateMapping();

    };

};

Editor.Terrain.prototype.exportDev = function () {

    var a = document.createElement('a');
    document.body.appendChild( a );

    a.download = 'mappingDev.png';
    a.href = this.canvas.toDataURL().replace( 'image/png', 'image/octet-stream' );

    var evObj = document.createEvent('Events');
    evObj.initEvent( 'click', true, false );
    a.dispatchEvent( evObj );

};

Editor.Terrain.prototype.exportForStatic = function () {

    var a = document.createElement('a');
    document.body.appendChild( a );

    var self = this;

    var size = 512;

    var offset = [ 8, 0, -8 ];

    for ( var j = 0; j < 3; j ++ ) {

        for ( var i = 0; i < 3; i ++ ) {

            setTimeout( function ( ti, tj ) {

                var canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;

                var ctx = canvas.getContext('2d');

                var part = self.ctx.getImageData( ti * size + 3 * size + offset[ ti ], tj * size + 3 * size + offset[ tj ], size, size );
                ctx.putImageData( part, 0, 0 );

                a.download = 'map' + ( ti + tj * 3 + 1 ) + '.png';
                a.href = canvas.toDataURL().replace( 'image/png', 'image/octet-stream' );

                var evObj = document.createEvent('Events');
                evObj.initEvent( 'click', true, false );
                a.dispatchEvent( evObj );

            }, 100 * i, i, j );

        }

    }

};

Editor.Terrain.prototype.export = function () {

    var a = document.createElement('a');
    document.body.appendChild( a );

    var self = this;

    for ( var i = 0; i < 9; i ++ ) {

        setTimeout( function ( id ) {

            a.download = 'map' + ( id + 1 ) + '.png';
            a.href = self.mappingsList[ id ].canvas.toDataURL().replace( 'image/png', 'image/octet-stream' );

            var evObj = document.createEvent('Events');
            evObj.initEvent( 'click', true, false );
            a.dispatchEvent( evObj );

        }, 100 * i, i );

    }

};


/*
 * GOT
 * @author: ohmed
*/

Editor.Flora = function () {

    this.activeState = -1;

    this.trees = GOT.landscape.floraObjects;

    this.groupsToUpdate = {};
    this.tmpMeshes = [];

};

Editor.Flora.prototype.init = function () {

    this.saveState();

};

Editor.Flora.prototype.saveState = function () {

    this.activeState ++;

    var trees = [];
    var tree;

    for ( var i = 0, il = GOT.landscape.floraObjects.length; i < il; i ++ ) {

        tree = GOT.landscape.floraObjects[ i ];

        if ( tree.instance && tree.instance.active !== false ) {

            trees.push( tree );

        }

    }

    GOT.landscape.floraObjects = trees;
    this.trees = trees;

};

Editor.Flora.prototype.undo = function () {

    if ( this.activeState === -1 ) {

        return;

    }

    this.activeState --;

    var trees = this.trees;

    for ( var i = 0, il = trees.length; i < il; i ++ ) {

        if ( trees[ i ].eid > this.activeState ) {

            trees[ i ].instance.active = false;

        }

    }

    this.update( true );

};

Editor.Flora.prototype.redo = function () {

    if ( this.activeState === -1 ) {

        return;

    }

    this.activeState ++;

    var trees = this.trees;

    for ( var i = 0, il = trees.length; i < il; i ++ ) {

        if ( trees[ i ].eid > this.activeState ) {

            trees[ i ].instance.active = false;

        } else if ( trees[ i ].instance ) {

            trees[ i ].instance.active = true;

        }

    }

    this.update( true );

};

Editor.Flora.prototype.canPlace = function ( x, z, type ) {

    var tree;

    for ( var i = 0, il = this.trees.length; i < il; i ++ ) {

        tree = this.trees[ i ];

        if ( Math.sqrt( Math.pow( tree.position.x - x, 2 ) + Math.pow( tree.position.z - z, 2 ) ) < 12 ) {

            return false;

        }

    }

    return true;

};

Editor.Flora.prototype.update = function ( force ) {

    var block;

    if ( force ) {

        this.groupsToUpdate = {};
        var block;

        for ( var i = 0, il = GOT.landscape.flora.blocks.length; i < il; i ++ ) {

            block = GOT.landscape.flora.blocks[ i ];
            this.groupsToUpdate[ block.uuid ] = block;

        }

    }

    for ( var i in this.groupsToUpdate ) {

        block = this.groupsToUpdate[ i ];

        if ( block.instances.length > 0 ) {

            GOT.view.scene.remove( block.getInternal('mesh') );
            block.updateGeometry();
            GOT.view.scene.add( block.getInternal('mesh') );

        }

    }

    this.groupsToUpdate = {};

    for ( var i = 0, il = this.tmpMeshes.length; i < il; i ++ ) {

        GOT.view.scene.remove( this.tmpMeshes[ i ] );

    }

    GOT.view.scene.remove( GOT.landscape.flora.globalSG.getInternal('mesh') );
    GOT.landscape.flora.globalSG.updateGeometry();
    GOT.view.scene.add( GOT.landscape.flora.globalSG.getInternal('mesh') );

    this.tmpMeshes.length = 0;

};

Editor.Flora.prototype.updateYPositions = function () {

    var mapSize = GOT.landscape.mapSize;

    var tree;
    var treePosition;

    for ( var i = 0, il = this.trees.length; i < il; i ++ ) {

        tree = this.trees[ i ];
        treePosition = tree.position;
        treePosition.y = GOT.landscape.terrain.getPointHeight( treePosition.x / mapSize + 0.5, treePosition.z / mapSize + 0.5 );

        tree.instance.position.y = treePosition.y;
        tree.instance.update();

    }

    this.update( true );

};

Editor.Flora.prototype.draw = function ( marker ) {

    var mapSize = GOT.landscape.mapSize;

    var type = ( marker.subtype.split('/').length > 1 ) ? marker.subtype.split('/')[ 0 ] : marker.subtype;
    var subtype = ( marker.subtype.split('/').length > 1 ) ? marker.subtype.split('/')[ 1 ] : '';

    var position = { x: marker.position.x, y: marker.position.y };
    var obejctPos = new NWE.Vec3();
    var size = marker.size;

    obejctPos.y = GOT.landscape.terrain.getPointHeight( position.x, position.y );

    position.x = mapSize * ( position.x - 0.5 );
    position.y = mapSize * ( position.y - 0.5 );

    var mesh, object;

    for ( var i = 0, il = size * size / 400; i < il; i ++ ) {

        obejctPos.x = ( position.x + 2 * size * ( Math.random() - 0.5 ) );
        obejctPos.z = ( position.y + 2 * size * ( Math.random() - 0.5 ) );

        if ( this.canPlace( obejctPos.x, obejctPos.z ) && Math.sqrt( Math.pow( obejctPos.x - position.x, 2 ) + Math.pow( obejctPos.z - position.y, 2 ) ) < size ) {

            object = new Building[ type ]({
                        name: type,
                        subtype: subtype,
                        position: obejctPos.clone(),
                        rotation: new NWE.Vec3()
                    });

            object.eid = this.activeState + 1;
            object.instance.eid = this.activeState + 1;

            GOT.landscape.floraObjects.push( object );

            this.groupsToUpdate[ object.instance.group.uuid ] = object.instance.group;

            mesh = new NWE.gfx.Mesh( GOT.ResourceMng.getGeometry( Building.list.flora[ type + subtype ].model ), new NWE.gfx.MeshBasicMaterial({ color: 0xff0000 }) );
            mesh.position.set( obejctPos.x, obejctPos.y, obejctPos.z );
            GOT.view.scene.add( mesh );

            this.tmpMeshes.push( mesh );

        }

    }

};

Editor.Flora.prototype.erase = function ( marker ) {

    var mapSize = GOT.landscape.mapSize;

    var position = { x: marker.position.x, y: marker.position.y };
    var size = marker.size;

    position.x = mapSize * ( position.x - 0.5 );
    position.y = mapSize * ( position.y - 0.5 );

    var tree;

    for ( var i = 0, il = this.trees.length; i < il; i ++ ) {

        tree = this.trees[ i ];

        if ( Math.sqrt( Math.pow( tree.position.x - position.x, 2 ) + Math.pow( tree.position.z - position.y, 2 ) ) < size ) {

            if ( tree.instance ) {

                tree.instance.active = false;

            }

        }

    }

    this.update( true );

};

Editor.Flora.prototype.export = function () {

    var data = [];
    var object;

    for ( var i = 0, il = this.trees.length; i < il; i ++ ) {

        object = this.trees[ i ];

        if ( ! object.instance.active ) {

            continue;

        }

        data.push({

            type: object.type,
            name: object.name,
            subtype: object.subtype,

            position: { x: object.position.x, y: object.position.y, z: object.position.z },
            scale: { x: object.scale.x, y: object.scale.y, z: object.scale.z },
            rotation: { x: object.rotation.x, y: object.rotation.y, z: object.rotation.z }

        });

    }

    data = JSON.stringify( data );

    var a = document.createElement('a');
    document.body.appendChild( a );
    a.download = 'flora.json';

    a.href = 'data:text/json;charset=utf8,' + encodeURIComponent( data );

    var evObj = document.createEvent('Events');
    evObj.initEvent( 'click', true, false );
    a.dispatchEvent( evObj );

};


/*
 * GOT
 * @author: ohmed
*/

Editor.Decorations = function () {

    this.activeState = -1;

    this.decorations = GOT.landscape.decorationsObjects;

    this.groupsToUpdate = {};
    this.tmpMeshes = [];

};

Editor.Decorations.prototype.init = function () {

    this.saveState();

};

Editor.Decorations.prototype.saveState = function () {

    this.activeState ++;

    var decorations = [];
    var decoration;

    for ( var i = 0, il = GOT.landscape.decorationsObjects.length; i < il; i ++ ) {

        decoration = GOT.landscape.decorationsObjects[ i ];

        if ( decoration.instance && decoration.instance.active !== false ) {

            decorations.push( decoration );

        }

    }

    GOT.landscape.decorationsObjects = decorations;
    this.decorations = decorations;

};

Editor.Decorations.prototype.undo = function () {

    if ( this.activeState === -1 ) {

        return;

    }

    this.activeState --;

    var decorations = this.decorations;

    for ( var i = 0, il = decorations.length; i < il; i ++ ) {

        if ( decorations[ i ].eid > this.activeState ) {

            decorations[ i ].instance.active = false;

        }

    }

    this.update( true );

};

Editor.Decorations.prototype.redo = function () {

    if ( this.activeState === -1 ) {

        return;

    }

    this.activeState ++;

    var decorations = this.decorations;

    for ( var i = 0, il = decorations.length; i < il; i ++ ) {

        if ( decorations[ i ].eid > this.activeState ) {

            decorations[ i ].instance.active = false;

        } else if ( decorations[ i ].instance ) {

            decorations[ i ].instance.active = true;

        }

    }

    this.update( true );

};

Editor.Decorations.prototype.update = function ( force ) {

    var block;

    if ( force ) {

        this.groupsToUpdate = {};
        var block;

        for ( var i = 0, il = GOT.landscape.decorations.blocks.length; i < il; i ++ ) {

            block = GOT.landscape.decorations.blocks[ i ];
            this.groupsToUpdate[ block.uuid ] = block;

        }

    }

    for ( var i in this.groupsToUpdate ) {

        block = this.groupsToUpdate[ i ];

        if ( block.instances.length > 0 ) {

            GOT.view.scene.remove( block.getInternal('mesh') );
            block.updateGeometry();
            GOT.view.scene.add( block.getInternal('mesh') );

        }

    }

    this.groupsToUpdate = {};

    for ( var i = 0, il = this.tmpMeshes.length; i < il; i ++ ) {

        GOT.view.scene.remove( this.tmpMeshes[ i ] );

    }

    this.tmpMeshes.length = 0;

};

Editor.Decorations.prototype.updateYPositions = function () {

    var mapSize = GOT.landscape.mapSize;
    var decoration;

    for ( var i = 0, il = this.decorations.length; i < il; i ++ ) {

        decoration = this.decorations[ i ];
        decoration.y = GOT.landscape.terrain.getPointHeight( decoration.x / mapSize + 0.5, decoration.y / mapSize + 0.5 );

    }

    this.update( true );

};

Editor.Decorations.prototype.draw = function ( marker ) {

    var mapSize = GOT.landscape.mapSize;

    var type = ( marker.subtype.split('/').length > 1 ) ? marker.subtype.split('/')[ 0 ] : marker.subtype;
    var subtype = ( marker.subtype.split('/').length > 1 ) ? marker.subtype.split('/')[ 1 ] : '';

    var obejctPos = new NWE.Vec3( marker.position.x, GOT.landscape.terrain.getPointHeight( marker.position.x, marker.position.y ), marker.position.y );

    obejctPos.x = mapSize * ( obejctPos.x - 0.5 );
    obejctPos.z = mapSize * ( obejctPos.z - 0.5 );

    //

    object = new Decoration[ type ]({
                name: type,
                subtype: subtype,
                position: obejctPos.clone(),
                rotation: new NWE.Vec3()
            });

    object.eid = this.activeState + 1;
    object.instance.eid = this.activeState + 1;

    GOT.landscape.decorationsObjects.push( object );

    this.groupsToUpdate[ object.instance.group.uuid ] = object.instance.group;

    this.update();

};

Editor.Decorations.prototype.erase = function ( marker ) {

    var self = this;

    var mapSize = GOT.landscape.mapSize;

    var position = { x: marker.position.x, y: marker.position.y };
    var size = marker.size;

    position.x = mapSize * ( position.x - 0.5 );
    position.y = mapSize * ( position.y - 0.5 );

    var decoration;

    for ( var i = 0, il = this.decorations.length; i < il; i ++ ) {

        decoration = this.decorations[ i ];

        if ( Math.sqrt( Math.pow( decoration.position.x - position.x, 2 ) + Math.pow( decoration.position.z - position.y, 2 ) ) < size ) {

            if ( decoration.instance ) {

                decoration.instance.active = false;

            }

        }

    }

    this.update( true );

};

Editor.Decorations.prototype.export = function () {

    var data = [];
    var object;

    for ( var i = 0, il = this.decorations.length; i < il; i ++ ) {

        object = this.decorations[ i ];

        if ( ! object.instance.active ) {

            continue;

        }

        data.push({

            type: object.type,
            name: object.name,
            subtype: object.subtype,

            position: { x: object.position.x, y: object.position.y, z: object.position.z },
            scale: { x: object.scale.x, y: object.scale.y, z: object.scale.z },
            rotation: { x: object.rotation.x, y: object.rotation.y, z: object.rotation.z }

        });

    }

    data = JSON.stringify( data );

    var a = document.createElement('a');
    document.body.appendChild( a );
    a.download = 'decorations.json';

    a.href = 'data:text/json;charset=utf8,' + encodeURIComponent( data );

    var evObj = document.createEvent('Events');
    evObj.initEvent( 'click', true, false );
    a.dispatchEvent( evObj );

};


